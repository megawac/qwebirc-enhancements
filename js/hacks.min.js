function $A(iterable) {
    if (iterable.item) {
        for (var l = iterable.length, array = Array(l); l--; ) array[l] = iterable[l];
        return array;
    }
    return Array.prototype.slice.call(iterable);
}

function $arguments(i) {
    return function() {
        return arguments[i];
    };
}

function $chk(obj) {
    return !(!obj && 0 !== obj);
}

function $clear(timer) {
    return clearTimeout(timer), clearInterval(timer), null;
}

function $defined(obj) {
    return void 0 != obj;
}

function $each(iterable, fn, bind) {
    var type = $type(iterable);
    ("arguments" == type || "collection" == type || "array" == type ? Array : Hash).each(iterable, fn, bind);
}

function $empty() {}

function $extend(original, extended) {
    for (var key in extended || {}) original[key] = extended[key];
    return original;
}

function $H(object) {
    return new Hash(object);
}

function $lambda(value) {
    return "function" == $type(value) ? value : function() {
        return value;
    };
}

function $merge() {
    var args = Array.slice(arguments);
    return args.unshift({}), $mixin.apply(null, args);
}

function $mixin(mix) {
    for (var i = 1, l = arguments.length; l > i; i++) {
        var object = arguments[i];
        if ("object" == $type(object)) for (var key in object) {
            var op = object[key], mp = mix[key];
            mix[key] = mp && "object" == $type(op) && "object" == $type(mp) ? $mixin(mp, op) : $unlink(op);
        }
    }
    return mix;
}

function $pick() {
    for (var i = 0, l = arguments.length; l > i; i++) if (void 0 != arguments[i]) return arguments[i];
    return null;
}

function $random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

function $splat(obj) {
    var type = $type(obj);
    return type ? "array" != type && "arguments" != type ? [ obj ] : obj : [];
}

function $try() {
    for (var i = 0, l = arguments.length; l > i; i++) try {
        return arguments[i]();
    } catch (e) {}
    return null;
}

function $type(obj) {
    if (void 0 == obj) return !1;
    if (obj.$family) return "number" != obj.$family.name || isFinite(obj) ? obj.$family.name : !1;
    if (obj.nodeName) switch (obj.nodeType) {
      case 1:
        return "element";

      case 3:
        return /\S/.test(obj.nodeValue) ? "textnode" : "whitespace";
    } else if ("number" == typeof obj.length) {
        if (obj.callee) return "arguments";
        if (obj.item) return "collection";
    }
    return typeof obj;
}

function $unlink(object) {
    var unlinked;
    switch ($type(object)) {
      case "object":
        unlinked = {};
        for (var p in object) unlinked[p] = $unlink(object[p]);
        break;

      case "hash":
        unlinked = new Hash(object);
        break;

      case "array":
        unlinked = [];
        for (var i = 0, l = object.length; l > i; i++) unlinked[i] = $unlink(object[i]);
        break;

      default:
        return object;
    }
    return unlinked;
}

function $exec(text) {
    if (!text) return text;
    if (window.execScript) window.execScript(text); else {
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript"), script[Browser.Engine.webkit && 420 > Browser.Engine.version ? "innerText" : "text"] = text, 
        document.head.appendChild(script), document.head.removeChild(script);
    }
    return text;
}

function Class(params) {
    params instanceof Function && (params = {
        initialize: params
    });
    var newClass = function() {
        if (Object.reset(this), newClass._prototyping) return this;
        this._current = $empty;
        var value = this.initialize ? this.initialize.apply(this, arguments) : this;
        return delete this._current, delete this.caller, value;
    }.extend(this);
    return newClass.implement(params), newClass.constructor = Class, newClass.prototype.constructor = newClass, 
    newClass;
}

function qwebirc_ui_onbeforeunload(e) {
    if (new Date().getTime() - document.window.steamlink > 100) {
        var message = "This action will close all active IRC connections.";
        return (e = e || window.event) && (e.returnValue = message), message;
    }
}

var MooTools = {
    version: "1.2.6",
    build: "a3be7a0ef5205eb655c4ee11e8cbedcb3f2ffa95"
}, Native = function(options) {
    options = options || {};
    var name = options.name, legacy = options.legacy, protect = options.protect, methods = options.implement, generics = options.generics, initialize = options.initialize, afterImplement = options.afterImplement || function() {}, object = initialize || legacy;
    if (generics = generics !== !1, object.constructor = Native, object.$family = {
        name: "native"
    }, legacy && initialize && (object.prototype = legacy.prototype), object.prototype.constructor = object, 
    name) {
        var family = name.toLowerCase();
        object.prototype.$family = {
            name: family
        }, Native.typize(object, family);
    }
    var add = function(obj, name, method, force) {
        return protect && !force && obj.prototype[name] || (obj.prototype[name] = method), 
        generics && Native.genericize(obj, name, protect), afterImplement.call(obj, name, method), 
        obj;
    };
    return object.alias = function(a1, a2, a3) {
        if ("string" == typeof a1) {
            var pa1 = this.prototype[a1];
            if (a1 = pa1) return add(this, a2, a1, a3);
        }
        for (var a in a1) this.alias(a, a1[a], a2);
        return this;
    }, object.implement = function(a1, a2, a3) {
        if ("string" == typeof a1) return add(this, a1, a2, a3);
        for (var p in a1) add(this, p, a1[p], a2);
        return this;
    }, methods && object.implement(methods), object;
};

Native.genericize = function(object, property, check) {
    check && object[property] || "function" != typeof object.prototype[property] || (object[property] = function() {
        var args = Array.prototype.slice.call(arguments);
        return object.prototype[property].apply(args.shift(), args);
    });
}, Native.implement = function(objects, properties) {
    for (var i = 0, l = objects.length; l > i; i++) objects[i].implement(properties);
}, Native.typize = function(object, family) {
    object.type || (object.type = function(item) {
        return $type(item) === family;
    });
}, function() {
    var natives = {
        Array: Array,
        Date: Date,
        Function: Function,
        Number: Number,
        RegExp: RegExp,
        String: String
    };
    for (var n in natives) new Native({
        name: n,
        initialize: natives[n],
        protect: !0
    });
    var types = {
        "boolean": Boolean,
        "native": Native,
        object: Object
    };
    for (var t in types) Native.typize(types[t], t);
    var generics = {
        Array: [ "concat", "indexOf", "join", "lastIndexOf", "pop", "push", "reverse", "shift", "slice", "sort", "splice", "toString", "unshift", "valueOf" ],
        String: [ "charAt", "charCodeAt", "concat", "indexOf", "lastIndexOf", "match", "replace", "search", "slice", "split", "substr", "substring", "toLowerCase", "toUpperCase", "valueOf" ]
    };
    for (var g in generics) for (var i = generics[g].length; i--; ) Native.genericize(natives[g], generics[g][i], !0);
}();

var Hash = new Native({
    name: "Hash",
    initialize: function(object) {
        "hash" == $type(object) && (object = $unlink(object.getClean()));
        for (var key in object) this[key] = object[key];
        return this;
    }
});

Hash.implement({
    forEach: function(fn, bind) {
        for (var key in this) this.hasOwnProperty(key) && fn.call(bind, this[key], key, this);
    },
    getClean: function() {
        var clean = {};
        for (var key in this) this.hasOwnProperty(key) && (clean[key] = this[key]);
        return clean;
    },
    getLength: function() {
        var length = 0;
        for (var key in this) this.hasOwnProperty(key) && length++;
        return length;
    }
}), Hash.alias("forEach", "each"), Array.implement({
    forEach: function(fn, bind) {
        for (var i = 0, l = this.length; l > i; i++) fn.call(bind, this[i], i, this);
    }
}), Array.alias("forEach", "each");

var $time = Date.now || function() {
    return +new Date();
}, Browser = $merge({
    Engine: {
        name: "unknown",
        version: 0
    },
    Platform: {
        name: void 0 != window.orientation ? "ipod" : (navigator.platform.match(/mac|win|linux/i) || [ "other" ])[0].toLowerCase()
    },
    Features: {
        xpath: !!document.evaluate,
        air: !!window.runtime,
        query: !!document.querySelector
    },
    Plugins: {},
    Engines: {
        presto: function() {
            return window.opera ? arguments.callee.caller ? 960 : document.getElementsByClassName ? 950 : 925 : !1;
        },
        trident: function() {
            return window.ActiveXObject ? window.XMLHttpRequest ? document.querySelectorAll ? 6 : 5 : 4 : !1;
        },
        webkit: function() {
            return navigator.taintEnabled ? !1 : Browser.Features.xpath ? Browser.Features.query ? 525 : 420 : 419;
        },
        gecko: function() {
            return document.getBoxObjectFor || null != window.mozInnerScreenX ? document.getElementsByClassName ? 19 : 18 : !1;
        }
    }
}, Browser || {});

Browser.Platform[Browser.Platform.name] = !0, Browser.detect = function() {
    for (var engine in this.Engines) {
        var version = this.Engines[engine]();
        if (version) {
            this.Engine = {
                name: engine,
                version: version
            }, this.Engine[engine] = this.Engine[engine + version] = !0;
            break;
        }
    }
    return {
        name: engine,
        version: version
    };
}, Browser.detect(), Browser.Request = function() {
    return $try(function() {
        return new XMLHttpRequest();
    }, function() {
        return new ActiveXObject("MSXML2.XMLHTTP");
    }, function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
    });
}, Browser.Features.xhr = !!Browser.Request(), Browser.Plugins.Flash = function() {
    var version = ($try(function() {
        return navigator.plugins["Shockwave Flash"].description;
    }, function() {
        return new ActiveXObject("ShockwaveFlash.ShockwaveFlash").GetVariable("$version");
    }) || "0 r0").match(/\d+/g);
    return {
        version: parseInt(version[0] || "0." + version[1], 10) || 0,
        build: parseInt(version[2], 10) || 0
    };
}(), Native.UID = 1;

var $uid = Browser.Engine.trident ? function(item) {
    return (item.uid || (item.uid = [ Native.UID++ ]))[0];
} : function(item) {
    return item.uid || (item.uid = Native.UID++);
}, Window = new Native({
    name: "Window",
    legacy: Browser.Engine.trident ? null : window.Window,
    initialize: function(win) {
        return $uid(win), win.Element || (win.Element = $empty, Browser.Engine.webkit && win.document.createElement("iframe"), 
        win.Element.prototype = Browser.Engine.webkit ? window["[[DOMElement.prototype]]"] : {}), 
        win.document.window = win, $extend(win, Window.Prototype);
    },
    afterImplement: function(property, value) {
        window[property] = Window.Prototype[property] = value;
    }
});

Window.Prototype = {
    $family: {
        name: "window"
    }
}, new Window(window);

var Document = new Native({
    name: "Document",
    legacy: Browser.Engine.trident ? null : window.Document,
    initialize: function(doc) {
        return $uid(doc), doc.head = doc.getElementsByTagName("head")[0], doc.html = doc.getElementsByTagName("html")[0], 
        Browser.Engine.trident && 4 >= Browser.Engine.version && $try(function() {
            doc.execCommand("BackgroundImageCache", !1, !0);
        }), Browser.Engine.trident && doc.window.attachEvent("onunload", function() {
            doc.window.detachEvent("onunload", arguments.callee), doc.head = doc.html = doc.window = null;
        }), $extend(doc, Document.Prototype);
    },
    afterImplement: function(property, value) {
        document[property] = Document.Prototype[property] = value;
    }
});

Document.Prototype = {
    $family: {
        name: "document"
    }
}, new Document(document), Array.implement({
    every: function(fn, bind) {
        for (var i = 0, l = this.length; l > i; i++) if (!fn.call(bind, this[i], i, this)) return !1;
        return !0;
    },
    filter: function(fn, bind) {
        for (var results = [], i = 0, l = this.length; l > i; i++) fn.call(bind, this[i], i, this) && results.push(this[i]);
        return results;
    },
    clean: function() {
        return this.filter($defined);
    },
    indexOf: function(item, from) {
        for (var len = this.length, i = 0 > from ? Math.max(0, len + from) : from || 0; len > i; i++) if (this[i] === item) return i;
        return -1;
    },
    map: function(fn, bind) {
        for (var results = [], i = 0, l = this.length; l > i; i++) results[i] = fn.call(bind, this[i], i, this);
        return results;
    },
    some: function(fn, bind) {
        for (var i = 0, l = this.length; l > i; i++) if (fn.call(bind, this[i], i, this)) return !0;
        return !1;
    },
    associate: function(keys) {
        for (var obj = {}, length = Math.min(this.length, keys.length), i = 0; length > i; i++) obj[keys[i]] = this[i];
        return obj;
    },
    link: function(object) {
        for (var result = {}, i = 0, l = this.length; l > i; i++) for (var key in object) if (object[key](this[i])) {
            result[key] = this[i], delete object[key];
            break;
        }
        return result;
    },
    contains: function(item, from) {
        return -1 != this.indexOf(item, from);
    },
    extend: function(array) {
        for (var i = 0, j = array.length; j > i; i++) this.push(array[i]);
        return this;
    },
    getLast: function() {
        return this.length ? this[this.length - 1] : null;
    },
    getRandom: function() {
        return this.length ? this[$random(0, this.length - 1)] : null;
    },
    include: function(item) {
        return this.contains(item) || this.push(item), this;
    },
    combine: function(array) {
        for (var i = 0, l = array.length; l > i; i++) this.include(array[i]);
        return this;
    },
    erase: function(item) {
        for (var i = this.length; i--; i) this[i] === item && this.splice(i, 1);
        return this;
    },
    empty: function() {
        return this.length = 0, this;
    },
    flatten: function() {
        for (var array = [], i = 0, l = this.length; l > i; i++) {
            var type = $type(this[i]);
            type && (array = array.concat("array" == type || "collection" == type || "arguments" == type ? Array.flatten(this[i]) : this[i]));
        }
        return array;
    },
    hexToRgb: function(array) {
        if (3 != this.length) return null;
        var rgb = this.map(function(value) {
            return 1 == value.length && (value += value), value.toInt(16);
        });
        return array ? rgb : "rgb(" + rgb + ")";
    },
    rgbToHex: function(array) {
        if (3 > this.length) return null;
        if (4 == this.length && 0 == this[3] && !array) return "transparent";
        for (var hex = [], i = 0; 3 > i; i++) {
            var bit = (this[i] - 0).toString(16);
            hex.push(1 == bit.length ? "0" + bit : bit);
        }
        return array ? hex : "#" + hex.join("");
    }
});

try {
    delete Function.prototype.bind;
} catch (e) {}

Function.implement({
    extend: function(properties) {
        for (var property in properties) this[property] = properties[property];
        return this;
    },
    create: function(options) {
        var self = this;
        return options = options || {}, function(event) {
            var args = options.arguments;
            args = void 0 != args ? $splat(args) : Array.slice(arguments, options.event ? 1 : 0), 
            options.event && (args = [ event || window.event ].extend(args));
            var returns = function() {
                return self.apply(options.bind || null, args);
            };
            return options.delay ? setTimeout(returns, options.delay) : options.periodical ? setInterval(returns, options.periodical) : options.attempt ? $try(returns) : returns();
        };
    },
    run: function(args, bind) {
        return this.apply(bind, $splat(args));
    },
    pass: function(args, bind) {
        return this.create({
            bind: bind,
            arguments: args
        });
    },
    bind: function(bind, args) {
        return this.create({
            bind: bind,
            arguments: args
        });
    },
    bindWithEvent: function(bind, args) {
        return this.create({
            bind: bind,
            arguments: args,
            event: !0
        });
    },
    attempt: function(args, bind) {
        return this.create({
            bind: bind,
            arguments: args,
            attempt: !0
        })();
    },
    delay: function(delay, bind, args) {
        return this.create({
            bind: bind,
            arguments: args,
            delay: delay
        })();
    },
    periodical: function(periodical, bind, args) {
        return this.create({
            bind: bind,
            arguments: args,
            periodical: periodical
        })();
    }
}), Number.implement({
    limit: function(min, max) {
        return Math.min(max, Math.max(min, this));
    },
    round: function(precision) {
        return precision = Math.pow(10, precision || 0), Math.round(this * precision) / precision;
    },
    times: function(fn, bind) {
        for (var i = 0; this > i; i++) fn.call(bind, i, this);
    },
    toFloat: function() {
        return parseFloat(this);
    },
    toInt: function(base) {
        return parseInt(this, base || 10);
    }
}), Number.alias("times", "each"), function(math) {
    var methods = {};
    math.each(function(name) {
        Number[name] || (methods[name] = function() {
            return Math[name].apply(null, [ this ].concat($A(arguments)));
        });
    }), Number.implement(methods);
}([ "abs", "acos", "asin", "atan", "atan2", "ceil", "cos", "exp", "floor", "log", "max", "min", "pow", "sin", "sqrt", "tan" ]);

try {
    delete String.prototype.contains;
} catch (e) {}

String.implement({
    test: function(regex, params) {
        return ("string" == typeof regex ? RegExp(regex, params) : regex).test(this);
    },
    contains: function(string, separator) {
        return separator ? (separator + this + separator).indexOf(separator + string + separator) > -1 : this.indexOf(string) > -1;
    },
    trim: function() {
        return this.replace(/^\s+|\s+$/g, "");
    },
    clean: function() {
        return this.replace(/\s+/g, " ").trim();
    },
    camelCase: function() {
        return this.replace(/-\D/g, function(match) {
            return match.charAt(1).toUpperCase();
        });
    },
    hyphenate: function() {
        return this.replace(/[A-Z]/g, function(match) {
            return "-" + match.charAt(0).toLowerCase();
        });
    },
    capitalize: function() {
        return this.replace(/\b[a-z]/g, function(match) {
            return match.toUpperCase();
        });
    },
    escapeRegExp: function() {
        return this.replace(/([-.*+?^${}()|[\]\/\\])/g, "\\$1");
    },
    toInt: function(base) {
        return parseInt(this, base || 10);
    },
    toFloat: function() {
        return parseFloat(this);
    },
    hexToRgb: function(array) {
        var hex = this.match(/^#?(\w{1,2})(\w{1,2})(\w{1,2})$/);
        return hex ? hex.slice(1).hexToRgb(array) : null;
    },
    rgbToHex: function(array) {
        var rgb = this.match(/\d{1,3}/g);
        return rgb ? rgb.rgbToHex(array) : null;
    },
    stripScripts: function(option) {
        var scripts = "", text = this.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function() {
            return scripts += arguments[1] + "\n", "";
        });
        return option === !0 ? $exec(scripts) : "function" == $type(option) && option(scripts, text), 
        text;
    },
    substitute: function(object, regexp) {
        return this.replace(regexp || /\\?\{([^{}]+)\}/g, function(match, name) {
            return "\\" == match.charAt(0) ? match.slice(1) : void 0 != object[name] ? object[name] : "";
        });
    }
}), Hash.implement({
    has: Object.prototype.hasOwnProperty,
    keyOf: function(value) {
        for (var key in this) if (this.hasOwnProperty(key) && this[key] === value) return key;
        return null;
    },
    hasValue: function(value) {
        return null !== Hash.keyOf(this, value);
    },
    extend: function(properties) {
        return Hash.each(properties || {}, function(value, key) {
            Hash.set(this, key, value);
        }, this), this;
    },
    combine: function(properties) {
        return Hash.each(properties || {}, function(value, key) {
            Hash.include(this, key, value);
        }, this), this;
    },
    erase: function(key) {
        return this.hasOwnProperty(key) && delete this[key], this;
    },
    get: function(key) {
        return this.hasOwnProperty(key) ? this[key] : null;
    },
    set: function(key, value) {
        return (!this[key] || this.hasOwnProperty(key)) && (this[key] = value), this;
    },
    empty: function() {
        return Hash.each(this, function(value, key) {
            delete this[key];
        }, this), this;
    },
    include: function(key, value) {
        return void 0 == this[key] && (this[key] = value), this;
    },
    map: function(fn, bind) {
        var results = new Hash();
        return Hash.each(this, function(value, key) {
            results.set(key, fn.call(bind, value, key, this));
        }, this), results;
    },
    filter: function(fn, bind) {
        var results = new Hash();
        return Hash.each(this, function(value, key) {
            fn.call(bind, value, key, this) && results.set(key, value);
        }, this), results;
    },
    every: function(fn, bind) {
        for (var key in this) if (this.hasOwnProperty(key) && !fn.call(bind, this[key], key)) return !1;
        return !0;
    },
    some: function(fn, bind) {
        for (var key in this) if (this.hasOwnProperty(key) && fn.call(bind, this[key], key)) return !0;
        return !1;
    },
    getKeys: function() {
        var keys = [];
        return Hash.each(this, function(value, key) {
            keys.push(key);
        }), keys;
    },
    getValues: function() {
        var values = [];
        return Hash.each(this, function(value) {
            values.push(value);
        }), values;
    },
    toQueryString: function(base) {
        var queryString = [];
        return Hash.each(this, function(value, key) {
            base && (key = base + "[" + key + "]");
            var result;
            switch ($type(value)) {
              case "object":
                result = Hash.toQueryString(value, key);
                break;

              case "array":
                var qs = {};
                value.each(function(val, i) {
                    qs[i] = val;
                }), result = Hash.toQueryString(qs, key);
                break;

              default:
                result = key + "=" + encodeURIComponent(value);
            }
            void 0 != value && queryString.push(result);
        }), queryString.join("&");
    }
}), Hash.alias({
    keyOf: "indexOf",
    hasValue: "contains"
});

var Event = new Native({
    name: "Event",
    initialize: function(event, win) {
        win = win || window;
        var doc = win.document;
        if (event = event || win.event, event.$extended) return event;
        this.$extended = !0;
        for (var type = event.type, target = event.target || event.srcElement; target && 3 == target.nodeType; ) target = target.parentNode;
        if (type.test(/key/)) {
            var code = event.which || event.keyCode, key = Event.Keys.keyOf(code);
            if ("keydown" == type) {
                var fKey = code - 111;
                fKey > 0 && 13 > fKey && (key = "f" + fKey);
            }
            key = key || String.fromCharCode(code).toLowerCase();
        } else if (type.match(/(click|mouse|menu)/i)) {
            doc = doc.compatMode && "CSS1Compat" != doc.compatMode ? doc.body : doc.html;
            var page = {
                x: event.pageX || event.clientX + doc.scrollLeft,
                y: event.pageY || event.clientY + doc.scrollTop
            }, client = {
                x: event.pageX ? event.pageX - win.pageXOffset : event.clientX,
                y: event.pageY ? event.pageY - win.pageYOffset : event.clientY
            };
            if (type.match(/DOMMouseScroll|mousewheel/)) var wheel = event.wheelDelta ? event.wheelDelta / 120 : -(event.detail || 0) / 3;
            var rightClick = 3 == event.which || 2 == event.button, related = null;
            if (type.match(/over|out/)) {
                switch (type) {
                  case "mouseover":
                    related = event.relatedTarget || event.fromElement;
                    break;

                  case "mouseout":
                    related = event.relatedTarget || event.toElement;
                }
                (function() {
                    for (;related && 3 == related.nodeType; ) related = related.parentNode;
                    return !0;
                }).create({
                    attempt: Browser.Engine.gecko
                })() || (related = !1);
            }
        }
        return $extend(this, {
            event: event,
            type: type,
            page: page,
            client: client,
            rightClick: rightClick,
            wheel: wheel,
            relatedTarget: related,
            target: target,
            code: code,
            key: key,
            shift: event.shiftKey,
            control: event.ctrlKey,
            alt: event.altKey,
            meta: event.metaKey
        });
    }
});

Event.Keys = new Hash({
    enter: 13,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    esc: 27,
    space: 32,
    backspace: 8,
    tab: 9,
    "delete": 46
}), Event.implement({
    stop: function() {
        return this.stopPropagation().preventDefault();
    },
    stopPropagation: function() {
        return this.event.stopPropagation ? this.event.stopPropagation() : this.event.cancelBubble = !0, 
        this;
    },
    preventDefault: function() {
        return this.event.preventDefault ? this.event.preventDefault() : this.event.returnValue = !1, 
        this;
    }
}), Function.prototype.protect = function() {
    return this._protected = !0, this;
}, Object.reset = function(object, key) {
    if (null == key) {
        for (var p in object) Object.reset(object, p);
        return object;
    }
    switch (delete object[key], $type(object[key])) {
      case "object":
        var F = function() {};
        F.prototype = object[key];
        var i = new F();
        object[key] = Object.reset(i);
        break;

      case "array":
        object[key] = $unlink(object[key]);
    }
    return object;
}, new Native({
    name: "Class",
    initialize: Class
}).extend({
    instantiate: function(F) {
        F._prototyping = !0;
        var proto = new F();
        return delete F._prototyping, proto;
    },
    wrap: function(self, key, method) {
        return method._origin && (method = method._origin), function() {
            if (method._protected && null == this._current) throw Error('The method "' + key + '" cannot be called.');
            var caller = this.caller, current = this._current;
            this.caller = current, this._current = arguments.callee;
            var result = method.apply(this, arguments);
            return this._current = current, this.caller = caller, result;
        }.extend({
            _owner: self,
            _origin: method,
            _name: key
        });
    }
}), Class.implement({
    implement: function(key, value) {
        if ("object" == $type(key)) {
            for (var p in key) this.implement(p, key[p]);
            return this;
        }
        var mutator = Class.Mutators[key];
        if (mutator && (value = mutator.call(this, value), null == value)) return this;
        var proto = this.prototype;
        switch ($type(value)) {
          case "function":
            if (value._hidden) return this;
            proto[key] = Class.wrap(this, key, value);
            break;

          case "object":
            var previous = proto[key];
            "object" == $type(previous) ? $mixin(previous, value) : proto[key] = $unlink(value);
            break;

          case "array":
            proto[key] = $unlink(value);
            break;

          default:
            proto[key] = value;
        }
        return this;
    }
}), Class.Mutators = {
    Extends: function(parent) {
        this.parent = parent, this.prototype = Class.instantiate(parent), this.implement("parent", function() {
            var name = this.caller._name, previous = this.caller._owner.parent.prototype[name];
            if (!previous) throw Error('The method "' + name + '" has no parent.');
            return previous.apply(this, arguments);
        }.protect());
    },
    Implements: function(items) {
        $splat(items).each(function(item) {
            item instanceof Function && (item = Class.instantiate(item)), this.implement(item);
        }, this);
    }
};

var Chain = new Class({
    $chain: [],
    chain: function() {
        return this.$chain.extend(Array.flatten(arguments)), this;
    },
    callChain: function() {
        return this.$chain.length ? this.$chain.shift().apply(this, arguments) : !1;
    },
    clearChain: function() {
        return this.$chain.empty(), this;
    }
}), Events = new Class({
    $events: {},
    addEvent: function(type, fn, internal) {
        return type = Events.removeOn(type), fn != $empty && (this.$events[type] = this.$events[type] || [], 
        this.$events[type].include(fn), internal && (fn.internal = !0)), this;
    },
    addEvents: function(events) {
        for (var type in events) this.addEvent(type, events[type]);
        return this;
    },
    fireEvent: function(type, args, delay) {
        return type = Events.removeOn(type), this.$events && this.$events[type] ? (this.$events[type].each(function(fn) {
            fn.create({
                bind: this,
                delay: delay,
                arguments: args
            })();
        }, this), this) : this;
    },
    removeEvent: function(type, fn) {
        return type = Events.removeOn(type), this.$events[type] ? (fn.internal || this.$events[type].erase(fn), 
        this) : this;
    },
    removeEvents: function(events) {
        var type;
        if ("object" == $type(events)) {
            for (type in events) this.removeEvent(type, events[type]);
            return this;
        }
        events && (events = Events.removeOn(events));
        for (type in this.$events) if (!events || events == type) for (var fns = this.$events[type], i = fns.length; i--; i) this.removeEvent(type, fns[i]);
        return this;
    }
});

Events.removeOn = function(string) {
    return string.replace(/^on([A-Z])/, function(full, first) {
        return first.toLowerCase();
    });
};

var Options = new Class({
    setOptions: function() {
        if (this.options = $merge.run([ this.options ].extend(arguments)), !this.addEvent) return this;
        for (var option in this.options) "function" == $type(this.options[option]) && /^on[A-Z]/.test(option) && (this.addEvent(option, this.options[option]), 
        delete this.options[option]);
        return this;
    }
}), Element = new Native({
    name: "Element",
    legacy: window.Element,
    initialize: function(tag, props) {
        var konstructor = Element.Constructors.get(tag);
        return konstructor ? konstructor(props) : "string" == typeof tag ? document.newElement(tag, props) : document.id(tag).set(props);
    },
    afterImplement: function(key, value) {
        Element.Prototype[key] = value, Array[key] || Elements.implement(key, function() {
            for (var items = [], elements = !0, i = 0, j = this.length; j > i; i++) {
                var returns = this[i][key].apply(this[i], arguments);
                items.push(returns), elements && (elements = "element" == $type(returns));
            }
            return elements ? new Elements(items) : items;
        });
    }
});

Element.Prototype = {
    $family: {
        name: "element"
    }
}, Element.Constructors = new Hash();

var IFrame = new Native({
    name: "IFrame",
    generics: !1,
    initialize: function() {
        var params = Array.link(arguments, {
            properties: Object.type,
            iframe: $defined
        }), props = params.properties || {}, iframe = document.id(params.iframe), onload = props.onload || $empty;
        delete props.onload, props.id = props.name = $pick(props.id, props.name, iframe ? iframe.id || iframe.name : "IFrame_" + $time()), 
        iframe = new Element(iframe || "iframe", props);
        var onFrameLoad = function() {
            var host = $try(function() {
                return iframe.contentWindow.location.host;
            });
            if (!host || host == window.location.host) {
                var win = new Window(iframe.contentWindow);
                new Document(iframe.contentWindow.document), $extend(win.Element.prototype, Element.Prototype);
            }
            onload.call(iframe.contentWindow, iframe.contentWindow.document);
        }, contentWindow = $try(function() {
            return iframe.contentWindow;
        });
        return contentWindow && contentWindow.document.body || window.frames[props.id] ? onFrameLoad() : iframe.addListener("load", onFrameLoad), 
        iframe;
    }
}), Elements = new Native({
    initialize: function(elements, options) {
        if (options = $extend({
            ddup: !0,
            cash: !0
        }, options), elements = elements || [], options.ddup || options.cash) {
            for (var uniques = {}, returned = [], i = 0, l = elements.length; l > i; i++) {
                var el = document.id(elements[i], !options.cash);
                if (options.ddup) {
                    if (uniques[el.uid]) continue;
                    uniques[el.uid] = !0;
                }
                el && returned.push(el);
            }
            elements = returned;
        }
        return options.cash ? $extend(elements, this) : elements;
    }
});

Elements.implement({
    filter: function(filter, bind) {
        return filter ? new Elements(Array.filter(this, "string" == typeof filter ? function(item) {
            return item.match(filter);
        } : filter, bind)) : this;
    }
}), function() {
    var createElementAcceptsHTML;
    try {
        var x = document.createElement("<input name=x>");
        createElementAcceptsHTML = "x" == x.name;
    } catch (e) {}
    var escapeQuotes = function(html) {
        return ("" + html).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
    };
    Document.implement({
        newElement: function(tag, props) {
            return props && null != props.checked && (props.defaultChecked = props.checked), 
            createElementAcceptsHTML && props && (tag = "<" + tag, props.name && (tag += ' name="' + escapeQuotes(props.name) + '"'), 
            props.type && (tag += ' type="' + escapeQuotes(props.type) + '"'), tag += ">", delete props.name, 
            delete props.type), this.id(this.createElement(tag)).set(props);
        },
        newTextNode: function(text) {
            return this.createTextNode(text);
        },
        getDocument: function() {
            return this;
        },
        getWindow: function() {
            return this.window;
        },
        id: function() {
            var types = {
                string: function(id, nocash, doc) {
                    return id = doc.getElementById(id), id ? types.element(id, nocash) : null;
                },
                element: function(el, nocash) {
                    if ($uid(el), !nocash && !el.$family && !/^object|embed$/i.test(el.tagName)) {
                        var proto = Element.Prototype;
                        for (var p in proto) el[p] = proto[p];
                    }
                    return el;
                },
                object: function(obj, nocash, doc) {
                    return obj.toElement ? types.element(obj.toElement(doc), nocash) : null;
                }
            };
            return types.textnode = types.whitespace = types.window = types.document = $arguments(0), 
            function(el, nocash, doc) {
                if (el && el.$family && el.uid) return el;
                var type = $type(el);
                return types[type] ? types[type](el, nocash, doc || document) : null;
            };
        }()
    });
}(), null == window.$ && Window.implement({
    $: function(el, nc) {
        return document.id(el, nc, this.document);
    }
}), Window.implement({
    $$: function(selector) {
        if (1 == arguments.length && "string" == typeof selector) return this.document.getElements(selector);
        for (var elements = [], args = Array.flatten(arguments), i = 0, l = args.length; l > i; i++) {
            var item = args[i];
            switch ($type(item)) {
              case "element":
                elements.push(item);
                break;

              case "string":
                elements.extend(this.document.getElements(item, !0));
            }
        }
        return new Elements(elements);
    },
    getDocument: function() {
        return this.document;
    },
    getWindow: function() {
        return this;
    }
}), Native.implement([ Element, Document ], {
    getElement: function(selector, nocash) {
        return document.id(this.getElements(selector, !0)[0] || null, nocash);
    },
    getElements: function(tags, nocash) {
        tags = tags.split(",");
        var elements = [], ddup = tags.length > 1;
        return tags.each(function(tag) {
            var partial = this.getElementsByTagName(tag.trim());
            ddup ? elements.extend(partial) : elements = partial;
        }, this), new Elements(elements, {
            ddup: ddup,
            cash: !nocash
        });
    }
}), function() {
    var collected = {}, storage = {}, props = {
        input: "checked",
        option: "selected",
        textarea: Browser.Engine.webkit && 420 > Browser.Engine.version ? "innerHTML" : "value"
    }, get = function(uid) {
        return storage[uid] || (storage[uid] = {});
    }, clean = function(item, retain) {
        if (item) {
            var uid = item.uid;
            if (retain !== !0 && (retain = !1), Browser.Engine.trident) {
                if (item.clearAttributes) {
                    var clone = retain && item.cloneNode(!1);
                    item.clearAttributes(), clone && item.mergeAttributes(clone);
                } else item.removeEvents && item.removeEvents();
                if (/object/i.test(item.tagName)) {
                    for (var p in item) "function" == typeof item[p] && (item[p] = $empty);
                    Element.dispose(item);
                }
            }
            uid && (collected[uid] = storage[uid] = null);
        }
    }, purge = function() {
        Hash.each(collected, clean), Browser.Engine.trident && $A(document.getElementsByTagName("object")).each(clean), 
        window.CollectGarbage && CollectGarbage(), collected = storage = null;
    }, walk = function(element, walk, start, match, all, nocash) {
        for (var el = element[start || walk], elements = []; el; ) {
            if (1 == el.nodeType && (!match || Element.match(el, match))) {
                if (!all) return document.id(el, nocash);
                elements.push(el);
            }
            el = el[walk];
        }
        return all ? new Elements(elements, {
            ddup: !1,
            cash: !nocash
        }) : null;
    }, attributes = {
        html: "innerHTML",
        "class": "className",
        "for": "htmlFor",
        defaultValue: "defaultValue",
        text: Browser.Engine.trident || Browser.Engine.webkit && 420 > Browser.Engine.version ? "innerText" : "textContent"
    }, bools = [ "compact", "nowrap", "ismap", "declare", "noshade", "checked", "disabled", "readonly", "multiple", "selected", "noresize", "defer" ], camels = [ "value", "type", "defaultValue", "accessKey", "cellPadding", "cellSpacing", "colSpan", "frameBorder", "maxLength", "readOnly", "rowSpan", "tabIndex", "useMap" ];
    bools = bools.associate(bools), Hash.extend(attributes, bools), Hash.extend(attributes, camels.associate(camels.map(String.toLowerCase)));
    var inserters = {
        before: function(context, element) {
            element.parentNode && element.parentNode.insertBefore(context, element);
        },
        after: function(context, element) {
            if (element.parentNode) {
                var next = element.nextSibling;
                next ? element.parentNode.insertBefore(context, next) : element.parentNode.appendChild(context);
            }
        },
        bottom: function(context, element) {
            element.appendChild(context);
        },
        top: function(context, element) {
            var first = element.firstChild;
            first ? element.insertBefore(context, first) : element.appendChild(context);
        }
    };
    inserters.inside = inserters.bottom, Hash.each(inserters, function(inserter, where) {
        where = where.capitalize(), Element.implement("inject" + where, function(el) {
            return inserter(this, document.id(el, !0)), this;
        }), Element.implement("grab" + where, function(el) {
            return inserter(document.id(el, !0), this), this;
        });
    }), Element.implement({
        set: function(prop, value) {
            switch ($type(prop)) {
              case "object":
                for (var p in prop) this.set(p, prop[p]);
                break;

              case "string":
                var property = Element.Properties.get(prop);
                property && property.set ? property.set.apply(this, Array.slice(arguments, 1)) : this.setProperty(prop, value);
            }
            return this;
        },
        get: function(prop) {
            var property = Element.Properties.get(prop);
            return property && property.get ? property.get.apply(this, Array.slice(arguments, 1)) : this.getProperty(prop);
        },
        erase: function(prop) {
            var property = Element.Properties.get(prop);
            return property && property.erase ? property.erase.apply(this) : this.removeProperty(prop), 
            this;
        },
        setProperty: function(attribute, value) {
            var key = attributes[attribute];
            return void 0 == value ? this.removeProperty(attribute) : (key && bools[attribute] && (value = !!value), 
            key ? this[key] = value : this.setAttribute(attribute, "" + value), this);
        },
        setProperties: function(attributes) {
            for (var attribute in attributes) this.setProperty(attribute, attributes[attribute]);
            return this;
        },
        getProperty: function(attribute) {
            var key = attributes[attribute], value = key ? this[key] : this.getAttribute(attribute, 2);
            return bools[attribute] ? !!value : key ? value : value || null;
        },
        getProperties: function() {
            var args = $A(arguments);
            return args.map(this.getProperty, this).associate(args);
        },
        removeProperty: function(attribute) {
            var key = attributes[attribute];
            return key ? this[key] = key && bools[attribute] ? !1 : "" : this.removeAttribute(attribute), 
            this;
        },
        removeProperties: function() {
            return Array.each(arguments, this.removeProperty, this), this;
        },
        hasClass: function(className) {
            return this.className.contains(className, " ");
        },
        addClass: function(className) {
            return this.hasClass(className) || (this.className = (this.className + " " + className).clean()), 
            this;
        },
        removeClass: function(className) {
            return this.className = this.className.replace(RegExp("(^|\\s)" + className + "(?:\\s|$)"), "$1"), 
            this;
        },
        toggleClass: function(className) {
            return this.hasClass(className) ? this.removeClass(className) : this.addClass(className);
        },
        adopt: function() {
            return Array.flatten(arguments).each(function(element) {
                element = document.id(element, !0), element && this.appendChild(element);
            }, this), this;
        },
        appendText: function(text, where) {
            return this.grab(this.getDocument().newTextNode(text), where);
        },
        grab: function(el, where) {
            return inserters[where || "bottom"](document.id(el, !0), this), this;
        },
        inject: function(el, where) {
            return inserters[where || "bottom"](this, document.id(el, !0)), this;
        },
        replaces: function(el) {
            return el = document.id(el, !0), el.parentNode.replaceChild(this, el), this;
        },
        wraps: function(el, where) {
            return el = document.id(el, !0), this.replaces(el).grab(el, where);
        },
        getPrevious: function(match, nocash) {
            return walk(this, "previousSibling", null, match, !1, nocash);
        },
        getAllPrevious: function(match, nocash) {
            return walk(this, "previousSibling", null, match, !0, nocash);
        },
        getNext: function(match, nocash) {
            return walk(this, "nextSibling", null, match, !1, nocash);
        },
        getAllNext: function(match, nocash) {
            return walk(this, "nextSibling", null, match, !0, nocash);
        },
        getFirst: function(match, nocash) {
            return walk(this, "nextSibling", "firstChild", match, !1, nocash);
        },
        getLast: function(match, nocash) {
            return walk(this, "previousSibling", "lastChild", match, !1, nocash);
        },
        getParent: function(match, nocash) {
            return walk(this, "parentNode", null, match, !1, nocash);
        },
        getParents: function(match, nocash) {
            return walk(this, "parentNode", null, match, !0, nocash);
        },
        getSiblings: function(match, nocash) {
            return this.getParent().getChildren(match, nocash).erase(this);
        },
        getChildren: function(match, nocash) {
            return walk(this, "nextSibling", "firstChild", match, !0, nocash);
        },
        getWindow: function() {
            return this.ownerDocument.window;
        },
        getDocument: function() {
            return this.ownerDocument;
        },
        getElementById: function(id, nocash) {
            var el = this.ownerDocument.getElementById(id);
            if (!el) return null;
            for (var parent = el.parentNode; parent != this; parent = parent.parentNode) if (!parent) return null;
            return document.id(el, nocash);
        },
        getSelected: function() {
            return new Elements($A(this.options).filter(function(option) {
                return option.selected;
            }));
        },
        getComputedStyle: function(property) {
            if (this.currentStyle) return this.currentStyle[property.camelCase()];
            var computed = this.getDocument().defaultView.getComputedStyle(this, null);
            return computed ? computed.getPropertyValue([ property.hyphenate() ]) : null;
        },
        toQueryString: function() {
            var queryString = [];
            return this.getElements("input, select, textarea", !0).each(function(el) {
                if (el.name && !el.disabled && "submit" != el.type && "reset" != el.type && "file" != el.type) {
                    var value = "select" == el.tagName.toLowerCase() ? Element.getSelected(el).map(function(opt) {
                        return opt.value;
                    }) : "radio" != el.type && "checkbox" != el.type || el.checked ? el.value : null;
                    $splat(value).each(function(val) {
                        val !== void 0 && queryString.push(el.name + "=" + encodeURIComponent(val));
                    });
                }
            }), queryString.join("&");
        },
        clone: function(contents, keepid) {
            contents = contents !== !1;
            var clone = this.cloneNode(contents), clean = function(node, element) {
                if (keepid || node.removeAttribute("id"), Browser.Engine.trident && (node.clearAttributes(), 
                node.mergeAttributes(element), node.removeAttribute("uid"), node.options)) for (var no = node.options, eo = element.options, j = no.length; j--; ) no[j].selected = eo[j].selected;
                var prop = props[element.tagName.toLowerCase()];
                prop && element[prop] && (node[prop] = element[prop]);
            };
            if (contents) for (var ce = clone.getElementsByTagName("*"), te = this.getElementsByTagName("*"), i = ce.length; i--; ) clean(ce[i], te[i]);
            return clean(clone, this), document.id(clone);
        },
        destroy: function() {
            return Element.empty(this), Element.dispose(this), clean(this, !0), null;
        },
        empty: function() {
            return $A(this.childNodes).each(function(node) {
                Element.destroy(node);
            }), this;
        },
        dispose: function() {
            return this.parentNode ? this.parentNode.removeChild(this) : this;
        },
        hasChild: function(el) {
            return el = document.id(el, !0), el ? Browser.Engine.webkit && 420 > Browser.Engine.version ? $A(this.getElementsByTagName(el.tagName)).contains(el) : this.contains ? this != el && this.contains(el) : !!(16 & this.compareDocumentPosition(el)) : !1;
        },
        match: function(tag) {
            return !tag || tag == this || Element.get(this, "tag") == tag;
        }
    }), Native.implement([ Element, Window, Document ], {
        addListener: function(type, fn) {
            if ("unload" == type) {
                var old = fn, self = this;
                fn = function() {
                    self.removeListener("unload", fn), old();
                };
            } else collected[this.uid] = this;
            return this.addEventListener ? this.addEventListener(type, fn, !1) : this.attachEvent("on" + type, fn), 
            this;
        },
        removeListener: function(type, fn) {
            return this.removeEventListener ? this.removeEventListener(type, fn, !1) : this.detachEvent("on" + type, fn), 
            this;
        },
        retrieve: function(property, dflt) {
            var storage = get(this.uid), prop = storage[property];
            return void 0 != dflt && void 0 == prop && (prop = storage[property] = dflt), $pick(prop);
        },
        store: function(property, value) {
            var storage = get(this.uid);
            return storage[property] = value, this;
        },
        eliminate: function(property) {
            var storage = get(this.uid);
            return delete storage[property], this;
        }
    }), window.addListener("unload", purge);
}(), Element.Properties = new Hash(), Element.Properties.style = {
    set: function(style) {
        this.style.cssText = style;
    },
    get: function() {
        return this.style.cssText;
    },
    erase: function() {
        this.style.cssText = "";
    }
}, Element.Properties.tag = {
    get: function() {
        return this.tagName.toLowerCase();
    }
}, Element.Properties.html = function() {
    var BUGGY_INNERHTML = !0;
    try {
        var tester = document.createElement("tr");
        tester.innerHTML = "<td>x", tester = tester.firstChild, BUGGY_INNERHTML = !("TD" == tester.nodeName && "x" == tester.innerHTML);
    } catch (e) {}
    if (!BUGGY_INNERHTML) return {
        set: function() {
            this.innerHTML = Array.flatten(arguments).join("");
        }
    };
    var wrapper = document.createElement("div"), translations = {
        table: [ 1, "<table>", "</table>" ],
        select: [ 1, "<select>", "</select>" ],
        tbody: [ 2, "<table><tbody>", "</tbody></table>" ],
        tr: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ]
    };
    translations.thead = translations.tfoot = translations.tbody;
    var html = {
        set: function() {
            var html = Array.flatten(arguments).join(""), wrap = translations[this.get("tag")];
            if (wrap) {
                var first = wrapper;
                first.innerHTML = wrap[1] + html + wrap[2];
                for (var i = wrap[0]; i--; ) first = first.firstChild;
                this.empty().adopt(first.childNodes);
            } else this.innerHTML = html;
        }
    };
    return html.erase = html.set, html;
}(), Browser.Engine.webkit && 420 > Browser.Engine.version && (Element.Properties.text = {
    get: function() {
        if (this.innerText) return this.innerText;
        var temp = this.ownerDocument.newElement("div", {
            html: this.innerHTML
        }).inject(this.ownerDocument.body), text = temp.innerText;
        return temp.destroy(), text;
    }
}), Element.Properties.events = {
    set: function(events) {
        this.addEvents(events);
    }
}, Native.implement([ Element, Window, Document ], {
    addEvent: function(type, fn) {
        var events = this.retrieve("events", {});
        if (events[type] = events[type] || {
            keys: [],
            values: []
        }, events[type].keys.contains(fn)) return this;
        events[type].keys.push(fn);
        var realType = type, custom = Element.Events.get(type), condition = fn, self = this;
        custom && (custom.onAdd && custom.onAdd.call(this, fn), custom.condition && (condition = function(event) {
            return custom.condition.call(this, event) ? fn.call(this, event) : !0;
        }), realType = custom.base || realType);
        var defn = function() {
            return fn.call(self);
        }, nativeEvent = Element.NativeEvents[realType];
        return nativeEvent && (2 == nativeEvent && (defn = function(event) {
            event = new Event(event, self.getWindow()), condition.call(self, event) === !1 && event.stop();
        }), this.addListener(realType, defn)), events[type].values.push(defn), this;
    },
    removeEvent: function(type, fn) {
        var events = this.retrieve("events");
        if (!events || !events[type]) return this;
        var pos = events[type].keys.indexOf(fn);
        if (-1 == pos) return this;
        events[type].keys.splice(pos, 1);
        var value = events[type].values.splice(pos, 1)[0], custom = Element.Events.get(type);
        return custom && (custom.onRemove && custom.onRemove.call(this, fn), type = custom.base || type), 
        Element.NativeEvents[type] ? this.removeListener(type, value) : this;
    },
    addEvents: function(events) {
        for (var event in events) this.addEvent(event, events[event]);
        return this;
    },
    removeEvents: function(events) {
        var type;
        if ("object" == $type(events)) {
            for (type in events) this.removeEvent(type, events[type]);
            return this;
        }
        var attached = this.retrieve("events");
        if (!attached) return this;
        if (events) {
            if (attached[events]) {
                for (;attached[events].keys[0]; ) this.removeEvent(events, attached[events].keys[0]);
                attached[events] = null;
            }
        } else {
            for (type in attached) this.removeEvents(type);
            this.eliminate("events");
        }
        return this;
    },
    fireEvent: function(type, args, delay) {
        var events = this.retrieve("events");
        return events && events[type] ? (events[type].keys.each(function(fn) {
            fn.create({
                bind: this,
                delay: delay,
                arguments: args
            })();
        }, this), this) : this;
    },
    cloneEvents: function(from, type) {
        from = document.id(from);
        var fevents = from.retrieve("events");
        if (!fevents) return this;
        if (type) fevents[type] && fevents[type].keys.each(function(fn) {
            this.addEvent(type, fn);
        }, this); else for (var evType in fevents) this.cloneEvents(from, evType);
        return this;
    }
});

try {
    "undefined" != typeof HTMLElement && (HTMLElement.prototype.fireEvent = Element.prototype.fireEvent);
} catch (e) {}

Element.NativeEvents = {
    click: 2,
    dblclick: 2,
    mouseup: 2,
    mousedown: 2,
    contextmenu: 2,
    mousewheel: 2,
    DOMMouseScroll: 2,
    mouseover: 2,
    mouseout: 2,
    mousemove: 2,
    selectstart: 2,
    selectend: 2,
    keydown: 2,
    keypress: 2,
    keyup: 2,
    focus: 2,
    blur: 2,
    change: 2,
    reset: 2,
    select: 2,
    submit: 2,
    load: 1,
    unload: 1,
    beforeunload: 2,
    resize: 1,
    move: 1,
    DOMContentLoaded: 1,
    readystatechange: 1,
    error: 1,
    abort: 1,
    scroll: 1
}, function() {
    var $check = function(event) {
        var related = event.relatedTarget;
        return void 0 == related ? !0 : related === !1 ? !1 : "document" != $type(this) && related != this && "xul" != related.prefix && !this.hasChild(related);
    };
    Element.Events = new Hash({
        mouseenter: {
            base: "mouseover",
            condition: $check
        },
        mouseleave: {
            base: "mouseout",
            condition: $check
        },
        mousewheel: {
            base: Browser.Engine.gecko ? "DOMMouseScroll" : "mousewheel"
        }
    });
}(), Element.Properties.styles = {
    set: function(styles) {
        this.setStyles(styles);
    }
}, Element.Properties.opacity = {
    set: function(opacity, novisibility) {
        novisibility || (0 == opacity ? "hidden" != this.style.visibility && (this.style.visibility = "hidden") : "visible" != this.style.visibility && (this.style.visibility = "visible")), 
        this.currentStyle && this.currentStyle.hasLayout || (this.style.zoom = 1), Browser.Engine.trident && (this.style.filter = 1 == opacity ? "" : "alpha(opacity=" + 100 * opacity + ")"), 
        this.style.opacity = opacity, this.store("opacity", opacity);
    },
    get: function() {
        return this.retrieve("opacity", 1);
    }
}, Element.implement({
    setOpacity: function(value) {
        return this.set("opacity", value, !0);
    },
    getOpacity: function() {
        return this.get("opacity");
    },
    setStyle: function(property, value) {
        switch (property) {
          case "opacity":
            return this.set("opacity", parseFloat(value));

          case "float":
            property = Browser.Engine.trident ? "styleFloat" : "cssFloat";
        }
        if (property = property.camelCase(), "string" != $type(value)) {
            var map = (Element.Styles.get(property) || "@").split(" ");
            value = $splat(value).map(function(val, i) {
                return map[i] ? "number" == $type(val) ? map[i].replace("@", Math.round(val)) : val : "";
            }).join(" ");
        } else value == Number(value) + "" && (value = Math.round(value));
        return this.style[property] = value, this;
    },
    getStyle: function(property) {
        switch (property) {
          case "opacity":
            return this.get("opacity");

          case "float":
            property = Browser.Engine.trident ? "styleFloat" : "cssFloat";
        }
        property = property.camelCase();
        var result = this.style[property];
        if (!$chk(result)) {
            result = [];
            for (var style in Element.ShortStyles) if (property == style) {
                for (var s in Element.ShortStyles[style]) result.push(this.getStyle(s));
                return result.join(" ");
            }
            result = this.getComputedStyle(property);
        }
        if (result) {
            result += "";
            var color = result.match(/rgba?\([\d\s,]+\)/);
            color && (result = result.replace(color[0], color[0].rgbToHex()));
        }
        if (Browser.Engine.presto || Browser.Engine.trident && !$chk(parseInt(result, 10))) {
            if (property.test(/^(height|width)$/)) {
                var values = "width" == property ? [ "left", "right" ] : [ "top", "bottom" ], size = 0;
                return values.each(function(value) {
                    size += this.getStyle("border-" + value + "-width").toInt() + this.getStyle("padding-" + value).toInt();
                }, this), this["offset" + property.capitalize()] - size + "px";
            }
            if (Browser.Engine.presto && (result + "").test("px")) return result;
            if (property.test(/(border(.+)Width|margin|padding)/)) return "0px";
        }
        return result;
    },
    setStyles: function(styles) {
        for (var style in styles) this.setStyle(style, styles[style]);
        return this;
    },
    getStyles: function() {
        var result = {};
        return Array.flatten(arguments).each(function(key) {
            result[key] = this.getStyle(key);
        }, this), result;
    }
}), Element.Styles = new Hash({
    left: "@px",
    top: "@px",
    bottom: "@px",
    right: "@px",
    width: "@px",
    height: "@px",
    maxWidth: "@px",
    maxHeight: "@px",
    minWidth: "@px",
    minHeight: "@px",
    backgroundColor: "rgb(@, @, @)",
    backgroundPosition: "@px @px",
    color: "rgb(@, @, @)",
    fontSize: "@px",
    letterSpacing: "@px",
    lineHeight: "@px",
    clip: "rect(@px @px @px @px)",
    margin: "@px @px @px @px",
    padding: "@px @px @px @px",
    border: "@px @ rgb(@, @, @) @px @ rgb(@, @, @) @px @ rgb(@, @, @)",
    borderWidth: "@px @px @px @px",
    borderStyle: "@ @ @ @",
    borderColor: "rgb(@, @, @) rgb(@, @, @) rgb(@, @, @) rgb(@, @, @)",
    zIndex: "@",
    zoom: "@",
    fontWeight: "@",
    textIndent: "@px",
    opacity: "@"
}), Element.ShortStyles = {
    margin: {},
    padding: {},
    border: {},
    borderWidth: {},
    borderStyle: {},
    borderColor: {}
}, [ "Top", "Right", "Bottom", "Left" ].each(function(direction) {
    var Short = Element.ShortStyles, All = Element.Styles;
    [ "margin", "padding" ].each(function(style) {
        var sd = style + direction;
        Short[style][sd] = All[sd] = "@px";
    });
    var bd = "border" + direction;
    Short.border[bd] = All[bd] = "@px @ rgb(@, @, @)";
    var bdw = bd + "Width", bds = bd + "Style", bdc = bd + "Color";
    Short[bd] = {}, Short.borderWidth[bdw] = Short[bd][bdw] = All[bdw] = "@px", Short.borderStyle[bds] = Short[bd][bds] = All[bds] = "@", 
    Short.borderColor[bdc] = Short[bd][bdc] = All[bdc] = "rgb(@, @, @)";
}), function() {
    function styleNumber(element, style) {
        return styleString(element, style).toInt() || 0;
    }
    function borderBox(element) {
        return "border-box" == styleString(element, "-moz-box-sizing");
    }
    function topBorder(element) {
        return styleNumber(element, "border-top-width");
    }
    function leftBorder(element) {
        return styleNumber(element, "border-left-width");
    }
    function isBody(element) {
        return /^(?:body|html)$/i.test(element.tagName);
    }
    function getCompatElement(element) {
        var doc = element.getDocument();
        return doc.compatMode && "CSS1Compat" != doc.compatMode ? doc.body : doc.html;
    }
    Element.implement({
        scrollTo: function(x, y) {
            return isBody(this) ? this.getWindow().scrollTo(x, y) : (this.scrollLeft = x, this.scrollTop = y), 
            this;
        },
        getSize: function() {
            return isBody(this) ? this.getWindow().getSize() : {
                x: this.offsetWidth,
                y: this.offsetHeight
            };
        },
        getScrollSize: function() {
            return isBody(this) ? this.getWindow().getScrollSize() : {
                x: this.scrollWidth,
                y: this.scrollHeight
            };
        },
        getScroll: function() {
            return isBody(this) ? this.getWindow().getScroll() : {
                x: this.scrollLeft,
                y: this.scrollTop
            };
        },
        getScrolls: function() {
            for (var element = this, position = {
                x: 0,
                y: 0
            }; element && !isBody(element); ) position.x += element.scrollLeft, position.y += element.scrollTop, 
            element = element.parentNode;
            return position;
        },
        getOffsetParent: function() {
            var element = this;
            if (isBody(element)) return null;
            if (!Browser.Engine.trident) return element.offsetParent;
            for (;(element = element.parentNode) && !isBody(element); ) if ("static" != styleString(element, "position")) return element;
            return null;
        },
        getOffsets: function() {
            if (this.getBoundingClientRect) {
                var bound = this.getBoundingClientRect(), html = document.id(this.getDocument().documentElement), htmlScroll = html.getScroll(), elemScrolls = this.getScrolls(), elemScroll = this.getScroll(), isFixed = "fixed" == styleString(this, "position");
                return {
                    x: bound.left.toInt() + elemScrolls.x - elemScroll.x + (isFixed ? 0 : htmlScroll.x) - html.clientLeft,
                    y: bound.top.toInt() + elemScrolls.y - elemScroll.y + (isFixed ? 0 : htmlScroll.y) - html.clientTop
                };
            }
            var element = this, position = {
                x: 0,
                y: 0
            };
            if (isBody(this)) return position;
            for (;element && !isBody(element); ) {
                if (position.x += element.offsetLeft, position.y += element.offsetTop, Browser.Engine.gecko) {
                    borderBox(element) || (position.x += leftBorder(element), position.y += topBorder(element));
                    var parent = element.parentNode;
                    parent && "visible" != styleString(parent, "overflow") && (position.x += leftBorder(parent), 
                    position.y += topBorder(parent));
                } else element != this && Browser.Engine.webkit && (position.x += leftBorder(element), 
                position.y += topBorder(element));
                element = element.offsetParent;
            }
            return Browser.Engine.gecko && !borderBox(this) && (position.x -= leftBorder(this), 
            position.y -= topBorder(this)), position;
        },
        getPosition: function(relative) {
            if (isBody(this)) return {
                x: 0,
                y: 0
            };
            var offset = this.getOffsets(), scroll = this.getScrolls(), position = {
                x: offset.x - scroll.x,
                y: offset.y - scroll.y
            }, relativePosition = relative && (relative = document.id(relative)) ? relative.getPosition() : {
                x: 0,
                y: 0
            };
            return {
                x: position.x - relativePosition.x,
                y: position.y - relativePosition.y
            };
        },
        getCoordinates: function(element) {
            if (isBody(this)) return this.getWindow().getCoordinates();
            var position = this.getPosition(element), size = this.getSize(), obj = {
                left: position.x,
                top: position.y,
                width: size.x,
                height: size.y
            };
            return obj.right = obj.left + obj.width, obj.bottom = obj.top + obj.height, obj;
        },
        computePosition: function(obj) {
            return {
                left: obj.x - styleNumber(this, "margin-left"),
                top: obj.y - styleNumber(this, "margin-top")
            };
        },
        setPosition: function(obj) {
            return this.setStyles(this.computePosition(obj));
        }
    }), Native.implement([ Document, Window ], {
        getSize: function() {
            if (Browser.Engine.presto || Browser.Engine.webkit) {
                var win = this.getWindow();
                return {
                    x: win.innerWidth,
                    y: win.innerHeight
                };
            }
            var doc = getCompatElement(this);
            return {
                x: doc.clientWidth,
                y: doc.clientHeight
            };
        },
        getScroll: function() {
            var win = this.getWindow(), doc = getCompatElement(this);
            return {
                x: win.pageXOffset || doc.scrollLeft,
                y: win.pageYOffset || doc.scrollTop
            };
        },
        getScrollSize: function() {
            var doc = getCompatElement(this), min = this.getSize();
            return {
                x: Math.max(doc.scrollWidth, min.x),
                y: Math.max(doc.scrollHeight, min.y)
            };
        },
        getPosition: function() {
            return {
                x: 0,
                y: 0
            };
        },
        getCoordinates: function() {
            var size = this.getSize();
            return {
                top: 0,
                left: 0,
                bottom: size.y,
                right: size.x,
                height: size.y,
                width: size.x
            };
        }
    });
    var styleString = Element.getComputedStyle;
}(), Element.alias("setPosition", "position"), Native.implement([ Window, Document, Element ], {
    getHeight: function() {
        return this.getSize().y;
    },
    getWidth: function() {
        return this.getSize().x;
    },
    getScrollTop: function() {
        return this.getScroll().y;
    },
    getScrollLeft: function() {
        return this.getScroll().x;
    },
    getScrollHeight: function() {
        return this.getScrollSize().y;
    },
    getScrollWidth: function() {
        return this.getScrollSize().x;
    },
    getTop: function() {
        return this.getPosition().y;
    },
    getLeft: function() {
        return this.getPosition().x;
    }
}), Native.implement([ Document, Element ], {
    getElements: function(expression, nocash) {
        expression = expression.split(",");
        for (var items, local = {}, i = 0, l = expression.length; l > i; i++) {
            var selector = expression[i], elements = Selectors.Utils.search(this, selector, local);
            0 != i && elements.item && (elements = $A(elements)), items = 0 == i ? elements : items.item ? $A(items).concat(elements) : items.concat(elements);
        }
        return new Elements(items, {
            ddup: expression.length > 1,
            cash: !nocash
        });
    }
}), Element.implement({
    match: function(selector) {
        if (!selector || selector == this) return !0;
        var tagid = Selectors.Utils.parseTagAndID(selector), tag = tagid[0], id = tagid[1];
        if (!Selectors.Filters.byID(this, id) || !Selectors.Filters.byTag(this, tag)) return !1;
        var parsed = Selectors.Utils.parseSelector(selector);
        return parsed ? Selectors.Utils.filter(this, parsed, {}) : !0;
    }
});

var Selectors = {
    Cache: {
        nth: {},
        parsed: {}
    }
};

Selectors.RegExps = {
    id: /#([\w-]+)/,
    tag: /^(\w+|\*)/,
    quick: /^(\w+|\*)$/,
    splitter: /\s*([+>~\s])\s*([a-zA-Z#.*:\[])/g,
    combined: /\.([\w-]+)|\[(\w+)(?:([!*^$~|]?=)(["']?)([^\4]*?)\4)?\]|:([\w-]+)(?:\(["']?(.*?)?["']?\)|$)/g
}, Selectors.Utils = {
    chk: function(item, uniques) {
        if (!uniques) return !0;
        var uid = $uid(item);
        return uniques[uid] ? !1 : uniques[uid] = !0;
    },
    parseNthArgument: function(argument) {
        if (Selectors.Cache.nth[argument]) return Selectors.Cache.nth[argument];
        var parsed = argument.match(/^([+-]?\d*)?([a-z]+)?([+-]?\d*)?$/);
        if (!parsed) return !1;
        var inta = parseInt(parsed[1], 10), a = inta || 0 === inta ? inta : 1, special = parsed[2] || !1, b = parseInt(parsed[3], 10) || 0;
        if (0 != a) {
            for (b--; 1 > b; ) b += a;
            for (;b >= a; ) b -= a;
        } else a = b, special = "index";
        switch (special) {
          case "n":
            parsed = {
                a: a,
                b: b,
                special: "n"
            };
            break;

          case "odd":
            parsed = {
                a: 2,
                b: 0,
                special: "n"
            };
            break;

          case "even":
            parsed = {
                a: 2,
                b: 1,
                special: "n"
            };
            break;

          case "first":
            parsed = {
                a: 0,
                special: "index"
            };
            break;

          case "last":
            parsed = {
                special: "last-child"
            };
            break;

          case "only":
            parsed = {
                special: "only-child"
            };
            break;

          default:
            parsed = {
                a: a - 1,
                special: "index"
            };
        }
        return Selectors.Cache.nth[argument] = parsed;
    },
    parseSelector: function(selector) {
        if (Selectors.Cache.parsed[selector]) return Selectors.Cache.parsed[selector];
        for (var m, parsed = {
            classes: [],
            pseudos: [],
            attributes: []
        }; m = Selectors.RegExps.combined.exec(selector); ) {
            var cn = m[1], an = m[2], ao = m[3], av = m[5], pn = m[6], pa = m[7];
            if (cn) parsed.classes.push(cn); else if (pn) {
                var parser = Selectors.Pseudo.get(pn);
                parser ? parsed.pseudos.push({
                    parser: parser,
                    argument: pa
                }) : parsed.attributes.push({
                    name: pn,
                    operator: "=",
                    value: pa
                });
            } else an && parsed.attributes.push({
                name: an,
                operator: ao,
                value: av
            });
        }
        return parsed.classes.length || delete parsed.classes, parsed.attributes.length || delete parsed.attributes, 
        parsed.pseudos.length || delete parsed.pseudos, parsed.classes || parsed.attributes || parsed.pseudos || (parsed = null), 
        Selectors.Cache.parsed[selector] = parsed;
    },
    parseTagAndID: function(selector) {
        var tag = selector.match(Selectors.RegExps.tag), id = selector.match(Selectors.RegExps.id);
        return [ tag ? tag[1] : "*", id ? id[1] : !1 ];
    },
    filter: function(item, parsed, local) {
        var i;
        if (parsed.classes) for (i = parsed.classes.length; i--; i) {
            var cn = parsed.classes[i];
            if (!Selectors.Filters.byClass(item, cn)) return !1;
        }
        if (parsed.attributes) for (i = parsed.attributes.length; i--; i) {
            var att = parsed.attributes[i];
            if (!Selectors.Filters.byAttribute(item, att.name, att.operator, att.value)) return !1;
        }
        if (parsed.pseudos) for (i = parsed.pseudos.length; i--; i) {
            var psd = parsed.pseudos[i];
            if (!Selectors.Filters.byPseudo(item, psd.parser, psd.argument, local)) return !1;
        }
        return !0;
    },
    getByTagAndID: function(ctx, tag, id) {
        if (id) {
            var item = ctx.getElementById ? ctx.getElementById(id, !0) : Element.getElementById(ctx, id, !0);
            return item && Selectors.Filters.byTag(item, tag) ? [ item ] : [];
        }
        return ctx.getElementsByTagName(tag);
    },
    search: function(self, expression, local) {
        for (var items, filtered, item, splitters = [], selectors = expression.trim().replace(Selectors.RegExps.splitter, function(m0, m1, m2) {
            return splitters.push(m1), ":)" + m2;
        }).split(":)"), i = 0, l = selectors.length; l > i; i++) {
            var selector = selectors[i];
            if (0 == i && Selectors.RegExps.quick.test(selector)) items = self.getElementsByTagName(selector); else {
                var splitter = splitters[i - 1], tagid = Selectors.Utils.parseTagAndID(selector), tag = tagid[0], id = tagid[1];
                if (0 == i) items = Selectors.Utils.getByTagAndID(self, tag, id); else {
                    for (var uniques = {}, found = [], j = 0, k = items.length; k > j; j++) found = Selectors.Getters[splitter](found, items[j], tag, id, uniques);
                    items = found;
                }
                var parsed = Selectors.Utils.parseSelector(selector);
                if (parsed) {
                    filtered = [];
                    for (var m = 0, n = items.length; n > m; m++) item = items[m], Selectors.Utils.filter(item, parsed, local) && filtered.push(item);
                    items = filtered;
                }
            }
        }
        return items;
    }
}, Selectors.Getters = {
    " ": function(found, self, tag, id, uniques) {
        for (var items = Selectors.Utils.getByTagAndID(self, tag, id), i = 0, l = items.length; l > i; i++) {
            var item = items[i];
            Selectors.Utils.chk(item, uniques) && found.push(item);
        }
        return found;
    },
    ">": function(found, self, tag, id, uniques) {
        for (var children = Selectors.Utils.getByTagAndID(self, tag, id), i = 0, l = children.length; l > i; i++) {
            var child = children[i];
            child.parentNode == self && Selectors.Utils.chk(child, uniques) && found.push(child);
        }
        return found;
    },
    "+": function(found, self, tag, id, uniques) {
        for (;self = self.nextSibling; ) if (1 == self.nodeType) {
            Selectors.Utils.chk(self, uniques) && Selectors.Filters.byTag(self, tag) && Selectors.Filters.byID(self, id) && found.push(self);
            break;
        }
        return found;
    },
    "~": function(found, self, tag, id, uniques) {
        for (;self = self.nextSibling; ) if (1 == self.nodeType) {
            if (!Selectors.Utils.chk(self, uniques)) break;
            Selectors.Filters.byTag(self, tag) && Selectors.Filters.byID(self, id) && found.push(self);
        }
        return found;
    }
}, Selectors.Filters = {
    byTag: function(self, tag) {
        return "*" == tag || self.tagName && self.tagName.toLowerCase() == tag;
    },
    byID: function(self, id) {
        return !id || self.id && self.id == id;
    },
    byClass: function(self, klass) {
        return self.className && self.className.contains && self.className.contains(klass, " ");
    },
    byPseudo: function(self, parser, argument, local) {
        return parser.call(self, argument, local);
    },
    byAttribute: function(self, name, operator, value) {
        var result = Element.prototype.getProperty.call(self, name);
        if (!result) return "!=" == operator;
        if (!operator || void 0 == value) return !0;
        switch (operator) {
          case "=":
            return result == value;

          case "*=":
            return result.contains(value);

          case "^=":
            return result.substr(0, value.length) == value;

          case "$=":
            return result.substr(result.length - value.length) == value;

          case "!=":
            return result != value;

          case "~=":
            return result.contains(value, " ");

          case "|=":
            return result.contains(value, "-");
        }
        return !1;
    }
}, Selectors.Pseudo = new Hash({
    checked: function() {
        return this.checked;
    },
    empty: function() {
        return !(this.innerText || this.textContent || "").length;
    },
    not: function(selector) {
        return !Element.match(this, selector);
    },
    contains: function(text) {
        return (this.innerText || this.textContent || "").contains(text);
    },
    "first-child": function() {
        return Selectors.Pseudo.index.call(this, 0);
    },
    "last-child": function() {
        for (var element = this; element = element.nextSibling; ) if (1 == element.nodeType) return !1;
        return !0;
    },
    "only-child": function() {
        for (var prev = this; prev = prev.previousSibling; ) if (1 == prev.nodeType) return !1;
        for (var next = this; next = next.nextSibling; ) if (1 == next.nodeType) return !1;
        return !0;
    },
    "nth-child": function(argument, local) {
        argument = void 0 == argument ? "n" : argument;
        var parsed = Selectors.Utils.parseNthArgument(argument);
        if ("n" != parsed.special) return Selectors.Pseudo[parsed.special].call(this, parsed.a, local);
        var count = 0;
        local.positions = local.positions || {};
        var uid = $uid(this);
        if (!local.positions[uid]) {
            for (var self = this; self = self.previousSibling; ) if (1 == self.nodeType) {
                count++;
                var position = local.positions[$uid(self)];
                if (void 0 != position) {
                    count = position + count;
                    break;
                }
            }
            local.positions[uid] = count;
        }
        return local.positions[uid] % parsed.a == parsed.b;
    },
    index: function(index) {
        for (var element = this, count = 0; element = element.previousSibling; ) if (1 == element.nodeType && ++count > index) return !1;
        return count == index;
    },
    even: function(argument, local) {
        return Selectors.Pseudo["nth-child"].call(this, "2n+1", local);
    },
    odd: function(argument, local) {
        return Selectors.Pseudo["nth-child"].call(this, "2n", local);
    },
    selected: function() {
        return this.selected;
    },
    enabled: function() {
        return this.disabled === !1;
    }
}), Element.Events.domready = {
    onAdd: function(fn) {
        Browser.loaded && fn.call(this);
    }
}, function() {
    var domready = function() {
        Browser.loaded || (Browser.loaded = !0, window.fireEvent("domready"), document.fireEvent("domready"));
    };
    if (window.addEvent("load", domready), Browser.Engine.trident) {
        var temp = document.createElement("div");
        (function() {
            $try(function() {
                return temp.doScroll(), document.id(temp).inject(document.body).set("html", "temp").dispose();
            }) ? domready() : arguments.callee.delay(50);
        })();
    } else Browser.Engine.webkit && 525 > Browser.Engine.version ? function() {
        [ "loaded", "complete" ].contains(document.readyState) ? domready() : arguments.callee.delay(50);
    }() : document.addEvent("DOMContentLoaded", domready);
}();

var JSON = new Hash(this.JSON && {
    stringify: JSON.stringify,
    parse: JSON.parse
}).extend({
    $specialChars: {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
    },
    $replaceChars: function(chr) {
        return JSON.$specialChars[chr] || "\\u00" + Math.floor(chr.charCodeAt() / 16).toString(16) + (chr.charCodeAt() % 16).toString(16);
    },
    encode: function(obj) {
        switch ($type(obj)) {
          case "string":
            return '"' + obj.replace(/[\x00-\x1f\\"]/g, JSON.$replaceChars) + '"';

          case "array":
            return "[" + (obj.map(JSON.encode).clean() + "") + "]";

          case "object":
          case "hash":
            var string = [];
            return Hash.each(obj, function(value, key) {
                var json = JSON.encode(value);
                json && string.push(JSON.encode(key) + ":" + json);
            }), "{" + string + "}";

          case "number":
          case "boolean":
            return obj + "";

          case !1:
            return "null";
        }
        return null;
    },
    decode: function(string, secure) {
        return "string" == $type(string) && string.length ? secure && !/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/.test(string.replace(/\\./g, "@").replace(/"[^"\\\n\r]*"/g, "")) ? null : eval("(" + string + ")") : null;
    }
}), Cookie = new Class({
    Implements: Options,
    options: {
        path: !1,
        domain: !1,
        duration: !1,
        secure: !1,
        document: document
    },
    initialize: function(key, options) {
        this.key = key, this.setOptions(options);
    },
    write: function(value) {
        if (value = encodeURIComponent(value), this.options.domain && (value += "; domain=" + this.options.domain), 
        this.options.path && (value += "; path=" + this.options.path), this.options.duration) {
            var date = new Date();
            date.setTime(date.getTime() + 1e3 * 60 * 60 * 24 * this.options.duration), value += "; expires=" + date.toGMTString();
        }
        return this.options.secure && (value += "; secure"), this.options.document.cookie = this.key + "=" + value, 
        this;
    },
    read: function() {
        var value = this.options.document.cookie.match("(?:^|;)\\s*" + this.key.escapeRegExp() + "=([^;]*)");
        return value ? decodeURIComponent(value[1]) : null;
    },
    dispose: function() {
        return new Cookie(this.key, $merge(this.options, {
            duration: -1
        })).write(""), this;
    }
});

Cookie.write = function(key, value, options) {
    return new Cookie(key, options).write(value);
}, Cookie.read = function(key) {
    return new Cookie(key).read();
}, Cookie.dispose = function(key, options) {
    return new Cookie(key, options).dispose();
};

var Swiff = new Class({
    Implements: [ Options ],
    options: {
        id: null,
        height: 1,
        width: 1,
        container: null,
        properties: {},
        params: {
            quality: "high",
            allowScriptAccess: "always",
            wMode: "transparent",
            swLiveConnect: !0
        },
        callBacks: {},
        vars: {}
    },
    toElement: function() {
        return this.object;
    },
    initialize: function(path, options) {
        this.instance = "Swiff_" + $time(), this.setOptions(options), options = this.options;
        var id = this.id = options.id || this.instance, container = document.id(options.container);
        Swiff.CallBacks[this.instance] = {};
        var params = options.params, vars = options.vars, callBacks = options.callBacks, properties = $extend({
            height: options.height,
            width: options.width
        }, options.properties), self = this;
        for (var callBack in callBacks) Swiff.CallBacks[this.instance][callBack] = function(option) {
            return function() {
                return option.apply(self.object, arguments);
            };
        }(callBacks[callBack]), vars[callBack] = "Swiff.CallBacks." + this.instance + "." + callBack;
        params.flashVars = Hash.toQueryString(vars), Browser.Engine.trident ? (properties.classid = "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", 
        params.movie = path) : (properties.type = "application/x-shockwave-flash", properties.data = path);
        var build = '<object id="' + id + '"';
        for (var property in properties) build += " " + property + '="' + properties[property] + '"';
        build += ">";
        for (var param in params) params[param] && (build += '<param name="' + param + '" value="' + params[param] + '" />');
        build += "</object>", this.object = (container ? container.empty() : new Element("div")).set("html", build).firstChild;
    },
    replaces: function(element) {
        return element = document.id(element, !0), element.parentNode.replaceChild(this.toElement(), element), 
        this;
    },
    inject: function(element) {
        return document.id(element, !0).appendChild(this.toElement()), this;
    },
    remote: function() {
        return Swiff.remote.apply(Swiff, [ this.toElement() ].extend(arguments));
    }
});

Swiff.CallBacks = {}, Swiff.remote = function(obj, fn) {
    var rs = obj.CallFunction('<invoke name="' + fn + '" returntype="javascript">' + __flash__argumentsToXML(arguments, 2) + "</invoke>");
    return eval(rs);
};

var Fx = new Class({
    Implements: [ Chain, Events, Options ],
    options: {
        fps: 50,
        unit: !1,
        duration: 500,
        link: "ignore"
    },
    initialize: function(options) {
        this.subject = this.subject || this, this.setOptions(options), this.options.duration = Fx.Durations[this.options.duration] || this.options.duration.toInt();
        var wait = this.options.wait;
        wait === !1 && (this.options.link = "cancel");
    },
    getTransition: function() {
        return function(p) {
            return -(Math.cos(Math.PI * p) - 1) / 2;
        };
    },
    step: function() {
        var time = $time();
        if (this.time + this.options.duration > time) {
            var delta = this.transition((time - this.time) / this.options.duration);
            this.set(this.compute(this.from, this.to, delta));
        } else this.set(this.compute(this.from, this.to, 1)), this.complete();
    },
    set: function(now) {
        return now;
    },
    compute: function(from, to, delta) {
        return Fx.compute(from, to, delta);
    },
    check: function() {
        if (!this.timer) return !0;
        switch (this.options.link) {
          case "cancel":
            return this.cancel(), !0;

          case "chain":
            return this.chain(this.caller.bind(this, arguments)), !1;
        }
        return !1;
    },
    start: function(from, to) {
        return this.check(from, to) ? (this.from = from, this.to = to, this.time = 0, this.transition = this.getTransition(), 
        this.startTimer(), this.onStart(), this) : this;
    },
    complete: function() {
        return this.stopTimer() && this.onComplete(), this;
    },
    cancel: function() {
        return this.stopTimer() && this.onCancel(), this;
    },
    onStart: function() {
        this.fireEvent("start", this.subject);
    },
    onComplete: function() {
        this.fireEvent("complete", this.subject), this.callChain() || this.fireEvent("chainComplete", this.subject);
    },
    onCancel: function() {
        this.fireEvent("cancel", this.subject).clearChain();
    },
    pause: function() {
        return this.stopTimer(), this;
    },
    resume: function() {
        return this.startTimer(), this;
    },
    stopTimer: function() {
        return this.timer ? (this.time = $time() - this.time, this.timer = $clear(this.timer), 
        !0) : !1;
    },
    startTimer: function() {
        return this.timer ? !1 : (this.time = $time() - this.time, this.timer = this.step.periodical(Math.round(1e3 / this.options.fps), this), 
        !0);
    }
});

Fx.compute = function(from, to, delta) {
    return (to - from) * delta + from;
}, Fx.Durations = {
    "short": 250,
    normal: 500,
    "long": 1e3
}, Fx.CSS = new Class({
    Extends: Fx,
    prepare: function(element, property, values) {
        values = $splat(values);
        var values1 = values[1];
        $chk(values1) || (values[1] = values[0], values[0] = element.getStyle(property));
        var parsed = values.map(this.parse);
        return {
            from: parsed[0],
            to: parsed[1]
        };
    },
    parse: function(value) {
        return value = $lambda(value)(), value = "string" == typeof value ? value.split(" ") : $splat(value), 
        value.map(function(val) {
            val += "";
            var found = !1;
            return Fx.CSS.Parsers.each(function(parser) {
                if (!found) {
                    var parsed = parser.parse(val);
                    $chk(parsed) && (found = {
                        value: parsed,
                        parser: parser
                    });
                }
            }), found = found || {
                value: val,
                parser: Fx.CSS.Parsers.String
            };
        });
    },
    compute: function(from, to, delta) {
        var computed = [];
        return Math.min(from.length, to.length).times(function(i) {
            computed.push({
                value: from[i].parser.compute(from[i].value, to[i].value, delta),
                parser: from[i].parser
            });
        }), computed.$family = {
            name: "fx:css:value"
        }, computed;
    },
    serve: function(value, unit) {
        "fx:css:value" != $type(value) && (value = this.parse(value));
        var returned = [];
        return value.each(function(bit) {
            returned = returned.concat(bit.parser.serve(bit.value, unit));
        }), returned;
    },
    render: function(element, property, value, unit) {
        element.setStyle(property, this.serve(value, unit));
    },
    search: function(selector) {
        if (Fx.CSS.Cache[selector]) return Fx.CSS.Cache[selector];
        var to = {};
        return Array.each(document.styleSheets, function(sheet) {
            var href = sheet.href;
            if (!href || !href.contains("://") || href.contains(document.domain)) {
                var rules = sheet.rules || sheet.cssRules;
                Array.each(rules, function(rule) {
                    if (rule.style) {
                        var selectorText = rule.selectorText ? rule.selectorText.replace(/^\w+/, function(m) {
                            return m.toLowerCase();
                        }) : null;
                        selectorText && selectorText.test("^" + selector + "$") && Element.Styles.each(function(value, style) {
                            rule.style[style] && !Element.ShortStyles[style] && (value = rule.style[style] + "", 
                            to[style] = value.test(/^rgb/) ? value.rgbToHex() : value);
                        });
                    }
                });
            }
        }), Fx.CSS.Cache[selector] = to;
    }
}), Fx.CSS.Cache = {}, Fx.CSS.Parsers = new Hash({
    Color: {
        parse: function(value) {
            return value.match(/^#[0-9a-f]{3,6}$/i) ? value.hexToRgb(!0) : (value = value.match(/(\d+),\s*(\d+),\s*(\d+)/)) ? [ value[1], value[2], value[3] ] : !1;
        },
        compute: function(from, to, delta) {
            return from.map(function(value, i) {
                return Math.round(Fx.compute(from[i], to[i], delta));
            });
        },
        serve: function(value) {
            return value.map(Number);
        }
    },
    Number: {
        parse: parseFloat,
        compute: Fx.compute,
        serve: function(value, unit) {
            return unit ? value + unit : value;
        }
    },
    String: {
        parse: $lambda(!1),
        compute: $arguments(1),
        serve: $arguments(0)
    }
}), Fx.Tween = new Class({
    Extends: Fx.CSS,
    initialize: function(element, options) {
        this.element = this.subject = document.id(element), this.parent(options);
    },
    set: function(property, now) {
        return 1 == arguments.length && (now = property, property = this.property || this.options.property), 
        this.render(this.element, property, now, this.options.unit), this;
    },
    start: function(property, from, to) {
        if (!this.check(property, from, to)) return this;
        var args = Array.flatten(arguments);
        this.property = this.options.property || args.shift();
        var parsed = this.prepare(this.element, this.property, args);
        return this.parent(parsed.from, parsed.to);
    }
}), Element.Properties.tween = {
    set: function(options) {
        var tween = this.retrieve("tween");
        return tween && tween.cancel(), this.eliminate("tween").store("tween:options", $extend({
            link: "cancel"
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("tween")) && ((options || !this.retrieve("tween:options")) && this.set("tween", options), 
        this.store("tween", new Fx.Tween(this, this.retrieve("tween:options")))), this.retrieve("tween");
    }
}, Element.implement({
    tween: function() {
        return this.get("tween").start(arguments), this;
    },
    fade: function(how) {
        var toggle, fade = this.get("tween"), o = "opacity";
        switch (how = $pick(how, "toggle")) {
          case "in":
            fade.start(o, 1);
            break;

          case "out":
            fade.start(o, 0);
            break;

          case "show":
            fade.set(o, 1);
            break;

          case "hide":
            fade.set(o, 0);
            break;

          case "toggle":
            var flag = this.retrieve("fade:flag", 1 == this.get("opacity"));
            fade.start(o, flag ? 0 : 1), this.store("fade:flag", !flag), toggle = !0;
            break;

          default:
            fade.start(o, arguments);
        }
        return toggle || this.eliminate("fade:flag"), this;
    },
    highlight: function(start, end) {
        end || (end = this.retrieve("highlight:original", this.getStyle("background-color")), 
        end = "transparent" == end ? "#fff" : end);
        var tween = this.get("tween");
        return tween.start("background-color", start || "#ffff88", end).chain(function() {
            this.setStyle("background-color", this.retrieve("highlight:original")), tween.callChain();
        }.bind(this)), this;
    }
}), Fx.Morph = new Class({
    Extends: Fx.CSS,
    initialize: function(element, options) {
        this.element = this.subject = document.id(element), this.parent(options);
    },
    set: function(now) {
        "string" == typeof now && (now = this.search(now));
        for (var p in now) this.render(this.element, p, now[p], this.options.unit);
        return this;
    },
    compute: function(from, to, delta) {
        var now = {};
        for (var p in from) now[p] = this.parent(from[p], to[p], delta);
        return now;
    },
    start: function(properties) {
        if (!this.check(properties)) return this;
        "string" == typeof properties && (properties = this.search(properties));
        var from = {}, to = {};
        for (var p in properties) {
            var parsed = this.prepare(this.element, p, properties[p]);
            from[p] = parsed.from, to[p] = parsed.to;
        }
        return this.parent(from, to);
    }
}), Element.Properties.morph = {
    set: function(options) {
        var morph = this.retrieve("morph");
        return morph && morph.cancel(), this.eliminate("morph").store("morph:options", $extend({
            link: "cancel"
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("morph")) && ((options || !this.retrieve("morph:options")) && this.set("morph", options), 
        this.store("morph", new Fx.Morph(this, this.retrieve("morph:options")))), this.retrieve("morph");
    }
}, Element.implement({
    morph: function(props) {
        return this.get("morph").start(props), this;
    }
}), Fx.implement({
    getTransition: function() {
        var trans = this.options.transition || Fx.Transitions.Sine.easeInOut;
        if ("string" == typeof trans) {
            var data = trans.split(":");
            trans = Fx.Transitions, trans = trans[data[0]] || trans[data[0].capitalize()], data[1] && (trans = trans["ease" + data[1].capitalize() + (data[2] ? data[2].capitalize() : "")]);
        }
        return trans;
    }
}), Fx.Transition = function(transition, params) {
    return params = $splat(params), $extend(transition, {
        easeIn: function(pos) {
            return transition(pos, params);
        },
        easeOut: function(pos) {
            return 1 - transition(1 - pos, params);
        },
        easeInOut: function(pos) {
            return .5 >= pos ? transition(2 * pos, params) / 2 : (2 - transition(2 * (1 - pos), params)) / 2;
        }
    });
}, Fx.Transitions = new Hash({
    linear: $arguments(0)
}), Fx.Transitions.extend = function(transitions) {
    for (var transition in transitions) Fx.Transitions[transition] = new Fx.Transition(transitions[transition]);
}, Fx.Transitions.extend({
    Pow: function(p, x) {
        return Math.pow(p, x[0] || 6);
    },
    Expo: function(p) {
        return Math.pow(2, 8 * (p - 1));
    },
    Circ: function(p) {
        return 1 - Math.sin(Math.acos(p));
    },
    Sine: function(p) {
        return 1 - Math.sin((1 - p) * Math.PI / 2);
    },
    Back: function(p, x) {
        return x = x[0] || 1.618, Math.pow(p, 2) * ((x + 1) * p - x);
    },
    Bounce: function(p) {
        for (var value, a = 0, b = 1; 1; a += b, b /= 2) if (p >= (7 - 4 * a) / 11) {
            value = b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);
            break;
        }
        return value;
    },
    Elastic: function(p, x) {
        return Math.pow(2, 10 * --p) * Math.cos(20 * p * Math.PI * (x[0] || 1) / 3);
    }
}), [ "Quad", "Cubic", "Quart", "Quint" ].each(function(transition, i) {
    Fx.Transitions[transition] = new Fx.Transition(function(p) {
        return Math.pow(p, [ i + 2 ]);
    });
});

var Request = new Class({
    Implements: [ Chain, Events, Options ],
    options: {
        url: "",
        data: "",
        headers: {
            "X-Requested-With": "XMLHttpRequest",
            Accept: "text/javascript, text/html, application/xml, text/xml, */*"
        },
        async: !0,
        format: !1,
        method: "post",
        link: "ignore",
        isSuccess: null,
        emulation: !0,
        urlEncoded: !0,
        encoding: "utf-8",
        evalScripts: !1,
        evalResponse: !1,
        noCache: !1
    },
    initialize: function(options) {
        this.xhr = new Browser.Request(), this.setOptions(options), this.options.isSuccess = this.options.isSuccess || this.isSuccess, 
        this.headers = new Hash(this.options.headers);
    },
    onStateChange: function() {
        4 == this.xhr.readyState && this.running && (this.running = !1, this.status = 0, 
        $try(function() {
            this.status = this.xhr.status;
        }.bind(this)), this.xhr.onreadystatechange = $empty, this.options.isSuccess.call(this, this.status) ? (this.response = {
            text: this.xhr.responseText,
            xml: this.xhr.responseXML
        }, this.success(this.response.text, this.response.xml)) : (this.response = {
            text: null,
            xml: null
        }, this.failure()));
    },
    isSuccess: function() {
        return this.status >= 200 && 300 > this.status;
    },
    processScripts: function(text) {
        return this.options.evalResponse || /(ecma|java)script/.test(this.getHeader("Content-type")) ? $exec(text) : text.stripScripts(this.options.evalScripts);
    },
    success: function(text, xml) {
        this.onSuccess(this.processScripts(text), xml);
    },
    onSuccess: function() {
        this.fireEvent("complete", arguments).fireEvent("success", arguments).callChain();
    },
    failure: function() {
        this.onFailure();
    },
    onFailure: function() {
        this.fireEvent("complete").fireEvent("failure", this.xhr);
    },
    setHeader: function(name, value) {
        return this.headers.set(name, value), this;
    },
    getHeader: function(name) {
        return $try(function() {
            return this.xhr.getResponseHeader(name);
        }.bind(this));
    },
    check: function() {
        if (!this.running) return !0;
        switch (this.options.link) {
          case "cancel":
            return this.cancel(), !0;

          case "chain":
            return this.chain(this.caller.bind(this, arguments)), !1;
        }
        return !1;
    },
    send: function(options) {
        if (!this.check(options)) return this;
        this.running = !0;
        var type = $type(options);
        ("string" == type || "element" == type) && (options = {
            data: options
        });
        var old = this.options;
        options = $extend({
            data: old.data,
            url: old.url,
            method: old.method
        }, options);
        var data = options.data, url = options.url + "", method = options.method.toLowerCase();
        switch ($type(data)) {
          case "element":
            data = document.id(data).toQueryString();
            break;

          case "object":
          case "hash":
            data = Hash.toQueryString(data);
        }
        if (this.options.format) {
            var format = "format=" + this.options.format;
            data = data ? format + "&" + data : format;
        }
        if (this.options.emulation && ![ "get", "post" ].contains(method)) {
            var _method = "_method=" + method;
            data = data ? _method + "&" + data : _method, method = "post";
        }
        if (this.options.urlEncoded && "post" == method) {
            var encoding = this.options.encoding ? "; charset=" + this.options.encoding : "";
            this.headers.set("Content-type", "application/x-www-form-urlencoded" + encoding);
        }
        if (this.options.noCache) {
            var noCache = "noCache=" + new Date().getTime();
            data = data ? noCache + "&" + data : noCache;
        }
        var trimPosition = url.lastIndexOf("/");
        return trimPosition > -1 && (trimPosition = url.indexOf("#")) > -1 && (url = url.substr(0, trimPosition)), 
        data && "get" == method && (url = url + (url.contains("?") ? "&" : "?") + data, 
        data = null), this.xhr.open(method.toUpperCase(), url, this.options.async), this.xhr.onreadystatechange = this.onStateChange.bind(this), 
        this.headers.each(function(value, key) {
            try {
                this.xhr.setRequestHeader(key, value);
            } catch (e) {
                this.fireEvent("exception", [ key, value ]);
            }
        }, this), this.fireEvent("request"), this.xhr.send(data), this.options.async || this.onStateChange(), 
        this;
    },
    cancel: function() {
        return this.running ? (this.running = !1, this.xhr.abort(), this.xhr.onreadystatechange = $empty, 
        this.xhr = new Browser.Request(), this.fireEvent("cancel"), this) : this;
    }
});

(function() {
    var methods = {};
    [ "get", "post", "put", "delete", "GET", "POST", "PUT", "DELETE" ].each(function(method) {
        methods[method] = function() {
            var params = Array.link(arguments, {
                url: String.type,
                data: $defined
            });
            return this.send($extend(params, {
                method: method
            }));
        };
    }), Request.implement(methods);
})(), Element.Properties.send = {
    set: function(options) {
        var send = this.retrieve("send");
        return send && send.cancel(), this.eliminate("send").store("send:options", $extend({
            data: this,
            link: "cancel",
            method: this.get("method") || "post",
            url: this.get("action")
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("send")) && ((options || !this.retrieve("send:options")) && this.set("send", options), 
        this.store("send", new Request(this.retrieve("send:options")))), this.retrieve("send");
    }
}, Element.implement({
    send: function(url) {
        var sender = this.get("send");
        return sender.send({
            data: this,
            url: url || sender.options.url
        }), this;
    }
}), Request.HTML = new Class({
    Extends: Request,
    options: {
        update: !1,
        append: !1,
        evalScripts: !0,
        filter: !1
    },
    processHTML: function(text) {
        var match = text.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        text = match ? match[1] : text;
        var container = new Element("div");
        return $try(function() {
            var doc, root = "<root>" + text + "</root>";
            if (Browser.Engine.trident ? (doc = new ActiveXObject("Microsoft.XMLDOM"), doc.async = !1, 
            doc.loadXML(root)) : doc = new DOMParser().parseFromString(root, "text/xml"), root = doc.getElementsByTagName("root")[0], 
            !root) return null;
            for (var i = 0, k = root.childNodes.length; k > i; i++) {
                var child = Element.clone(root.childNodes[i], !0, !0);
                child && container.grab(child);
            }
            return container;
        }) || container.set("html", text);
    },
    success: function(text) {
        var options = this.options, response = this.response;
        response.html = text.stripScripts(function(script) {
            response.javascript = script;
        });
        var temp = this.processHTML(response.html);
        response.tree = temp.childNodes, response.elements = temp.getElements("*"), options.filter && (response.tree = response.elements.filter(options.filter)), 
        options.update ? document.id(options.update).empty().set("html", response.html) : options.append && document.id(options.append).adopt(temp.getChildren()), 
        options.evalScripts && $exec(response.javascript), this.onSuccess(response.tree, response.elements, response.html, response.javascript);
    }
}), Element.Properties.load = {
    set: function(options) {
        var load = this.retrieve("load");
        return load && load.cancel(), this.eliminate("load").store("load:options", $extend({
            data: this,
            link: "cancel",
            update: this,
            method: "get"
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("load")) && ((options || !this.retrieve("load:options")) && this.set("load", options), 
        this.store("load", new Request.HTML(this.retrieve("load:options")))), this.retrieve("load");
    }
}, Element.implement({
    load: function() {
        return this.get("load").send(Array.link(arguments, {
            data: Object.type,
            url: String.type
        })), this;
    }
}), Request.JSON = new Class({
    Extends: Request,
    options: {
        secure: !0
    },
    initialize: function(options) {
        this.parent(options), this.headers.extend({
            Accept: "application/json",
            "X-Request": "JSON"
        });
    },
    success: function(text) {
        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);
    }
}), MooTools.More = {
    version: "1.2.5.1",
    build: "254884f2b83651bf95260eed5c6cceb838e22d8e"
}, Class.Mutators.Binds = function(binds) {
    return binds;
}, Class.Mutators.initialize = function(initialize) {
    return function() {
        return $splat(this.Binds).each(function(name) {
            var original = this[name];
            original && (this[name] = original.bind(this));
        }, this), initialize.apply(this, arguments);
    };
}, Element.implement({
    measure: function(fn) {
        var vis = function(el) {
            return !(el && !el.offsetHeight && !el.offsetWidth);
        };
        if (vis(this)) return fn.apply(this);
        for (var parent = this.getParent(), toMeasure = []; !vis(parent) && parent != document.body; ) toMeasure.push(parent.expose()), 
        parent = parent.getParent();
        var restore = this.expose(), result = fn.apply(this);
        return restore(), toMeasure.each(function(restore) {
            restore();
        }), result;
    },
    expose: function() {
        if ("none" != this.getStyle("display")) return $empty;
        var before = this.style.cssText;
        return this.setStyles({
            display: "block",
            position: "absolute",
            visibility: "hidden"
        }), function() {
            this.style.cssText = before;
        }.bind(this);
    },
    getDimensions: function(options) {
        options = $merge({
            computeSize: !1
        }, options);
        var dim = {}, getSize = function(el, options) {
            return options.computeSize ? el.getComputedSize(options) : el.getSize();
        }, parent = this.getParent("body");
        if (parent && "none" == this.getStyle("display")) dim = this.measure(function() {
            return getSize(this, options);
        }); else if (parent) try {
            dim = getSize(this, options);
        } catch (e) {} else dim = {
            x: 0,
            y: 0
        };
        return $chk(dim.x) ? $extend(dim, {
            width: dim.x,
            height: dim.y
        }) : $extend(dim, {
            x: dim.width,
            y: dim.height
        });
    },
    getComputedSize: function(options) {
        options && options.plains && (options.planes = options.plains), options = $merge({
            styles: [ "padding", "border" ],
            planes: {
                height: [ "top", "bottom" ],
                width: [ "left", "right" ]
            },
            mode: "both"
        }, options);
        var size = {
            width: 0,
            height: 0
        };
        switch (options.mode) {
          case "vertical":
            delete size.width, delete options.planes.width;
            break;

          case "horizontal":
            delete size.height, delete options.planes.height;
        }
        var getStyles = [];
        $each(options.planes, function(plane) {
            plane.each(function(edge) {
                options.styles.each(function(style) {
                    getStyles.push("border" == style ? style + "-" + edge + "-" + "width" : style + "-" + edge);
                });
            });
        });
        var styles = {};
        getStyles.each(function(style) {
            styles[style] = this.getComputedStyle(style);
        }, this);
        var subtracted = [];
        return $each(options.planes, function(plane, key) {
            var capitalized = key.capitalize();
            size["total" + capitalized] = size["computed" + capitalized] = 0, plane.each(function(edge) {
                size["computed" + edge.capitalize()] = 0, getStyles.each(function(style) {
                    style.test(edge) && (styles[style] = styles[style].toInt() || 0, size["total" + capitalized] = size["total" + capitalized] + styles[style], 
                    size["computed" + edge.capitalize()] = size["computed" + edge.capitalize()] + styles[style]), 
                    style.test(edge) && key != style && (style.test("border") || style.test("padding")) && !subtracted.contains(style) && (subtracted.push(style), 
                    size["computed" + capitalized] = size["computed" + capitalized] - styles[style]);
                });
            });
        }), [ "Width", "Height" ].each(function(value) {
            var lower = value.toLowerCase();
            $chk(size[lower]) && (size[lower] = size[lower] + this["offset" + value] + size["computed" + value], 
            size["total" + value] = size[lower] + size["total" + value], delete size["computed" + value]);
        }, this), $extend(styles, size);
    }
});

var Drag = new Class({
    Implements: [ Events, Options ],
    options: {
        snap: 6,
        unit: "px",
        grid: !1,
        style: !0,
        limit: !1,
        handle: !1,
        invert: !1,
        preventDefault: !1,
        stopPropagation: !1,
        modifiers: {
            x: "left",
            y: "top"
        }
    },
    initialize: function() {
        var params = Array.link(arguments, {
            options: Object.type,
            element: $defined
        });
        this.element = document.id(params.element), this.document = this.element.getDocument(), 
        this.setOptions(params.options || {});
        var htype = $type(this.options.handle);
        this.handles = ("array" == htype || "collection" == htype ? $$(this.options.handle) : document.id(this.options.handle)) || this.element, 
        this.mouse = {
            now: {},
            pos: {}
        }, this.value = {
            start: {},
            now: {}
        }, this.selection = Browser.Engine.trident ? "selectstart" : "mousedown", this.bound = {
            start: this.start.bind(this),
            check: this.check.bind(this),
            drag: this.drag.bind(this),
            stop: this.stop.bind(this),
            cancel: this.cancel.bind(this),
            eventStop: $lambda(!1)
        }, this.attach();
    },
    attach: function() {
        return this.handles.addEvent("mousedown", this.bound.start), this;
    },
    detach: function() {
        return this.handles.removeEvent("mousedown", this.bound.start), this;
    },
    start: function(event) {
        if (!event.rightClick) {
            this.options.preventDefault && event.preventDefault(), this.options.stopPropagation && event.stopPropagation(), 
            this.mouse.start = event.page, this.fireEvent("beforeStart", this.element);
            var limit = this.options.limit;
            this.limit = {
                x: [],
                y: []
            };
            var styles = this.element.getStyles("left", "right", "top", "bottom");
            this._invert = {
                x: "left" == this.options.modifiers.x && "auto" == styles.left && !isNaN(styles.right.toInt()) && (this.options.modifiers.x = "right"),
                y: "top" == this.options.modifiers.y && "auto" == styles.top && !isNaN(styles.bottom.toInt()) && (this.options.modifiers.y = "bottom")
            };
            var z, coordinates;
            for (z in this.options.modifiers) if (this.options.modifiers[z]) {
                var style = this.element.getStyle(this.options.modifiers[z]);
                if (style && !style.match(/px$/) && (coordinates || (coordinates = this.element.getCoordinates(this.element.getOffsetParent())), 
                style = coordinates[this.options.modifiers[z]]), this.value.now[z] = this.options.style ? (style || 0).toInt() : this.element[this.options.modifiers[z]], 
                this.options.invert && (this.value.now[z] *= -1), this._invert[z] && (this.value.now[z] *= -1), 
                this.mouse.pos[z] = event.page[z] - this.value.now[z], limit && limit[z]) for (var i = 2; i--; i) $chk(limit[z][i]) && (this.limit[z][i] = $lambda(limit[z][i])());
            }
            "number" == $type(this.options.grid) && (this.options.grid = {
                x: this.options.grid,
                y: this.options.grid
            }), this.document.addEvents({
                mousemove: this.bound.check,
                mouseup: this.bound.cancel
            }), this.document.addEvent(this.selection, this.bound.eventStop);
        }
    },
    check: function(event) {
        this.options.preventDefault && event.preventDefault();
        var distance = Math.round(Math.sqrt(Math.pow(event.page.x - this.mouse.start.x, 2) + Math.pow(event.page.y - this.mouse.start.y, 2)));
        distance > this.options.snap && (this.cancel(), this.document.addEvents({
            mousemove: this.bound.drag,
            mouseup: this.bound.stop
        }), this.fireEvent("start", [ this.element, event ]).fireEvent("snap", this.element));
    },
    drag: function(event) {
        this.options.preventDefault && event.preventDefault(), this.mouse.now = event.page;
        for (var z in this.options.modifiers) this.options.modifiers[z] && (this.value.now[z] = this.mouse.now[z] - this.mouse.pos[z], 
        this.options.invert && (this.value.now[z] *= -1), this._invert[z] && (this.value.now[z] *= -1), 
        this.options.limit && this.limit[z] && ($chk(this.limit[z][1]) && this.value.now[z] > this.limit[z][1] ? this.value.now[z] = this.limit[z][1] : $chk(this.limit[z][0]) && this.value.now[z] < this.limit[z][0] && (this.value.now[z] = this.limit[z][0])), 
        this.options.grid[z] && (this.value.now[z] -= (this.value.now[z] - (this.limit[z][0] || 0)) % this.options.grid[z]), 
        this.options.style ? this.element.setStyle(this.options.modifiers[z], this.value.now[z] + this.options.unit) : this.element[this.options.modifiers[z]] = this.value.now[z]);
        this.fireEvent("drag", [ this.element, event ]);
    },
    cancel: function(event) {
        this.document.removeEvent("mousemove", this.bound.check), this.document.removeEvent("mouseup", this.bound.cancel), 
        event && (this.document.removeEvent(this.selection, this.bound.eventStop), this.fireEvent("cancel", this.element));
    },
    stop: function(event) {
        this.document.removeEvent(this.selection, this.bound.eventStop), this.document.removeEvent("mousemove", this.bound.drag), 
        this.document.removeEvent("mouseup", this.bound.stop), event && this.fireEvent("complete", [ this.element, event ]);
    }
});

Element.implement({
    makeResizable: function(options) {
        var drag = new Drag(this, $merge({
            modifiers: {
                x: "width",
                y: "height"
            }
        }, options));
        return this.store("resizer", drag), drag.addEvent("drag", function() {
            this.fireEvent("resize", drag);
        }.bind(this));
    }
});

var Slider = new Class({
    Implements: [ Events, Options ],
    Binds: [ "clickedElement", "draggedKnob", "scrolledElement" ],
    options: {
        onTick: function(position) {
            this.options.snap && (position = this.toPosition(this.step)), this.knob.setStyle(this.property, position);
        },
        initialStep: 0,
        snap: !1,
        offset: 0,
        range: !1,
        wheel: !1,
        steps: 100,
        mode: "horizontal"
    },
    initialize: function(element, knob, options) {
        this.setOptions(options), this.element = document.id(element), this.knob = document.id(knob), 
        this.previousChange = this.previousEnd = this.step = -1;
        var offset, limit = {}, modifiers = {
            x: !1,
            y: !1
        };
        switch (this.options.mode) {
          case "vertical":
            this.axis = "y", this.property = "top", offset = "offsetHeight";
            break;

          case "horizontal":
            this.axis = "x", this.property = "left", offset = "offsetWidth";
        }
        this.full = this.element.measure(function() {
            return this.half = this.knob[offset] / 2, this.element[offset] - this.knob[offset] + 2 * this.options.offset;
        }.bind(this)), this.setRange(this.options.range), this.knob.setStyle("position", "relative").setStyle(this.property, -this.options.offset), 
        modifiers[this.axis] = this.property, limit[this.axis] = [ -this.options.offset, this.full - this.options.offset ];
        var dragOptions = {
            snap: 0,
            limit: limit,
            modifiers: modifiers,
            onDrag: this.draggedKnob,
            onStart: this.draggedKnob,
            onBeforeStart: function() {
                this.isDragging = !0;
            }.bind(this),
            onCancel: function() {
                this.isDragging = !1;
            }.bind(this),
            onComplete: function() {
                this.isDragging = !1, this.draggedKnob(), this.end();
            }.bind(this)
        };
        this.options.snap && (dragOptions.grid = Math.ceil(this.stepWidth), dragOptions.limit[this.axis][1] = this.full), 
        this.drag = new Drag(this.knob, dragOptions), this.attach(), null != this.options.initialStep && this.set(this.options.initialStep);
    },
    attach: function() {
        return this.element.addEvent("mousedown", this.clickedElement), this.options.wheel && this.element.addEvent("mousewheel", this.scrolledElement), 
        this.drag.attach(), this;
    },
    detach: function() {
        return this.element.removeEvent("mousedown", this.clickedElement), this.element.removeEvent("mousewheel", this.scrolledElement), 
        this.drag.detach(), this;
    },
    set: function(step) {
        return this.range > 0 ^ this.min > step || (step = this.min), this.range > 0 ^ step > this.max || (step = this.max), 
        this.step = Math.round(step), this.checkStep(), this.fireEvent("tick", this.toPosition(this.step)), 
        this.end(), this;
    },
    setRange: function(range, pos) {
        return this.min = $pick(range[0], 0), this.max = $pick(range[1], this.options.steps), 
        this.range = this.max - this.min, this.steps = this.options.steps || this.full, 
        this.stepSize = Math.abs(this.range) / this.steps, this.stepWidth = this.stepSize * this.full / Math.abs(this.range), 
        this.set($pick(pos, this.step).floor(this.min).max(this.max)), this;
    },
    clickedElement: function(event) {
        if (!this.isDragging && event.target != this.knob) {
            var dir = 0 > this.range ? -1 : 1, position = event.page[this.axis] - this.element.getPosition()[this.axis] - this.half;
            position = position.limit(-this.options.offset, this.full - this.options.offset), 
            this.step = Math.round(this.min + dir * this.toStep(position)), this.checkStep(), 
            this.fireEvent("tick", position), this.end();
        }
    },
    scrolledElement: function(event) {
        var mode = "horizontal" == this.options.mode ? 0 > event.wheel : event.wheel > 0;
        this.set(mode ? this.step - this.stepSize : this.step + this.stepSize), event.stop();
    },
    draggedKnob: function() {
        var dir = 0 > this.range ? -1 : 1, position = this.drag.value.now[this.axis];
        position = position.limit(-this.options.offset, this.full - this.options.offset), 
        this.step = Math.round(this.min + dir * this.toStep(position)), this.checkStep();
    },
    checkStep: function() {
        this.previousChange != this.step && (this.previousChange = this.step, this.fireEvent("change", this.step));
    },
    end: function() {
        this.previousEnd !== this.step && (this.previousEnd = this.step, this.fireEvent("complete", this.step + ""));
    },
    toStep: function(position) {
        var step = (position + this.options.offset) * this.stepSize / this.full * this.steps;
        return this.options.steps ? Math.round(step -= step % this.stepSize) : step;
    },
    toPosition: function(step) {
        return this.full * Math.abs(this.min - step) / (this.steps * this.stepSize) - this.options.offset;
    }
}), Color = new Native({
    initialize: function(color, type) {
        switch (arguments.length >= 3 ? (type = "rgb", color = Array.slice(arguments, 0, 3)) : "string" == typeof color && (color = color.match(/rgb/) ? color.rgbToHex().hexToRgb(!0) : color.match(/hsb/) ? color.hsbToRgb() : color.hexToRgb(!0)), 
        type = type || "rgb") {
          case "hsb":
            var old = color;
            color = color.hsbToRgb(), color.hsb = old;
            break;

          case "hex":
            color = color.hexToRgb(!0);
        }
        return color.rgb = color.slice(0, 3), color.hsb = color.hsb || color.rgbToHsb(), 
        color.hex = color.rgbToHex(), $extend(color, this);
    }
});

Color.implement({
    mix: function() {
        var colors = Array.slice(arguments), alpha = "number" == $type(colors.getLast()) ? colors.pop() : 50, rgb = this.slice();
        return colors.each(function(color) {
            color = new Color(color);
            for (var i = 0; 3 > i; i++) rgb[i] = Math.round(rgb[i] / 100 * (100 - alpha) + color[i] / 100 * alpha);
        }), new Color(rgb, "rgb");
    },
    invert: function() {
        return new Color(this.map(function(value) {
            return 255 - value;
        }));
    },
    setHue: function(value) {
        return new Color([ value, this.hsb[1], this.hsb[2] ], "hsb");
    },
    setSaturation: function(percent) {
        return new Color([ this.hsb[0], percent, this.hsb[2] ], "hsb");
    },
    setBrightness: function(percent) {
        return new Color([ this.hsb[0], this.hsb[1], percent ], "hsb");
    }
});

var $RGB = function(r, g, b) {
    return new Color([ r, g, b ], "rgb");
}, $HSB = function(h, s, b) {
    return new Color([ h, s, b ], "hsb");
}, $HEX = function(hex) {
    return new Color(hex, "hex");
};

Array.implement({
    rgbToHsb: function() {
        var red = this[0], green = this[1], blue = this[2], hue = 0, max = Math.max(red, green, blue), min = Math.min(red, green, blue), delta = max - min, brightness = max / 255, saturation = 0 != max ? delta / max : 0;
        if (0 != saturation) {
            var rr = (max - red) / delta, gr = (max - green) / delta, br = (max - blue) / delta;
            hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr, hue /= 6, 
            0 > hue && hue++;
        }
        return [ Math.round(360 * hue), Math.round(100 * saturation), Math.round(100 * brightness) ];
    },
    hsbToRgb: function() {
        var br = Math.round(255 * (this[2] / 100));
        if (0 == this[1]) return [ br, br, br ];
        var hue = this[0] % 360, f = hue % 60, p = Math.round(255 * (this[2] * (100 - this[1]) / 1e4)), q = Math.round(255 * (this[2] * (6e3 - this[1] * f) / 6e5)), t = Math.round(255 * (this[2] * (6e3 - this[1] * (60 - f)) / 6e5));
        switch (Math.floor(hue / 60)) {
          case 0:
            return [ br, t, p ];

          case 1:
            return [ q, br, p ];

          case 2:
            return [ p, br, t ];

          case 3:
            return [ p, q, br ];

          case 4:
            return [ t, p, br ];

          case 5:
            return [ br, p, q ];
        }
        return !1;
    }
}), String.implement({
    rgbToHsb: function() {
        var rgb = this.match(/\d{1,3}/g);
        return rgb ? rgb.rgbToHsb() : null;
    },
    hsbToRgb: function() {
        var hsb = this.match(/\d{1,3}/g);
        return hsb ? hsb.hsbToRgb() : null;
    }
}), Request.JSON = new Class({
    Extends: Request,
    options: {
        secure: !0
    },
    initialize: function(options) {
        this.parent(options), this.headers.extend({
            Accept: "application/json",
            "X-Request": "JSON"
        });
    },
    success: function(text) {
        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);
    }
}), MooTools.More = {
    version: "1.2.5.1",
    build: "254884f2b83651bf95260eed5c6cceb838e22d8e"
}, Class.Mutators.Binds = function(binds) {
    return binds;
}, Class.Mutators.initialize = function(initialize) {
    return function() {
        return $splat(this.Binds).each(function(name) {
            var original = this[name];
            original && (this[name] = original.bind(this));
        }, this), initialize.apply(this, arguments);
    };
}, Fx.Elements = new Class({
    Extends: Fx.CSS,
    initialize: function(elements, options) {
        this.elements = this.subject = $$(elements), this.parent(options);
    },
    compute: function(from, to, delta) {
        var now = {};
        for (var i in from) {
            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};
            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);
        }
        return now;
    },
    set: function(now) {
        for (var i in now) if (this.elements[i]) {
            var iNow = now[i];
            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);
        }
        return this;
    },
    start: function(obj) {
        if (!this.check(obj)) return this;
        var from = {}, to = {};
        for (var i in obj) if (this.elements[i]) {
            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};
            for (var p in iProps) {
                var parsed = this.prepare(this.elements[i], p, iProps[p]);
                iFrom[p] = parsed.from, iTo[p] = parsed.to;
            }
        }
        return this.parent(from, to);
    }
}), Fx.Slide = new Class({
    Extends: Fx,
    options: {
        mode: "vertical",
        wrapper: !1,
        hideOverflow: !0,
        resetHeight: !1
    },
    initialize: function(element, options) {
        this.addEvent("complete", function() {
            this.open = 0 != this.wrapper["offset" + this.layout.capitalize()], this.open && this.options.resetHeight && this.wrapper.setStyle("height", ""), 
            this.open && Browser.Engine.webkit419 && this.element.dispose().inject(this.wrapper);
        }, !0), this.element = this.subject = document.id(element), this.parent(options);
        var wrapper = this.element.retrieve("wrapper"), styles = this.element.getStyles("margin", "position", "overflow");
        this.options.hideOverflow && (styles = $extend(styles, {
            overflow: "hidden"
        })), this.options.wrapper && (wrapper = document.id(this.options.wrapper).setStyles(styles)), 
        this.wrapper = wrapper || new Element("div", {
            styles: styles
        }).wraps(this.element), this.element.store("wrapper", this.wrapper).setStyle("margin", 0), 
        this.now = [], this.open = !0;
    },
    vertical: function() {
        this.margin = "margin-top", this.layout = "height", this.offset = this.element.offsetHeight;
    },
    horizontal: function() {
        this.margin = "margin-left", this.layout = "width", this.offset = this.element.offsetWidth;
    },
    set: function(now) {
        return this.element.setStyle(this.margin, now[0]), this.wrapper.setStyle(this.layout, now[1]), 
        this;
    },
    compute: function(from, to, delta) {
        return [ 0, 1 ].map(function(i) {
            return Fx.compute(from[i], to[i], delta);
        });
    },
    start: function(how, mode) {
        if (!this.check(how, mode)) return this;
        this[mode || this.options.mode]();
        var start, margin = this.element.getStyle(this.margin).toInt(), layout = this.wrapper.getStyle(this.layout).toInt(), caseIn = [ [ margin, layout ], [ 0, this.offset ] ], caseOut = [ [ margin, layout ], [ -this.offset, 0 ] ];
        switch (how) {
          case "in":
            start = caseIn;
            break;

          case "out":
            start = caseOut;
            break;

          case "toggle":
            start = 0 == layout ? caseIn : caseOut;
        }
        return this.parent(start[0], start[1]);
    },
    slideIn: function(mode) {
        return this.start("in", mode);
    },
    slideOut: function(mode) {
        return this.start("out", mode);
    },
    hide: function(mode) {
        return this[mode || this.options.mode](), this.open = !1, this.set([ -this.offset, 0 ]);
    },
    show: function(mode) {
        return this[mode || this.options.mode](), this.open = !0, this.set([ 0, this.offset ]);
    },
    toggle: function(mode) {
        return this.start("toggle", mode);
    }
}), Element.Properties.slide = {
    set: function(options) {
        var slide = this.retrieve("slide");
        return slide && slide.cancel(), this.eliminate("slide").store("slide:options", $extend({
            link: "cancel"
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("slide")) && ((options || !this.retrieve("slide:options")) && this.set("slide", options), 
        this.store("slide", new Fx.Slide(this, this.retrieve("slide:options")))), this.retrieve("slide");
    }
}, Element.implement({
    slide: function(how, mode) {
        how = how || "toggle";
        var toggle, slide = this.get("slide");
        switch (how) {
          case "hide":
            slide.hide(mode);
            break;

          case "show":
            slide.show(mode);
            break;

          case "toggle":
            var flag = this.retrieve("slide:flag", slide.open);
            slide[flag ? "slideOut" : "slideIn"](mode), this.store("slide:flag", !flag), toggle = !0;
            break;

          default:
            slide.start(how, mode);
        }
        return toggle || this.eliminate("slide:flag"), this;
    }
}), Hash.Cookie = new Class({
    Extends: Cookie,
    options: {
        autoSave: !0
    },
    initialize: function(name, options) {
        this.parent(name, options), this.load();
    },
    save: function() {
        var value = JSON.encode(this.hash);
        return !value || value.length > 4096 ? !1 : ("{}" == value ? this.dispose() : this.write(value), 
        !0);
    },
    load: function() {
        return this.hash = new Hash(JSON.decode(this.read(), !0)), this;
    }
}), Hash.each(Hash.prototype, function(method, name) {
    "function" == typeof method && Hash.Cookie.implement(name, function() {
        var value = method.apply(this.hash, arguments);
        return this.options.autoSave && this.save(), value;
    });
}), function() {
    var read = function(option, element) {
        return option ? "function" == $type(option) ? option(element) : element.get(option) : "";
    };
    this.Tips = new Class({
        Implements: [ Events, Options ],
        options: {
            onShow: function() {
                this.tip.setStyle("display", "block");
            },
            onHide: function() {
                this.tip.setStyle("display", "none");
            },
            title: "title",
            text: function(element) {
                return element.get("rel") || element.get("href");
            },
            showDelay: 100,
            hideDelay: 100,
            className: "tip-wrap",
            offset: {
                x: 16,
                y: 16
            },
            windowPadding: {
                x: 0,
                y: 0
            },
            fixed: !1
        },
        initialize: function() {
            var params = Array.link(arguments, {
                options: Object.type,
                elements: $defined
            });
            this.setOptions(params.options), params.elements && this.attach(params.elements), 
            this.container = new Element("div", {
                "class": "tip"
            });
        },
        toElement: function() {
            return this.tip ? this.tip : this.tip = new Element("div", {
                "class": this.options.className,
                styles: {
                    position: "absolute",
                    top: 0,
                    left: 0
                }
            }).adopt(new Element("div", {
                "class": "tip-top"
            }), this.container, new Element("div", {
                "class": "tip-bottom"
            }));
        },
        attach: function(elements) {
            return $$(elements).each(function(element) {
                var title = read(this.options.title, element), text = read(this.options.text, element);
                element.erase("title").store("tip:native", title).retrieve("tip:title", title), 
                element.retrieve("tip:text", text), this.fireEvent("attach", [ element ]);
                var events = [ "enter", "leave" ];
                this.options.fixed || events.push("move"), events.each(function(value) {
                    var event = element.retrieve("tip:" + value);
                    event || (event = this["element" + value.capitalize()].bindWithEvent(this, element)), 
                    element.store("tip:" + value, event).addEvent("mouse" + value, event);
                }, this);
            }, this), this;
        },
        detach: function(elements) {
            return $$(elements).each(function(element) {
                if ([ "enter", "leave", "move" ].each(function(value) {
                    element.removeEvent("mouse" + value, element.retrieve("tip:" + value)).eliminate("tip:" + value);
                }), this.fireEvent("detach", [ element ]), "title" == this.options.title) {
                    var original = element.retrieve("tip:native");
                    original && element.set("title", original);
                }
            }, this), this;
        },
        elementEnter: function(event, element) {
            this.container.empty(), [ "title", "text" ].each(function(value) {
                var content = element.retrieve("tip:" + value);
                content && this.fill(new Element("div", {
                    "class": "tip-" + value
                }).inject(this.container), content);
            }, this), $clear(this.timer), this.timer = function() {
                this.show(element), this.position(this.options.fixed ? {
                    page: element.getPosition()
                } : event);
            }.delay(this.options.showDelay, this);
        },
        elementLeave: function(event, element) {
            $clear(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, element), 
            this.fireForParent(event, element);
        },
        fireForParent: function(event, element) {
            element = element.getParent(), element && element != document.body && (element.retrieve("tip:enter") ? element.fireEvent("mouseenter", event) : this.fireForParent(event, element));
        },
        elementMove: function(event) {
            this.position(event);
        },
        position: function(event) {
            this.tip || document.id(this);
            var size = window.getSize(), scroll = window.getScroll(), tip = {
                x: this.tip.offsetWidth,
                y: this.tip.offsetHeight
            }, props = {
                x: "left",
                y: "top"
            }, obj = {};
            for (var z in props) obj[props[z]] = event.page[z] + this.options.offset[z], obj[props[z]] + tip[z] - scroll[z] > size[z] - this.options.windowPadding[z] && (obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z]);
            this.tip.setStyles(obj);
        },
        fill: function(element, contents) {
            "string" == typeof contents ? element.set("html", contents) : element.adopt(contents);
        },
        show: function(element) {
            this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), 
            this.fireEvent("show", [ this.tip, element ]);
        },
        hide: function(element) {
            this.tip || document.id(this), this.fireEvent("hide", [ this.tip, element ]);
        }
    });
}();

var Color = new Native({
    initialize: function(color, type) {
        switch (arguments.length >= 3 ? (type = "rgb", color = Array.slice(arguments, 0, 3)) : "string" == typeof color && (color = color.match(/rgb/) ? color.rgbToHex().hexToRgb(!0) : color.match(/hsb/) ? color.hsbToRgb() : color.hexToRgb(!0)), 
        type = type || "rgb") {
          case "hsb":
            var old = color;
            color = color.hsbToRgb(), color.hsb = old;
            break;

          case "hex":
            color = color.hexToRgb(!0);
        }
        return color.rgb = color.slice(0, 3), color.hsb = color.hsb || color.rgbToHsb(), 
        color.hex = color.rgbToHex(), $extend(color, this);
    }
});

Color.implement({
    mix: function() {
        var colors = Array.slice(arguments), alpha = "number" == $type(colors.getLast()) ? colors.pop() : 50, rgb = this.slice();
        return colors.each(function(color) {
            color = new Color(color);
            for (var i = 0; 3 > i; i++) rgb[i] = Math.round(rgb[i] / 100 * (100 - alpha) + color[i] / 100 * alpha);
        }), new Color(rgb, "rgb");
    },
    invert: function() {
        return new Color(this.map(function(value) {
            return 255 - value;
        }));
    },
    setHue: function(value) {
        return new Color([ value, this.hsb[1], this.hsb[2] ], "hsb");
    },
    setSaturation: function(percent) {
        return new Color([ this.hsb[0], percent, this.hsb[2] ], "hsb");
    },
    setBrightness: function(percent) {
        return new Color([ this.hsb[0], this.hsb[1], percent ], "hsb");
    }
});

var $RGB = function(r, g, b) {
    return new Color([ r, g, b ], "rgb");
}, $HSB = function(h, s, b) {
    return new Color([ h, s, b ], "hsb");
}, $HEX = function(hex) {
    return new Color(hex, "hex");
};

Array.implement({
    rgbToHsb: function() {
        var red = this[0], green = this[1], blue = this[2], hue = 0, max = Math.max(red, green, blue), min = Math.min(red, green, blue), delta = max - min, brightness = max / 255, saturation = 0 != max ? delta / max : 0;
        if (0 != saturation) {
            var rr = (max - red) / delta, gr = (max - green) / delta, br = (max - blue) / delta;
            hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr, hue /= 6, 
            0 > hue && hue++;
        }
        return [ Math.round(360 * hue), Math.round(100 * saturation), Math.round(100 * brightness) ];
    },
    hsbToRgb: function() {
        var br = Math.round(255 * (this[2] / 100));
        if (0 == this[1]) return [ br, br, br ];
        var hue = this[0] % 360, f = hue % 60, p = Math.round(255 * (this[2] * (100 - this[1]) / 1e4)), q = Math.round(255 * (this[2] * (6e3 - this[1] * f) / 6e5)), t = Math.round(255 * (this[2] * (6e3 - this[1] * (60 - f)) / 6e5));
        switch (Math.floor(hue / 60)) {
          case 0:
            return [ br, t, p ];

          case 1:
            return [ q, br, p ];

          case 2:
            return [ p, br, t ];

          case 3:
            return [ p, q, br ];

          case 4:
            return [ t, p, br ];

          case 5:
            return [ br, p, q ];
        }
        return !1;
    }
}), String.implement({
    rgbToHsb: function() {
        var rgb = this.match(/\d{1,3}/g);
        return rgb ? rgb.rgbToHsb() : null;
    },
    hsbToRgb: function() {
        var hsb = this.match(/\d{1,3}/g);
        return hsb ? hsb.hsbToRgb() : null;
    }
}), Request.JSON = new Class({
    Extends: Request,
    options: {
        secure: !0
    },
    initialize: function(options) {
        this.parent(options), this.headers.extend({
            Accept: "application/json",
            "X-Request": "JSON"
        });
    },
    success: function(text) {
        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);
    }
}), MooTools.More = {
    version: "1.2.5.1",
    build: "254884f2b83651bf95260eed5c6cceb838e22d8e"
}, Class.Mutators.Binds = function(binds) {
    return binds;
}, Class.Mutators.initialize = function(initialize) {
    return function() {
        return $splat(this.Binds).each(function(name) {
            var original = this[name];
            original && (this[name] = original.bind(this));
        }, this), initialize.apply(this, arguments);
    };
}, Fx.Elements = new Class({
    Extends: Fx.CSS,
    initialize: function(elements, options) {
        this.elements = this.subject = $$(elements), this.parent(options);
    },
    compute: function(from, to, delta) {
        var now = {};
        for (var i in from) {
            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};
            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);
        }
        return now;
    },
    set: function(now) {
        for (var i in now) if (this.elements[i]) {
            var iNow = now[i];
            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);
        }
        return this;
    },
    start: function(obj) {
        if (!this.check(obj)) return this;
        var from = {}, to = {};
        for (var i in obj) if (this.elements[i]) {
            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};
            for (var p in iProps) {
                var parsed = this.prepare(this.elements[i], p, iProps[p]);
                iFrom[p] = parsed.from, iTo[p] = parsed.to;
            }
        }
        return this.parent(from, to);
    }
}), Fx.Slide = new Class({
    Extends: Fx,
    options: {
        mode: "vertical",
        wrapper: !1,
        hideOverflow: !0,
        resetHeight: !1
    },
    initialize: function(element, options) {
        this.addEvent("complete", function() {
            this.open = 0 != this.wrapper["offset" + this.layout.capitalize()], this.open && this.options.resetHeight && this.wrapper.setStyle("height", ""), 
            this.open && Browser.Engine.webkit419 && this.element.dispose().inject(this.wrapper);
        }, !0), this.element = this.subject = document.id(element), this.parent(options);
        var wrapper = this.element.retrieve("wrapper"), styles = this.element.getStyles("margin", "position", "overflow");
        this.options.hideOverflow && (styles = $extend(styles, {
            overflow: "hidden"
        })), this.options.wrapper && (wrapper = document.id(this.options.wrapper).setStyles(styles)), 
        this.wrapper = wrapper || new Element("div", {
            styles: styles
        }).wraps(this.element), this.element.store("wrapper", this.wrapper).setStyle("margin", 0), 
        this.now = [], this.open = !0;
    },
    vertical: function() {
        this.margin = "margin-top", this.layout = "height", this.offset = this.element.offsetHeight;
    },
    horizontal: function() {
        this.margin = "margin-left", this.layout = "width", this.offset = this.element.offsetWidth;
    },
    set: function(now) {
        return this.element.setStyle(this.margin, now[0]), this.wrapper.setStyle(this.layout, now[1]), 
        this;
    },
    compute: function(from, to, delta) {
        return [ 0, 1 ].map(function(i) {
            return Fx.compute(from[i], to[i], delta);
        });
    },
    start: function(how, mode) {
        if (!this.check(how, mode)) return this;
        this[mode || this.options.mode]();
        var start, margin = this.element.getStyle(this.margin).toInt(), layout = this.wrapper.getStyle(this.layout).toInt(), caseIn = [ [ margin, layout ], [ 0, this.offset ] ], caseOut = [ [ margin, layout ], [ -this.offset, 0 ] ];
        switch (how) {
          case "in":
            start = caseIn;
            break;

          case "out":
            start = caseOut;
            break;

          case "toggle":
            start = 0 == layout ? caseIn : caseOut;
        }
        return this.parent(start[0], start[1]);
    },
    slideIn: function(mode) {
        return this.start("in", mode);
    },
    slideOut: function(mode) {
        return this.start("out", mode);
    },
    hide: function(mode) {
        return this[mode || this.options.mode](), this.open = !1, this.set([ -this.offset, 0 ]);
    },
    show: function(mode) {
        return this[mode || this.options.mode](), this.open = !0, this.set([ 0, this.offset ]);
    },
    toggle: function(mode) {
        return this.start("toggle", mode);
    }
}), Element.Properties.slide = {
    set: function(options) {
        var slide = this.retrieve("slide");
        return slide && slide.cancel(), this.eliminate("slide").store("slide:options", $extend({
            link: "cancel"
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("slide")) && ((options || !this.retrieve("slide:options")) && this.set("slide", options), 
        this.store("slide", new Fx.Slide(this, this.retrieve("slide:options")))), this.retrieve("slide");
    }
}, Element.implement({
    slide: function(how, mode) {
        how = how || "toggle";
        var toggle, slide = this.get("slide");
        switch (how) {
          case "hide":
            slide.hide(mode);
            break;

          case "show":
            slide.show(mode);
            break;

          case "toggle":
            var flag = this.retrieve("slide:flag", slide.open);
            slide[flag ? "slideOut" : "slideIn"](mode), this.store("slide:flag", !flag), toggle = !0;
            break;

          default:
            slide.start(how, mode);
        }
        return toggle || this.eliminate("slide:flag"), this;
    }
}), Hash.Cookie = new Class({
    Extends: Cookie,
    options: {
        autoSave: !0
    },
    initialize: function(name, options) {
        this.parent(name, options), this.load();
    },
    save: function() {
        var value = JSON.encode(this.hash);
        return !value || value.length > 4096 ? !1 : ("{}" == value ? this.dispose() : this.write(value), 
        !0);
    },
    load: function() {
        return this.hash = new Hash(JSON.decode(this.read(), !0)), this;
    }
}), Hash.each(Hash.prototype, function(method, name) {
    "function" == typeof method && Hash.Cookie.implement(name, function() {
        var value = method.apply(this.hash, arguments);
        return this.options.autoSave && this.save(), value;
    });
}), function() {
    var read = function(option, element) {
        return option ? "function" == $type(option) ? option(element) : element.get(option) : "";
    };
    this.Tips = new Class({
        Implements: [ Events, Options ],
        options: {
            onShow: function() {
                this.tip.setStyle("display", "block");
            },
            onHide: function() {
                this.tip.setStyle("display", "none");
            },
            title: "title",
            text: function(element) {
                return element.get("rel") || element.get("href");
            },
            showDelay: 100,
            hideDelay: 100,
            className: "tip-wrap",
            offset: {
                x: 16,
                y: 16
            },
            windowPadding: {
                x: 0,
                y: 0
            },
            fixed: !1
        },
        initialize: function() {
            var params = Array.link(arguments, {
                options: Object.type,
                elements: $defined
            });
            this.setOptions(params.options), params.elements && this.attach(params.elements), 
            this.container = new Element("div", {
                "class": "tip"
            });
        },
        toElement: function() {
            return this.tip ? this.tip : this.tip = new Element("div", {
                "class": this.options.className,
                styles: {
                    position: "absolute",
                    top: 0,
                    left: 0
                }
            }).adopt(new Element("div", {
                "class": "tip-top"
            }), this.container, new Element("div", {
                "class": "tip-bottom"
            }));
        },
        attach: function(elements) {
            return $$(elements).each(function(element) {
                var title = read(this.options.title, element), text = read(this.options.text, element);
                element.erase("title").store("tip:native", title).retrieve("tip:title", title), 
                element.retrieve("tip:text", text), this.fireEvent("attach", [ element ]);
                var events = [ "enter", "leave" ];
                this.options.fixed || events.push("move"), events.each(function(value) {
                    var event = element.retrieve("tip:" + value);
                    event || (event = this["element" + value.capitalize()].bindWithEvent(this, element)), 
                    element.store("tip:" + value, event).addEvent("mouse" + value, event);
                }, this);
            }, this), this;
        },
        detach: function(elements) {
            return $$(elements).each(function(element) {
                if ([ "enter", "leave", "move" ].each(function(value) {
                    element.removeEvent("mouse" + value, element.retrieve("tip:" + value)).eliminate("tip:" + value);
                }), this.fireEvent("detach", [ element ]), "title" == this.options.title) {
                    var original = element.retrieve("tip:native");
                    original && element.set("title", original);
                }
            }, this), this;
        },
        elementEnter: function(event, element) {
            this.container.empty(), [ "title", "text" ].each(function(value) {
                var content = element.retrieve("tip:" + value);
                content && this.fill(new Element("div", {
                    "class": "tip-" + value
                }).inject(this.container), content);
            }, this), $clear(this.timer), this.timer = function() {
                this.show(element), this.position(this.options.fixed ? {
                    page: element.getPosition()
                } : event);
            }.delay(this.options.showDelay, this);
        },
        elementLeave: function(event, element) {
            $clear(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, element), 
            this.fireForParent(event, element);
        },
        fireForParent: function(event, element) {
            element = element.getParent(), element && element != document.body && (element.retrieve("tip:enter") ? element.fireEvent("mouseenter", event) : this.fireForParent(event, element));
        },
        elementMove: function(event) {
            this.position(event);
        },
        position: function(event) {
            this.tip || document.id(this);
            var size = window.getSize(), scroll = window.getScroll(), tip = {
                x: this.tip.offsetWidth,
                y: this.tip.offsetHeight
            }, props = {
                x: "left",
                y: "top"
            }, obj = {};
            for (var z in props) obj[props[z]] = event.page[z] + this.options.offset[z], obj[props[z]] + tip[z] - scroll[z] > size[z] - this.options.windowPadding[z] && (obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z]);
            this.tip.setStyles(obj);
        },
        fill: function(element, contents) {
            "string" == typeof contents ? element.set("html", contents) : element.adopt(contents);
        },
        show: function(element) {
            this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), 
            this.fireEvent("show", [ this.tip, element ]);
        },
        hide: function(element) {
            this.tip || document.id(this), this.fireEvent("hide", [ this.tip, element ]);
        }
    });
}();

var Color = new Native({
    initialize: function(color, type) {
        switch (arguments.length >= 3 ? (type = "rgb", color = Array.slice(arguments, 0, 3)) : "string" == typeof color && (color = color.match(/rgb/) ? color.rgbToHex().hexToRgb(!0) : color.match(/hsb/) ? color.hsbToRgb() : color.hexToRgb(!0)), 
        type = type || "rgb") {
          case "hsb":
            var old = color;
            color = color.hsbToRgb(), color.hsb = old;
            break;

          case "hex":
            color = color.hexToRgb(!0);
        }
        return color.rgb = color.slice(0, 3), color.hsb = color.hsb || color.rgbToHsb(), 
        color.hex = color.rgbToHex(), $extend(color, this);
    }
});

Color.implement({
    mix: function() {
        var colors = Array.slice(arguments), alpha = "number" == $type(colors.getLast()) ? colors.pop() : 50, rgb = this.slice();
        return colors.each(function(color) {
            color = new Color(color);
            for (var i = 0; 3 > i; i++) rgb[i] = Math.round(rgb[i] / 100 * (100 - alpha) + color[i] / 100 * alpha);
        }), new Color(rgb, "rgb");
    },
    invert: function() {
        return new Color(this.map(function(value) {
            return 255 - value;
        }));
    },
    setHue: function(value) {
        return new Color([ value, this.hsb[1], this.hsb[2] ], "hsb");
    },
    setSaturation: function(percent) {
        return new Color([ this.hsb[0], percent, this.hsb[2] ], "hsb");
    },
    setBrightness: function(percent) {
        return new Color([ this.hsb[0], this.hsb[1], percent ], "hsb");
    }
});

var $RGB = function(r, g, b) {
    return new Color([ r, g, b ], "rgb");
}, $HSB = function(h, s, b) {
    return new Color([ h, s, b ], "hsb");
}, $HEX = function(hex) {
    return new Color(hex, "hex");
};

Array.implement({
    rgbToHsb: function() {
        var red = this[0], green = this[1], blue = this[2], hue = 0, max = Math.max(red, green, blue), min = Math.min(red, green, blue), delta = max - min, brightness = max / 255, saturation = 0 != max ? delta / max : 0;
        if (0 != saturation) {
            var rr = (max - red) / delta, gr = (max - green) / delta, br = (max - blue) / delta;
            hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr, hue /= 6, 
            0 > hue && hue++;
        }
        return [ Math.round(360 * hue), Math.round(100 * saturation), Math.round(100 * brightness) ];
    },
    hsbToRgb: function() {
        var br = Math.round(255 * (this[2] / 100));
        if (0 == this[1]) return [ br, br, br ];
        var hue = this[0] % 360, f = hue % 60, p = Math.round(255 * (this[2] * (100 - this[1]) / 1e4)), q = Math.round(255 * (this[2] * (6e3 - this[1] * f) / 6e5)), t = Math.round(255 * (this[2] * (6e3 - this[1] * (60 - f)) / 6e5));
        switch (Math.floor(hue / 60)) {
          case 0:
            return [ br, t, p ];

          case 1:
            return [ q, br, p ];

          case 2:
            return [ p, br, t ];

          case 3:
            return [ p, q, br ];

          case 4:
            return [ t, p, br ];

          case 5:
            return [ br, p, q ];
        }
        return !1;
    }
}), String.implement({
    rgbToHsb: function() {
        var rgb = this.match(/\d{1,3}/g);
        return rgb ? rgb.rgbToHsb() : null;
    },
    hsbToRgb: function() {
        var hsb = this.match(/\d{1,3}/g);
        return hsb ? hsb.hsbToRgb() : null;
    }
}), Request.JSON = new Class({
    Extends: Request,
    options: {
        secure: !0
    },
    initialize: function(options) {
        this.parent(options), this.headers.extend({
            Accept: "application/json",
            "X-Request": "JSON"
        });
    },
    success: function(text) {
        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);
    }
}), MooTools.More = {
    version: "1.2.5.1",
    build: "254884f2b83651bf95260eed5c6cceb838e22d8e"
}, Class.Mutators.Binds = function(binds) {
    return binds;
}, Class.Mutators.initialize = function(initialize) {
    return function() {
        return $splat(this.Binds).each(function(name) {
            var original = this[name];
            original && (this[name] = original.bind(this));
        }, this), initialize.apply(this, arguments);
    };
}, Fx.Elements = new Class({
    Extends: Fx.CSS,
    initialize: function(elements, options) {
        this.elements = this.subject = $$(elements), this.parent(options);
    },
    compute: function(from, to, delta) {
        var now = {};
        for (var i in from) {
            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};
            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);
        }
        return now;
    },
    set: function(now) {
        for (var i in now) if (this.elements[i]) {
            var iNow = now[i];
            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);
        }
        return this;
    },
    start: function(obj) {
        if (!this.check(obj)) return this;
        var from = {}, to = {};
        for (var i in obj) if (this.elements[i]) {
            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};
            for (var p in iProps) {
                var parsed = this.prepare(this.elements[i], p, iProps[p]);
                iFrom[p] = parsed.from, iTo[p] = parsed.to;
            }
        }
        return this.parent(from, to);
    }
}), Fx.Slide = new Class({
    Extends: Fx,
    options: {
        mode: "vertical",
        wrapper: !1,
        hideOverflow: !0,
        resetHeight: !1
    },
    initialize: function(element, options) {
        this.addEvent("complete", function() {
            this.open = 0 != this.wrapper["offset" + this.layout.capitalize()], this.open && this.options.resetHeight && this.wrapper.setStyle("height", ""), 
            this.open && Browser.Engine.webkit419 && this.element.dispose().inject(this.wrapper);
        }, !0), this.element = this.subject = document.id(element), this.parent(options);
        var wrapper = this.element.retrieve("wrapper"), styles = this.element.getStyles("margin", "position", "overflow");
        this.options.hideOverflow && (styles = $extend(styles, {
            overflow: "hidden"
        })), this.options.wrapper && (wrapper = document.id(this.options.wrapper).setStyles(styles)), 
        this.wrapper = wrapper || new Element("div", {
            styles: styles
        }).wraps(this.element), this.element.store("wrapper", this.wrapper).setStyle("margin", 0), 
        this.now = [], this.open = !0;
    },
    vertical: function() {
        this.margin = "margin-top", this.layout = "height", this.offset = this.element.offsetHeight;
    },
    horizontal: function() {
        this.margin = "margin-left", this.layout = "width", this.offset = this.element.offsetWidth;
    },
    set: function(now) {
        return this.element.setStyle(this.margin, now[0]), this.wrapper.setStyle(this.layout, now[1]), 
        this;
    },
    compute: function(from, to, delta) {
        return [ 0, 1 ].map(function(i) {
            return Fx.compute(from[i], to[i], delta);
        });
    },
    start: function(how, mode) {
        if (!this.check(how, mode)) return this;
        this[mode || this.options.mode]();
        var start, margin = this.element.getStyle(this.margin).toInt(), layout = this.wrapper.getStyle(this.layout).toInt(), caseIn = [ [ margin, layout ], [ 0, this.offset ] ], caseOut = [ [ margin, layout ], [ -this.offset, 0 ] ];
        switch (how) {
          case "in":
            start = caseIn;
            break;

          case "out":
            start = caseOut;
            break;

          case "toggle":
            start = 0 == layout ? caseIn : caseOut;
        }
        return this.parent(start[0], start[1]);
    },
    slideIn: function(mode) {
        return this.start("in", mode);
    },
    slideOut: function(mode) {
        return this.start("out", mode);
    },
    hide: function(mode) {
        return this[mode || this.options.mode](), this.open = !1, this.set([ -this.offset, 0 ]);
    },
    show: function(mode) {
        return this[mode || this.options.mode](), this.open = !0, this.set([ 0, this.offset ]);
    },
    toggle: function(mode) {
        return this.start("toggle", mode);
    }
}), Element.Properties.slide = {
    set: function(options) {
        var slide = this.retrieve("slide");
        return slide && slide.cancel(), this.eliminate("slide").store("slide:options", $extend({
            link: "cancel"
        }, options));
    },
    get: function(options) {
        return (options || !this.retrieve("slide")) && ((options || !this.retrieve("slide:options")) && this.set("slide", options), 
        this.store("slide", new Fx.Slide(this, this.retrieve("slide:options")))), this.retrieve("slide");
    }
}, Element.implement({
    slide: function(how, mode) {
        how = how || "toggle";
        var toggle, slide = this.get("slide");
        switch (how) {
          case "hide":
            slide.hide(mode);
            break;

          case "show":
            slide.show(mode);
            break;

          case "toggle":
            var flag = this.retrieve("slide:flag", slide.open);
            slide[flag ? "slideOut" : "slideIn"](mode), this.store("slide:flag", !flag), toggle = !0;
            break;

          default:
            slide.start(how, mode);
        }
        return toggle || this.eliminate("slide:flag"), this;
    }
}), Hash.Cookie = new Class({
    Extends: Cookie,
    options: {
        autoSave: !0
    },
    initialize: function(name, options) {
        this.parent(name, options), this.load();
    },
    save: function() {
        var value = JSON.encode(this.hash);
        return !value || value.length > 4096 ? !1 : ("{}" == value ? this.dispose() : this.write(value), 
        !0);
    },
    load: function() {
        return this.hash = new Hash(JSON.decode(this.read(), !0)), this;
    }
}), Hash.each(Hash.prototype, function(method, name) {
    "function" == typeof method && Hash.Cookie.implement(name, function() {
        var value = method.apply(this.hash, arguments);
        return this.options.autoSave && this.save(), value;
    });
}), function() {
    var read = function(option, element) {
        return option ? "function" == $type(option) ? option(element) : element.get(option) : "";
    };
    this.Tips = new Class({
        Implements: [ Events, Options ],
        options: {
            onShow: function() {
                this.tip.setStyle("display", "block");
            },
            onHide: function() {
                this.tip.setStyle("display", "none");
            },
            title: "title",
            text: function(element) {
                return element.get("rel") || element.get("href");
            },
            showDelay: 100,
            hideDelay: 100,
            className: "tip-wrap",
            offset: {
                x: 16,
                y: 16
            },
            windowPadding: {
                x: 0,
                y: 0
            },
            fixed: !1
        },
        initialize: function() {
            var params = Array.link(arguments, {
                options: Object.type,
                elements: $defined
            });
            this.setOptions(params.options), params.elements && this.attach(params.elements), 
            this.container = new Element("div", {
                "class": "tip"
            });
        },
        toElement: function() {
            return this.tip ? this.tip : this.tip = new Element("div", {
                "class": this.options.className,
                styles: {
                    position: "absolute",
                    top: 0,
                    left: 0
                }
            }).adopt(new Element("div", {
                "class": "tip-top"
            }), this.container, new Element("div", {
                "class": "tip-bottom"
            }));
        },
        attach: function(elements) {
            return $$(elements).each(function(element) {
                var title = read(this.options.title, element), text = read(this.options.text, element);
                element.erase("title").store("tip:native", title).retrieve("tip:title", title), 
                element.retrieve("tip:text", text), this.fireEvent("attach", [ element ]);
                var events = [ "enter", "leave" ];
                this.options.fixed || events.push("move"), events.each(function(value) {
                    var event = element.retrieve("tip:" + value);
                    event || (event = this["element" + value.capitalize()].bindWithEvent(this, element)), 
                    element.store("tip:" + value, event).addEvent("mouse" + value, event);
                }, this);
            }, this), this;
        },
        detach: function(elements) {
            return $$(elements).each(function(element) {
                if ([ "enter", "leave", "move" ].each(function(value) {
                    element.removeEvent("mouse" + value, element.retrieve("tip:" + value)).eliminate("tip:" + value);
                }), this.fireEvent("detach", [ element ]), "title" == this.options.title) {
                    var original = element.retrieve("tip:native");
                    original && element.set("title", original);
                }
            }, this), this;
        },
        elementEnter: function(event, element) {
            this.container.empty(), [ "title", "text" ].each(function(value) {
                var content = element.retrieve("tip:" + value);
                content && this.fill(new Element("div", {
                    "class": "tip-" + value
                }).inject(this.container), content);
            }, this), $clear(this.timer), this.timer = function() {
                this.show(element), this.position(this.options.fixed ? {
                    page: element.getPosition()
                } : event);
            }.delay(this.options.showDelay, this);
        },
        elementLeave: function(event, element) {
            $clear(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, element), 
            this.fireForParent(event, element);
        },
        fireForParent: function(event, element) {
            element = element.getParent(), element && element != document.body && (element.retrieve("tip:enter") ? element.fireEvent("mouseenter", event) : this.fireForParent(event, element));
        },
        elementMove: function(event) {
            this.position(event);
        },
        position: function(event) {
            this.tip || document.id(this);
            var size = window.getSize(), scroll = window.getScroll(), tip = {
                x: this.tip.offsetWidth,
                y: this.tip.offsetHeight
            }, props = {
                x: "left",
                y: "top"
            }, obj = {};
            for (var z in props) obj[props[z]] = event.page[z] + this.options.offset[z], obj[props[z]] + tip[z] - scroll[z] > size[z] - this.options.windowPadding[z] && (obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z]);
            this.tip.setStyles(obj);
        },
        fill: function(element, contents) {
            "string" == typeof contents ? element.set("html", contents) : element.adopt(contents);
        },
        show: function(element) {
            this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), 
            this.fireEvent("show", [ this.tip, element ]);
        },
        hide: function(element) {
            this.tip || document.id(this), this.fireEvent("hide", [ this.tip, element ]);
        }
    });
}(), this.Handlebars = {}, function(Handlebars) {
    Handlebars.VERSION = "1.0.0-rc.3", Handlebars.COMPILER_REVISION = 2, Handlebars.REVISION_CHANGES = {
        1: "<= 1.0.rc.2",
        2: ">= 1.0.0-rc.3"
    }, Handlebars.helpers = {}, Handlebars.partials = {}, Handlebars.registerHelper = function(name, fn, inverse) {
        inverse && (fn.not = inverse), this.helpers[name] = fn;
    }, Handlebars.registerPartial = function(name, str) {
        this.partials[name] = str;
    }, Handlebars.registerHelper("helperMissing", function(arg) {
        if (2 === arguments.length) return void 0;
        throw Error("Could not find property '" + arg + "'");
    });
    var toString = Object.prototype.toString, functionType = "[object Function]";
    Handlebars.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse || function() {}, fn = options.fn, type = toString.call(context);
        return type === functionType && (context = context.call(this)), context === !0 ? fn(this) : context === !1 || null == context ? inverse(this) : "[object Array]" === type ? context.length > 0 ? Handlebars.helpers.each(context, options) : inverse(this) : fn(context);
    }), Handlebars.K = function() {}, Handlebars.createFrame = Object.create || function(object) {
        Handlebars.K.prototype = object;
        var obj = new Handlebars.K();
        return Handlebars.K.prototype = null, obj;
    }, Handlebars.logger = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        level: 3,
        methodMap: {
            0: "debug",
            1: "info",
            2: "warn",
            3: "error"
        },
        log: function(level, obj) {
            if (level >= Handlebars.logger.level) {
                var method = Handlebars.logger.methodMap[level];
                "undefined" != typeof console && console[method] && console[method].call(console, obj);
            }
        }
    }, Handlebars.log = function(level, obj) {
        Handlebars.logger.log(level, obj);
    }, Handlebars.registerHelper("each", function(context, options) {
        var data, fn = options.fn, inverse = options.inverse, i = 0, ret = "";
        if (options.data && (data = Handlebars.createFrame(options.data)), context && "object" == typeof context) if (context instanceof Array) for (var j = context.length; j > i; i++) data && (data.index = i), 
        ret += fn(context[i], {
            data: data
        }); else for (var key in context) context.hasOwnProperty(key) && (data && (data.key = key), 
        ret += fn(context[key], {
            data: data
        }), i++);
        return 0 === i && (ret = inverse(this)), ret;
    }), Handlebars.registerHelper("if", function(context, options) {
        var type = toString.call(context);
        return type === functionType && (context = context.call(this)), !context || Handlebars.Utils.isEmpty(context) ? options.inverse(this) : options.fn(this);
    }), Handlebars.registerHelper("unless", function(context, options) {
        var fn = options.fn, inverse = options.inverse;
        return options.fn = inverse, options.inverse = fn, Handlebars.helpers["if"].call(this, context, options);
    }), Handlebars.registerHelper("with", function(context, options) {
        return options.fn(context);
    }), Handlebars.registerHelper("log", function(context, options) {
        var level = options.data && null != options.data.level ? parseInt(options.data.level, 10) : 1;
        Handlebars.log(level, context);
    });
}(this.Handlebars);

var handlebars = function() {
    function Parser() {
        this.yy = {};
    }
    var parser = {
        trace: function() {},
        yy: {},
        symbols_: {
            error: 2,
            root: 3,
            program: 4,
            EOF: 5,
            simpleInverse: 6,
            statements: 7,
            statement: 8,
            openInverse: 9,
            closeBlock: 10,
            openBlock: 11,
            mustache: 12,
            partial: 13,
            CONTENT: 14,
            COMMENT: 15,
            OPEN_BLOCK: 16,
            inMustache: 17,
            CLOSE: 18,
            OPEN_INVERSE: 19,
            OPEN_ENDBLOCK: 20,
            path: 21,
            OPEN: 22,
            OPEN_UNESCAPED: 23,
            OPEN_PARTIAL: 24,
            partialName: 25,
            params: 26,
            hash: 27,
            DATA: 28,
            param: 29,
            STRING: 30,
            INTEGER: 31,
            BOOLEAN: 32,
            hashSegments: 33,
            hashSegment: 34,
            ID: 35,
            EQUALS: 36,
            PARTIAL_NAME: 37,
            pathSegments: 38,
            SEP: 39,
            $accept: 0,
            $end: 1
        },
        terminals_: {
            2: "error",
            5: "EOF",
            14: "CONTENT",
            15: "COMMENT",
            16: "OPEN_BLOCK",
            18: "CLOSE",
            19: "OPEN_INVERSE",
            20: "OPEN_ENDBLOCK",
            22: "OPEN",
            23: "OPEN_UNESCAPED",
            24: "OPEN_PARTIAL",
            28: "DATA",
            30: "STRING",
            31: "INTEGER",
            32: "BOOLEAN",
            35: "ID",
            36: "EQUALS",
            37: "PARTIAL_NAME",
            39: "SEP"
        },
        productions_: [ 0, [ 3, 2 ], [ 4, 2 ], [ 4, 3 ], [ 4, 2 ], [ 4, 1 ], [ 4, 1 ], [ 4, 0 ], [ 7, 1 ], [ 7, 2 ], [ 8, 3 ], [ 8, 3 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 11, 3 ], [ 9, 3 ], [ 10, 3 ], [ 12, 3 ], [ 12, 3 ], [ 13, 3 ], [ 13, 4 ], [ 6, 2 ], [ 17, 3 ], [ 17, 2 ], [ 17, 2 ], [ 17, 1 ], [ 17, 1 ], [ 26, 2 ], [ 26, 1 ], [ 29, 1 ], [ 29, 1 ], [ 29, 1 ], [ 29, 1 ], [ 29, 1 ], [ 27, 1 ], [ 33, 2 ], [ 33, 1 ], [ 34, 3 ], [ 34, 3 ], [ 34, 3 ], [ 34, 3 ], [ 34, 3 ], [ 25, 1 ], [ 21, 1 ], [ 38, 3 ], [ 38, 1 ] ],
        performAction: function(yytext, yyleng, yylineno, yy, yystate, $$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];

              case 2:
                this.$ = new yy.ProgramNode([], $$[$0]);
                break;

              case 3:
                this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0]);
                break;

              case 4:
                this.$ = new yy.ProgramNode($$[$0 - 1], []);
                break;

              case 5:
                this.$ = new yy.ProgramNode($$[$0]);
                break;

              case 6:
                this.$ = new yy.ProgramNode([], []);
                break;

              case 7:
                this.$ = new yy.ProgramNode([]);
                break;

              case 8:
                this.$ = [ $$[$0] ];
                break;

              case 9:
                $$[$0 - 1].push($$[$0]), this.$ = $$[$0 - 1];
                break;

              case 10:
                this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1].inverse, $$[$0 - 1], $$[$0]);
                break;

              case 11:
                this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0 - 1].inverse, $$[$0]);
                break;

              case 12:
                this.$ = $$[$0];
                break;

              case 13:
                this.$ = $$[$0];
                break;

              case 14:
                this.$ = new yy.ContentNode($$[$0]);
                break;

              case 15:
                this.$ = new yy.CommentNode($$[$0]);
                break;

              case 16:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);
                break;

              case 17:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);
                break;

              case 18:
                this.$ = $$[$0 - 1];
                break;

              case 19:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);
                break;

              case 20:
                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1], !0);
                break;

              case 21:
                this.$ = new yy.PartialNode($$[$0 - 1]);
                break;

              case 22:
                this.$ = new yy.PartialNode($$[$0 - 2], $$[$0 - 1]);
                break;

              case 23:
                break;

              case 24:
                this.$ = [ [ $$[$0 - 2] ].concat($$[$0 - 1]), $$[$0] ];
                break;

              case 25:
                this.$ = [ [ $$[$0 - 1] ].concat($$[$0]), null ];
                break;

              case 26:
                this.$ = [ [ $$[$0 - 1] ], $$[$0] ];
                break;

              case 27:
                this.$ = [ [ $$[$0] ], null ];
                break;

              case 28:
                this.$ = [ [ new yy.DataNode($$[$0]) ], null ];
                break;

              case 29:
                $$[$0 - 1].push($$[$0]), this.$ = $$[$0 - 1];
                break;

              case 30:
                this.$ = [ $$[$0] ];
                break;

              case 31:
                this.$ = $$[$0];
                break;

              case 32:
                this.$ = new yy.StringNode($$[$0]);
                break;

              case 33:
                this.$ = new yy.IntegerNode($$[$0]);
                break;

              case 34:
                this.$ = new yy.BooleanNode($$[$0]);
                break;

              case 35:
                this.$ = new yy.DataNode($$[$0]);
                break;

              case 36:
                this.$ = new yy.HashNode($$[$0]);
                break;

              case 37:
                $$[$0 - 1].push($$[$0]), this.$ = $$[$0 - 1];
                break;

              case 38:
                this.$ = [ $$[$0] ];
                break;

              case 39:
                this.$ = [ $$[$0 - 2], $$[$0] ];
                break;

              case 40:
                this.$ = [ $$[$0 - 2], new yy.StringNode($$[$0]) ];
                break;

              case 41:
                this.$ = [ $$[$0 - 2], new yy.IntegerNode($$[$0]) ];
                break;

              case 42:
                this.$ = [ $$[$0 - 2], new yy.BooleanNode($$[$0]) ];
                break;

              case 43:
                this.$ = [ $$[$0 - 2], new yy.DataNode($$[$0]) ];
                break;

              case 44:
                this.$ = new yy.PartialNameNode($$[$0]);
                break;

              case 45:
                this.$ = new yy.IdNode($$[$0]);
                break;

              case 46:
                $$[$0 - 2].push($$[$0]), this.$ = $$[$0 - 2];
                break;

              case 47:
                this.$ = [ $$[$0] ];
            }
        },
        table: [ {
            3: 1,
            4: 2,
            5: [ 2, 7 ],
            6: 3,
            7: 4,
            8: 6,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 5 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            1: [ 3 ]
        }, {
            5: [ 1, 17 ]
        }, {
            5: [ 2, 6 ],
            7: 18,
            8: 6,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 19 ],
            20: [ 2, 6 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            5: [ 2, 5 ],
            6: 20,
            8: 21,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 5 ],
            20: [ 2, 5 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            17: 23,
            18: [ 1, 22 ],
            21: 24,
            28: [ 1, 25 ],
            35: [ 1, 27 ],
            38: 26
        }, {
            5: [ 2, 8 ],
            14: [ 2, 8 ],
            15: [ 2, 8 ],
            16: [ 2, 8 ],
            19: [ 2, 8 ],
            20: [ 2, 8 ],
            22: [ 2, 8 ],
            23: [ 2, 8 ],
            24: [ 2, 8 ]
        }, {
            4: 28,
            6: 3,
            7: 4,
            8: 6,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 5 ],
            20: [ 2, 7 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            4: 29,
            6: 3,
            7: 4,
            8: 6,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 5 ],
            20: [ 2, 7 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            5: [ 2, 12 ],
            14: [ 2, 12 ],
            15: [ 2, 12 ],
            16: [ 2, 12 ],
            19: [ 2, 12 ],
            20: [ 2, 12 ],
            22: [ 2, 12 ],
            23: [ 2, 12 ],
            24: [ 2, 12 ]
        }, {
            5: [ 2, 13 ],
            14: [ 2, 13 ],
            15: [ 2, 13 ],
            16: [ 2, 13 ],
            19: [ 2, 13 ],
            20: [ 2, 13 ],
            22: [ 2, 13 ],
            23: [ 2, 13 ],
            24: [ 2, 13 ]
        }, {
            5: [ 2, 14 ],
            14: [ 2, 14 ],
            15: [ 2, 14 ],
            16: [ 2, 14 ],
            19: [ 2, 14 ],
            20: [ 2, 14 ],
            22: [ 2, 14 ],
            23: [ 2, 14 ],
            24: [ 2, 14 ]
        }, {
            5: [ 2, 15 ],
            14: [ 2, 15 ],
            15: [ 2, 15 ],
            16: [ 2, 15 ],
            19: [ 2, 15 ],
            20: [ 2, 15 ],
            22: [ 2, 15 ],
            23: [ 2, 15 ],
            24: [ 2, 15 ]
        }, {
            17: 30,
            21: 24,
            28: [ 1, 25 ],
            35: [ 1, 27 ],
            38: 26
        }, {
            17: 31,
            21: 24,
            28: [ 1, 25 ],
            35: [ 1, 27 ],
            38: 26
        }, {
            17: 32,
            21: 24,
            28: [ 1, 25 ],
            35: [ 1, 27 ],
            38: 26
        }, {
            25: 33,
            37: [ 1, 34 ]
        }, {
            1: [ 2, 1 ]
        }, {
            5: [ 2, 2 ],
            8: 21,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 19 ],
            20: [ 2, 2 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            17: 23,
            21: 24,
            28: [ 1, 25 ],
            35: [ 1, 27 ],
            38: 26
        }, {
            5: [ 2, 4 ],
            7: 35,
            8: 6,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 19 ],
            20: [ 2, 4 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            5: [ 2, 9 ],
            14: [ 2, 9 ],
            15: [ 2, 9 ],
            16: [ 2, 9 ],
            19: [ 2, 9 ],
            20: [ 2, 9 ],
            22: [ 2, 9 ],
            23: [ 2, 9 ],
            24: [ 2, 9 ]
        }, {
            5: [ 2, 23 ],
            14: [ 2, 23 ],
            15: [ 2, 23 ],
            16: [ 2, 23 ],
            19: [ 2, 23 ],
            20: [ 2, 23 ],
            22: [ 2, 23 ],
            23: [ 2, 23 ],
            24: [ 2, 23 ]
        }, {
            18: [ 1, 36 ]
        }, {
            18: [ 2, 27 ],
            21: 41,
            26: 37,
            27: 38,
            28: [ 1, 45 ],
            29: 39,
            30: [ 1, 42 ],
            31: [ 1, 43 ],
            32: [ 1, 44 ],
            33: 40,
            34: 46,
            35: [ 1, 47 ],
            38: 26
        }, {
            18: [ 2, 28 ]
        }, {
            18: [ 2, 45 ],
            28: [ 2, 45 ],
            30: [ 2, 45 ],
            31: [ 2, 45 ],
            32: [ 2, 45 ],
            35: [ 2, 45 ],
            39: [ 1, 48 ]
        }, {
            18: [ 2, 47 ],
            28: [ 2, 47 ],
            30: [ 2, 47 ],
            31: [ 2, 47 ],
            32: [ 2, 47 ],
            35: [ 2, 47 ],
            39: [ 2, 47 ]
        }, {
            10: 49,
            20: [ 1, 50 ]
        }, {
            10: 51,
            20: [ 1, 50 ]
        }, {
            18: [ 1, 52 ]
        }, {
            18: [ 1, 53 ]
        }, {
            18: [ 1, 54 ]
        }, {
            18: [ 1, 55 ],
            21: 56,
            35: [ 1, 27 ],
            38: 26
        }, {
            18: [ 2, 44 ],
            35: [ 2, 44 ]
        }, {
            5: [ 2, 3 ],
            8: 21,
            9: 7,
            11: 8,
            12: 9,
            13: 10,
            14: [ 1, 11 ],
            15: [ 1, 12 ],
            16: [ 1, 13 ],
            19: [ 1, 19 ],
            20: [ 2, 3 ],
            22: [ 1, 14 ],
            23: [ 1, 15 ],
            24: [ 1, 16 ]
        }, {
            14: [ 2, 17 ],
            15: [ 2, 17 ],
            16: [ 2, 17 ],
            19: [ 2, 17 ],
            20: [ 2, 17 ],
            22: [ 2, 17 ],
            23: [ 2, 17 ],
            24: [ 2, 17 ]
        }, {
            18: [ 2, 25 ],
            21: 41,
            27: 57,
            28: [ 1, 45 ],
            29: 58,
            30: [ 1, 42 ],
            31: [ 1, 43 ],
            32: [ 1, 44 ],
            33: 40,
            34: 46,
            35: [ 1, 47 ],
            38: 26
        }, {
            18: [ 2, 26 ]
        }, {
            18: [ 2, 30 ],
            28: [ 2, 30 ],
            30: [ 2, 30 ],
            31: [ 2, 30 ],
            32: [ 2, 30 ],
            35: [ 2, 30 ]
        }, {
            18: [ 2, 36 ],
            34: 59,
            35: [ 1, 60 ]
        }, {
            18: [ 2, 31 ],
            28: [ 2, 31 ],
            30: [ 2, 31 ],
            31: [ 2, 31 ],
            32: [ 2, 31 ],
            35: [ 2, 31 ]
        }, {
            18: [ 2, 32 ],
            28: [ 2, 32 ],
            30: [ 2, 32 ],
            31: [ 2, 32 ],
            32: [ 2, 32 ],
            35: [ 2, 32 ]
        }, {
            18: [ 2, 33 ],
            28: [ 2, 33 ],
            30: [ 2, 33 ],
            31: [ 2, 33 ],
            32: [ 2, 33 ],
            35: [ 2, 33 ]
        }, {
            18: [ 2, 34 ],
            28: [ 2, 34 ],
            30: [ 2, 34 ],
            31: [ 2, 34 ],
            32: [ 2, 34 ],
            35: [ 2, 34 ]
        }, {
            18: [ 2, 35 ],
            28: [ 2, 35 ],
            30: [ 2, 35 ],
            31: [ 2, 35 ],
            32: [ 2, 35 ],
            35: [ 2, 35 ]
        }, {
            18: [ 2, 38 ],
            35: [ 2, 38 ]
        }, {
            18: [ 2, 47 ],
            28: [ 2, 47 ],
            30: [ 2, 47 ],
            31: [ 2, 47 ],
            32: [ 2, 47 ],
            35: [ 2, 47 ],
            36: [ 1, 61 ],
            39: [ 2, 47 ]
        }, {
            35: [ 1, 62 ]
        }, {
            5: [ 2, 10 ],
            14: [ 2, 10 ],
            15: [ 2, 10 ],
            16: [ 2, 10 ],
            19: [ 2, 10 ],
            20: [ 2, 10 ],
            22: [ 2, 10 ],
            23: [ 2, 10 ],
            24: [ 2, 10 ]
        }, {
            21: 63,
            35: [ 1, 27 ],
            38: 26
        }, {
            5: [ 2, 11 ],
            14: [ 2, 11 ],
            15: [ 2, 11 ],
            16: [ 2, 11 ],
            19: [ 2, 11 ],
            20: [ 2, 11 ],
            22: [ 2, 11 ],
            23: [ 2, 11 ],
            24: [ 2, 11 ]
        }, {
            14: [ 2, 16 ],
            15: [ 2, 16 ],
            16: [ 2, 16 ],
            19: [ 2, 16 ],
            20: [ 2, 16 ],
            22: [ 2, 16 ],
            23: [ 2, 16 ],
            24: [ 2, 16 ]
        }, {
            5: [ 2, 19 ],
            14: [ 2, 19 ],
            15: [ 2, 19 ],
            16: [ 2, 19 ],
            19: [ 2, 19 ],
            20: [ 2, 19 ],
            22: [ 2, 19 ],
            23: [ 2, 19 ],
            24: [ 2, 19 ]
        }, {
            5: [ 2, 20 ],
            14: [ 2, 20 ],
            15: [ 2, 20 ],
            16: [ 2, 20 ],
            19: [ 2, 20 ],
            20: [ 2, 20 ],
            22: [ 2, 20 ],
            23: [ 2, 20 ],
            24: [ 2, 20 ]
        }, {
            5: [ 2, 21 ],
            14: [ 2, 21 ],
            15: [ 2, 21 ],
            16: [ 2, 21 ],
            19: [ 2, 21 ],
            20: [ 2, 21 ],
            22: [ 2, 21 ],
            23: [ 2, 21 ],
            24: [ 2, 21 ]
        }, {
            18: [ 1, 64 ]
        }, {
            18: [ 2, 24 ]
        }, {
            18: [ 2, 29 ],
            28: [ 2, 29 ],
            30: [ 2, 29 ],
            31: [ 2, 29 ],
            32: [ 2, 29 ],
            35: [ 2, 29 ]
        }, {
            18: [ 2, 37 ],
            35: [ 2, 37 ]
        }, {
            36: [ 1, 61 ]
        }, {
            21: 65,
            28: [ 1, 69 ],
            30: [ 1, 66 ],
            31: [ 1, 67 ],
            32: [ 1, 68 ],
            35: [ 1, 27 ],
            38: 26
        }, {
            18: [ 2, 46 ],
            28: [ 2, 46 ],
            30: [ 2, 46 ],
            31: [ 2, 46 ],
            32: [ 2, 46 ],
            35: [ 2, 46 ],
            39: [ 2, 46 ]
        }, {
            18: [ 1, 70 ]
        }, {
            5: [ 2, 22 ],
            14: [ 2, 22 ],
            15: [ 2, 22 ],
            16: [ 2, 22 ],
            19: [ 2, 22 ],
            20: [ 2, 22 ],
            22: [ 2, 22 ],
            23: [ 2, 22 ],
            24: [ 2, 22 ]
        }, {
            18: [ 2, 39 ],
            35: [ 2, 39 ]
        }, {
            18: [ 2, 40 ],
            35: [ 2, 40 ]
        }, {
            18: [ 2, 41 ],
            35: [ 2, 41 ]
        }, {
            18: [ 2, 42 ],
            35: [ 2, 42 ]
        }, {
            18: [ 2, 43 ],
            35: [ 2, 43 ]
        }, {
            5: [ 2, 18 ],
            14: [ 2, 18 ],
            15: [ 2, 18 ],
            16: [ 2, 18 ],
            19: [ 2, 18 ],
            20: [ 2, 18 ],
            22: [ 2, 18 ],
            23: [ 2, 18 ],
            24: [ 2, 18 ]
        } ],
        defaultActions: {
            17: [ 2, 1 ],
            25: [ 2, 28 ],
            38: [ 2, 26 ],
            57: [ 2, 24 ]
        },
        parseError: function(str) {
            throw Error(str);
        },
        parse: function(input) {
            function lex() {
                var token;
                return token = self.lexer.lex() || 1, "number" != typeof token && (token = self.symbols_[token] || token), 
                token;
            }
            var self = this, stack = [ 0 ], vstack = [ null ], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0;
            this.lexer.setInput(input), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, 
            this.yy.parser = this, this.lexer.yylloc === void 0 && (this.lexer.yylloc = {});
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            "function" == typeof this.yy.parseError && (this.parseError = this.yy.parseError);
            for (var symbol, preErrorSymbol, state, action, r, p, len, newState, expected, yyval = {}; ;) {
                if (state = stack[stack.length - 1], this.defaultActions[state] ? action = this.defaultActions[state] : ((null === symbol || symbol === void 0) && (symbol = lex()), 
                action = table[state] && table[state][symbol]), action === void 0 || !action.length || !action[0]) {
                    var errStr = "";
                    if (!recovering) {
                        expected = [];
                        for (p in table[state]) this.terminals_[p] && p > 2 && expected.push("'" + this.terminals_[p] + "'");
                        errStr = this.lexer.showPosition ? "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'" : "Parse error on line " + (yylineno + 1) + ": Unexpected " + (1 == symbol ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'"), 
                        this.parseError(errStr, {
                            text: this.lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: this.lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                }
                if (action[0] instanceof Array && action.length > 1) throw Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                switch (action[0]) {
                  case 1:
                    stack.push(symbol), vstack.push(this.lexer.yytext), lstack.push(this.lexer.yylloc), 
                    stack.push(action[1]), symbol = null, preErrorSymbol ? (symbol = preErrorSymbol, 
                    preErrorSymbol = null) : (yyleng = this.lexer.yyleng, yytext = this.lexer.yytext, 
                    yylineno = this.lexer.yylineno, yyloc = this.lexer.yylloc, recovering > 0 && recovering--);
                    break;

                  case 2:
                    if (len = this.productions_[action[1]][1], yyval.$ = vstack[vstack.length - len], 
                    yyval._$ = {
                        first_line: lstack[lstack.length - (len || 1)].first_line,
                        last_line: lstack[lstack.length - 1].last_line,
                        first_column: lstack[lstack.length - (len || 1)].first_column,
                        last_column: lstack[lstack.length - 1].last_column
                    }, ranges && (yyval._$.range = [ lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1] ]), 
                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack), 
                    r !== void 0) return r;
                    len && (stack = stack.slice(0, 2 * -1 * len), vstack = vstack.slice(0, -1 * len), 
                    lstack = lstack.slice(0, -1 * len)), stack.push(this.productions_[action[1]][0]), 
                    vstack.push(yyval.$), lstack.push(yyval._$), newState = table[stack[stack.length - 2]][stack[stack.length - 1]], 
                    stack.push(newState);
                    break;

                  case 3:
                    return !0;
                }
            }
            return !0;
        }
    }, lexer = function() {
        var lexer = {
            EOF: 1,
            parseError: function(str, hash) {
                if (!this.yy.parser) throw Error(str);
                this.yy.parser.parseError(str, hash);
            },
            setInput: function(input) {
                return this._input = input, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, 
                this.yytext = this.matched = this.match = "", this.conditionStack = [ "INITIAL" ], 
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                }, this.options.ranges && (this.yylloc.range = [ 0, 0 ]), this.offset = 0, this;
            },
            input: function() {
                var ch = this._input[0];
                this.yytext += ch, this.yyleng++, this.offset++, this.match += ch, this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                return lines ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, 
                this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), 
                ch;
            },
            unput: function(ch) {
                var len = ch.length, lines = ch.split(/(?:\r\n?|\n)/g);
                this._input = ch + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - len - 1), 
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), 
                lines.length - 1 && (this.yylineno -= lines.length - 1);
                var r = this.yylloc.range;
                return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                }, this.options.ranges && (this.yylloc.range = [ r[0], r[0] + this.yyleng - len ]), 
                this;
            },
            more: function() {
                return this._more = !0, this;
            },
            less: function(n) {
                this.unput(this.match.slice(n));
            },
            pastInput: function() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function() {
                var next = this.match;
                return 20 > next.length && (next += this._input.substr(0, 20 - next.length)), (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function() {
                var pre = this.pastInput(), c = Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function() {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var token, match, tempMatch, index, lines;
                this._more || (this.yytext = "", this.match = "");
                for (var rules = this._currentRules(), i = 0; rules.length > i && (tempMatch = this._input.match(this.rules[rules[i]]), 
                !tempMatch || match && !(tempMatch[0].length > match[0].length) || (match = tempMatch, 
                index = i, this.options.flex)); i++) ;
                return match ? (lines = match[0].match(/(?:\r\n?|\n).*/g), lines && (this.yylineno += lines.length), 
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                }, this.yytext += match[0], this.match += match[0], this.matches = match, this.yyleng = this.yytext.length, 
                this.options.ranges && (this.yylloc.range = [ this.offset, this.offset += this.yyleng ]), 
                this._more = !1, this._input = this._input.slice(match[0].length), this.matched += match[0], 
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]), 
                this.done && this._input && (this.done = !1), token ? token : void 0) : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });
            },
            lex: function() {
                var r = this.next();
                return r !== void 0 ? r : this.lex();
            },
            begin: function(condition) {
                this.conditionStack.push(condition);
            },
            popState: function() {
                return this.conditionStack.pop();
            },
            _currentRules: function() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function() {
                return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function(condition) {
                this.begin(condition);
            }
        };
        return lexer.options = {}, lexer.performAction = function(yy, yy_, $avoiding_name_collisions, YY_START) {
            switch ($avoiding_name_collisions) {
              case 0:
                if ("\\" !== yy_.yytext.slice(-1) && this.begin("mu"), "\\" === yy_.yytext.slice(-1) && (yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1), 
                this.begin("emu")), yy_.yytext) return 14;
                break;

              case 1:
                return 14;

              case 2:
                return "\\" !== yy_.yytext.slice(-1) && this.popState(), "\\" === yy_.yytext.slice(-1) && (yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1)), 
                14;

              case 3:
                return yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 4), this.popState(), 15;

              case 4:
                return this.begin("par"), 24;

              case 5:
                return 16;

              case 6:
                return 20;

              case 7:
                return 19;

              case 8:
                return 19;

              case 9:
                return 23;

              case 10:
                return 23;

              case 11:
                this.popState(), this.begin("com");
                break;

              case 12:
                return yy_.yytext = yy_.yytext.substr(3, yy_.yyleng - 5), this.popState(), 15;

              case 13:
                return 22;

              case 14:
                return 36;

              case 15:
                return 35;

              case 16:
                return 35;

              case 17:
                return 39;

              case 18:
                break;

              case 19:
                return this.popState(), 18;

              case 20:
                return this.popState(), 18;

              case 21:
                return yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\"/g, '"'), 30;

              case 22:
                return yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\'/g, "'"), 30;

              case 23:
                return yy_.yytext = yy_.yytext.substr(1), 28;

              case 24:
                return 32;

              case 25:
                return 32;

              case 26:
                return 31;

              case 27:
                return 35;

              case 28:
                return yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2), 35;

              case 29:
                return "INVALID";

              case 30:
                break;

              case 31:
                return this.popState(), 37;

              case 32:
                return 5;
            }
        }, lexer.rules = [ /^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|$)))/, /^(?:[\s\S]*?--\}\})/, /^(?:\{\{>)/, /^(?:\{\{#)/, /^(?:\{\{\/)/, /^(?:\{\{\^)/, /^(?:\{\{\s*else\b)/, /^(?:\{\{\{)/, /^(?:\{\{&)/, /^(?:\{\{!--)/, /^(?:\{\{![\s\S]*?\}\})/, /^(?:\{\{)/, /^(?:=)/, /^(?:\.(?=[} ]))/, /^(?:\.\.)/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}\}\})/, /^(?:\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@[a-zA-Z]+)/, /^(?:true(?=[}\s]))/, /^(?:false(?=[}\s]))/, /^(?:[0-9]+(?=[}\s]))/, /^(?:[a-zA-Z0-9_$-]+(?=[=}\s\/.]))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:\s+)/, /^(?:[a-zA-Z0-9_$-/]+)/, /^(?:$)/ ], 
        lexer.conditions = {
            mu: {
                rules: [ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32 ],
                inclusive: !1
            },
            emu: {
                rules: [ 2 ],
                inclusive: !1
            },
            com: {
                rules: [ 3 ],
                inclusive: !1
            },
            par: {
                rules: [ 30, 31 ],
                inclusive: !1
            },
            INITIAL: {
                rules: [ 0, 1, 32 ],
                inclusive: !0
            }
        }, lexer;
    }();
    return parser.lexer = lexer, Parser.prototype = parser, parser.Parser = Parser, 
    new Parser();
}();

Handlebars.Parser = handlebars, Handlebars.parse = function(input) {
    return input.constructor === Handlebars.AST.ProgramNode ? input : (Handlebars.Parser.yy = Handlebars.AST, 
    Handlebars.Parser.parse(input));
}, Handlebars.print = function(ast) {
    return new Handlebars.PrintVisitor().accept(ast);
}, function() {
    Handlebars.AST = {}, Handlebars.AST.ProgramNode = function(statements, inverse) {
        this.type = "program", this.statements = statements, inverse && (this.inverse = new Handlebars.AST.ProgramNode(inverse));
    }, Handlebars.AST.MustacheNode = function(rawParams, hash, unescaped) {
        this.type = "mustache", this.escaped = !unescaped, this.hash = hash;
        var id = this.id = rawParams[0], params = this.params = rawParams.slice(1), eligibleHelper = this.eligibleHelper = id.isSimple;
        this.isHelper = eligibleHelper && (params.length || hash);
    }, Handlebars.AST.PartialNode = function(partialName, context) {
        this.type = "partial", this.partialName = partialName, this.context = context;
    };
    var verifyMatch = function(open, close) {
        if (open.original !== close.original) throw new Handlebars.Exception(open.original + " doesn't match " + close.original);
    };
    Handlebars.AST.BlockNode = function(mustache, program, inverse, close) {
        verifyMatch(mustache.id, close), this.type = "block", this.mustache = mustache, 
        this.program = program, this.inverse = inverse, this.inverse && !this.program && (this.isInverse = !0);
    }, Handlebars.AST.ContentNode = function(string) {
        this.type = "content", this.string = string;
    }, Handlebars.AST.HashNode = function(pairs) {
        this.type = "hash", this.pairs = pairs;
    }, Handlebars.AST.IdNode = function(parts) {
        this.type = "ID", this.original = parts.join(".");
        for (var dig = [], depth = 0, i = 0, l = parts.length; l > i; i++) {
            var part = parts[i];
            if (".." === part || "." === part || "this" === part) {
                if (dig.length > 0) throw new Handlebars.Exception("Invalid path: " + this.original);
                ".." === part ? depth++ : this.isScoped = !0;
            } else dig.push(part);
        }
        this.parts = dig, this.string = dig.join("."), this.depth = depth, this.isSimple = 1 === parts.length && !this.isScoped && 0 === depth, 
        this.stringModeValue = this.string;
    }, Handlebars.AST.PartialNameNode = function(name) {
        this.type = "PARTIAL_NAME", this.name = name;
    }, Handlebars.AST.DataNode = function(id) {
        this.type = "DATA", this.id = id;
    }, Handlebars.AST.StringNode = function(string) {
        this.type = "STRING", this.string = string, this.stringModeValue = string;
    }, Handlebars.AST.IntegerNode = function(integer) {
        this.type = "INTEGER", this.integer = integer, this.stringModeValue = Number(integer);
    }, Handlebars.AST.BooleanNode = function(bool) {
        this.type = "BOOLEAN", this.bool = bool, this.stringModeValue = "true" === bool;
    }, Handlebars.AST.CommentNode = function(comment) {
        this.type = "comment", this.comment = comment;
    };
}();

var errorProps = [ "description", "fileName", "lineNumber", "message", "name", "number", "stack" ];

Handlebars.Exception = function() {
    for (var tmp = Error.prototype.constructor.apply(this, arguments), idx = 0; errorProps.length > idx; idx++) this[errorProps[idx]] = tmp[errorProps[idx]];
}, Handlebars.Exception.prototype = Error(), Handlebars.SafeString = function(string) {
    this.string = string;
}, Handlebars.SafeString.prototype.toString = function() {
    return "" + this.string;
}, function() {
    var escape = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, badChars = /[&<>"'`]/g, possible = /[&<>"'`]/, escapeChar = function(chr) {
        return escape[chr] || "&amp;";
    };
    Handlebars.Utils = {
        escapeExpression: function(string) {
            return string instanceof Handlebars.SafeString ? "" + string : null == string || string === !1 ? "" : possible.test(string) ? string.replace(badChars, escapeChar) : string;
        },
        isEmpty: function(value) {
            return value || 0 === value ? "[object Array]" === Object.prototype.toString.call(value) && 0 === value.length ? !0 : !1 : !0;
        }
    };
}(), Handlebars.Compiler = function() {}, Handlebars.JavaScriptCompiler = function() {}, 
function(Compiler, JavaScriptCompiler) {
    Compiler.prototype = {
        compiler: Compiler,
        disassemble: function() {
            for (var opcode, params, param, opcodes = this.opcodes, out = [], i = 0, l = opcodes.length; l > i; i++) if (opcode = opcodes[i], 
            "DECLARE" === opcode.opcode) out.push("DECLARE " + opcode.name + "=" + opcode.value); else {
                params = [];
                for (var j = 0; opcode.args.length > j; j++) param = opcode.args[j], "string" == typeof param && (param = '"' + param.replace("\n", "\\n") + '"'), 
                params.push(param);
                out.push(opcode.opcode + " " + params.join(" "));
            }
            return out.join("\n");
        },
        equals: function(other) {
            var len = this.opcodes.length;
            if (other.opcodes.length !== len) return !1;
            for (var i = 0; len > i; i++) {
                var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
                if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) return !1;
                for (var j = 0; opcode.args.length > j; j++) if (opcode.args[j] !== otherOpcode.args[j]) return !1;
            }
            return !0;
        },
        guid: 0,
        compile: function(program, options) {
            this.children = [], this.depths = {
                list: []
            }, this.options = options;
            var knownHelpers = this.options.knownHelpers;
            if (this.options.knownHelpers = {
                helperMissing: !0,
                blockHelperMissing: !0,
                each: !0,
                "if": !0,
                unless: !0,
                "with": !0,
                log: !0
            }, knownHelpers) for (var name in knownHelpers) this.options.knownHelpers[name] = knownHelpers[name];
            return this.program(program);
        },
        accept: function(node) {
            return this[node.type](node);
        },
        program: function(program) {
            var statement, statements = program.statements;
            this.opcodes = [];
            for (var i = 0, l = statements.length; l > i; i++) statement = statements[i], this[statement.type](statement);
            return this.isSimple = 1 === l, this.depths.list = this.depths.list.sort(function(a, b) {
                return a - b;
            }), this;
        },
        compileProgram: function(program) {
            var depth, result = new this.compiler().compile(program, this.options), guid = this.guid++;
            this.usePartial = this.usePartial || result.usePartial, this.children[guid] = result;
            for (var i = 0, l = result.depths.list.length; l > i; i++) depth = result.depths.list[i], 
            2 > depth || this.addDepth(depth - 1);
            return guid;
        },
        block: function(block) {
            var mustache = block.mustache, program = block.program, inverse = block.inverse;
            program && (program = this.compileProgram(program)), inverse && (inverse = this.compileProgram(inverse));
            var type = this.classifyMustache(mustache);
            "helper" === type ? this.helperMustache(mustache, program, inverse) : "simple" === type ? (this.simpleMustache(mustache), 
            this.opcode("pushProgram", program), this.opcode("pushProgram", inverse), this.opcode("emptyHash"), 
            this.opcode("blockValue")) : (this.ambiguousMustache(mustache, program, inverse), 
            this.opcode("pushProgram", program), this.opcode("pushProgram", inverse), this.opcode("emptyHash"), 
            this.opcode("ambiguousBlockValue")), this.opcode("append");
        },
        hash: function(hash) {
            var pair, val, pairs = hash.pairs;
            this.opcode("pushHash");
            for (var i = 0, l = pairs.length; l > i; i++) pair = pairs[i], val = pair[1], this.options.stringParams ? this.opcode("pushStringParam", val.stringModeValue, val.type) : this.accept(val), 
            this.opcode("assignToHash", pair[0]);
            this.opcode("popHash");
        },
        partial: function(partial) {
            var partialName = partial.partialName;
            this.usePartial = !0, partial.context ? this.ID(partial.context) : this.opcode("push", "depth0"), 
            this.opcode("invokePartial", partialName.name), this.opcode("append");
        },
        content: function(content) {
            this.opcode("appendContent", content.string);
        },
        mustache: function(mustache) {
            var options = this.options, type = this.classifyMustache(mustache);
            "simple" === type ? this.simpleMustache(mustache) : "helper" === type ? this.helperMustache(mustache) : this.ambiguousMustache(mustache), 
            mustache.escaped && !options.noEscape ? this.opcode("appendEscaped") : this.opcode("append");
        },
        ambiguousMustache: function(mustache, program, inverse) {
            var id = mustache.id, name = id.parts[0], isBlock = null != program || null != inverse;
            this.opcode("getContext", id.depth), this.opcode("pushProgram", program), this.opcode("pushProgram", inverse), 
            this.opcode("invokeAmbiguous", name, isBlock);
        },
        simpleMustache: function(mustache) {
            var id = mustache.id;
            "DATA" === id.type ? this.DATA(id) : id.parts.length ? this.ID(id) : (this.addDepth(id.depth), 
            this.opcode("getContext", id.depth), this.opcode("pushContext")), this.opcode("resolvePossibleLambda");
        },
        helperMustache: function(mustache, program, inverse) {
            var params = this.setupFullMustacheParams(mustache, program, inverse), name = mustache.id.parts[0];
            if (this.options.knownHelpers[name]) this.opcode("invokeKnownHelper", params.length, name); else {
                if (this.knownHelpersOnly) throw Error("You specified knownHelpersOnly, but used the unknown helper " + name);
                this.opcode("invokeHelper", params.length, name);
            }
        },
        ID: function(id) {
            this.addDepth(id.depth), this.opcode("getContext", id.depth);
            var name = id.parts[0];
            name ? this.opcode("lookupOnContext", id.parts[0]) : this.opcode("pushContext");
            for (var i = 1, l = id.parts.length; l > i; i++) this.opcode("lookup", id.parts[i]);
        },
        DATA: function(data) {
            this.options.data = !0, this.opcode("lookupData", data.id);
        },
        STRING: function(string) {
            this.opcode("pushString", string.string);
        },
        INTEGER: function(integer) {
            this.opcode("pushLiteral", integer.integer);
        },
        BOOLEAN: function(bool) {
            this.opcode("pushLiteral", bool.bool);
        },
        comment: function() {},
        opcode: function(name) {
            this.opcodes.push({
                opcode: name,
                args: [].slice.call(arguments, 1)
            });
        },
        declare: function(name, value) {
            this.opcodes.push({
                opcode: "DECLARE",
                name: name,
                value: value
            });
        },
        addDepth: function(depth) {
            if (isNaN(depth)) throw Error("EWOT");
            0 !== depth && (this.depths[depth] || (this.depths[depth] = !0, this.depths.list.push(depth)));
        },
        classifyMustache: function(mustache) {
            var isHelper = mustache.isHelper, isEligible = mustache.eligibleHelper, options = this.options;
            if (isEligible && !isHelper) {
                var name = mustache.id.parts[0];
                options.knownHelpers[name] ? isHelper = !0 : options.knownHelpersOnly && (isEligible = !1);
            }
            return isHelper ? "helper" : isEligible ? "ambiguous" : "simple";
        },
        pushParams: function(params) {
            for (var param, i = params.length; i--; ) param = params[i], this.options.stringParams ? (param.depth && this.addDepth(param.depth), 
            this.opcode("getContext", param.depth || 0), this.opcode("pushStringParam", param.stringModeValue, param.type)) : this[param.type](param);
        },
        setupMustacheParams: function(mustache) {
            var params = mustache.params;
            return this.pushParams(params), mustache.hash ? this.hash(mustache.hash) : this.opcode("emptyHash"), 
            params;
        },
        setupFullMustacheParams: function(mustache, program, inverse) {
            var params = mustache.params;
            return this.pushParams(params), this.opcode("pushProgram", program), this.opcode("pushProgram", inverse), 
            mustache.hash ? this.hash(mustache.hash) : this.opcode("emptyHash"), params;
        }
    };
    var Literal = function(value) {
        this.value = value;
    };
    JavaScriptCompiler.prototype = {
        nameLookup: function(parent, name) {
            return /^[0-9]+$/.test(name) ? parent + "[" + name + "]" : JavaScriptCompiler.isValidJavaScriptVariableName(name) ? parent + "." + name : parent + "['" + name + "']";
        },
        appendToBuffer: function(string) {
            return this.environment.isSimple ? "return " + string + ";" : {
                appendToBuffer: !0,
                content: string,
                toString: function() {
                    return "buffer += " + string + ";";
                }
            };
        },
        initializeBuffer: function() {
            return this.quotedString("");
        },
        namespace: "Handlebars",
        compile: function(environment, options, context, asObject) {
            this.environment = environment, this.options = options || {}, Handlebars.log(Handlebars.logger.DEBUG, this.environment.disassemble() + "\n\n"), 
            this.name = this.environment.name, this.isChild = !!context, this.context = context || {
                programs: [],
                environments: [],
                aliases: {}
            }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.registers = {
                list: []
            }, this.compileStack = [], this.inlineStack = [], this.compileChildren(environment, options);
            var opcode, opcodes = environment.opcodes;
            for (this.i = 0, l = opcodes.length; l > this.i; this.i++) opcode = opcodes[this.i], 
            "DECLARE" === opcode.opcode ? this[opcode.name] = opcode.value : this[opcode.opcode].apply(this, opcode.args);
            return this.createFunctionContext(asObject);
        },
        nextOpcode: function() {
            var opcodes = this.environment.opcodes;
            return opcodes[this.i + 1];
        },
        eat: function() {
            this.i = this.i + 1;
        },
        preamble: function() {
            var out = [];
            if (this.isChild) out.push(""); else {
                var namespace = this.namespace, copies = "helpers = helpers || " + namespace + ".helpers;";
                this.environment.usePartial && (copies = copies + " partials = partials || " + namespace + ".partials;"), 
                this.options.data && (copies += " data = data || {};"), out.push(copies);
            }
            this.environment.isSimple ? out.push("") : out.push(", buffer = " + this.initializeBuffer()), 
            this.lastContext = 0, this.source = out;
        },
        createFunctionContext: function(asObject) {
            var locals = this.stackVars.concat(this.registers.list);
            if (locals.length > 0 && (this.source[1] = this.source[1] + ", " + locals.join(", ")), 
            !this.isChild) for (var alias in this.context.aliases) this.source[1] = this.source[1] + ", " + alias + "=" + this.context.aliases[alias];
            this.source[1] && (this.source[1] = "var " + this.source[1].substring(2) + ";"), 
            this.isChild || (this.source[1] += "\n" + this.context.programs.join("\n") + "\n"), 
            this.environment.isSimple || this.source.push("return buffer;");
            for (var params = this.isChild ? [ "depth0", "data" ] : [ "Handlebars", "depth0", "helpers", "partials", "data" ], i = 0, l = this.environment.depths.list.length; l > i; i++) params.push("depth" + this.environment.depths.list[i]);
            var source = this.mergeSource();
            if (!this.isChild) {
                var revision = Handlebars.COMPILER_REVISION, versions = Handlebars.REVISION_CHANGES[revision];
                source = "this.compilerInfo = [" + revision + ",'" + versions + "'];\n" + source;
            }
            if (asObject) return params.push(source), Function.apply(this, params);
            var functionSource = "function " + (this.name || "") + "(" + params.join(",") + ") {\n  " + source + "}";
            return Handlebars.log(Handlebars.logger.DEBUG, functionSource + "\n\n"), functionSource;
        },
        mergeSource: function() {
            for (var buffer, source = "", i = 0, len = this.source.length; len > i; i++) {
                var line = this.source[i];
                line.appendToBuffer ? buffer = buffer ? buffer + "\n    + " + line.content : line.content : (buffer && (source += "buffer += " + buffer + ";\n  ", 
                buffer = void 0), source += line + "\n  ");
            }
            return source;
        },
        blockValue: function() {
            this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";
            var params = [ "depth0" ];
            this.setupParams(0, params), this.replaceStack(function(current) {
                return params.splice(1, 0, current), "blockHelperMissing.call(" + params.join(", ") + ")";
            });
        },
        ambiguousBlockValue: function() {
            this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";
            var params = [ "depth0" ];
            this.setupParams(0, params);
            var current = this.topStack();
            params.splice(1, 0, current), params[params.length - 1] = "options", this.source.push("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
        },
        appendContent: function(content) {
            this.source.push(this.appendToBuffer(this.quotedString(content)));
        },
        append: function() {
            this.flushInline();
            var local = this.popStack();
            this.source.push("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }"), 
            this.environment.isSimple && this.source.push("else { " + this.appendToBuffer("''") + " }");
        },
        appendEscaped: function() {
            this.context.aliases.escapeExpression = "this.escapeExpression", this.source.push(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
        },
        getContext: function(depth) {
            this.lastContext !== depth && (this.lastContext = depth);
        },
        lookupOnContext: function(name) {
            this.push(this.nameLookup("depth" + this.lastContext, name, "context"));
        },
        pushContext: function() {
            this.pushStackLiteral("depth" + this.lastContext);
        },
        resolvePossibleLambda: function() {
            this.context.aliases.functionType = '"function"', this.replaceStack(function(current) {
                return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
            });
        },
        lookup: function(name) {
            this.replaceStack(function(current) {
                return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, "context");
            });
        },
        lookupData: function(id) {
            this.push(this.nameLookup("data", id, "data"));
        },
        pushStringParam: function(string, type) {
            this.pushStackLiteral("depth" + this.lastContext), this.pushString(type), "string" == typeof string ? this.pushString(string) : this.pushStackLiteral(string);
        },
        emptyHash: function() {
            this.pushStackLiteral("{}"), this.options.stringParams && this.register("hashTypes", "{}");
        },
        pushHash: function() {
            this.hash = {
                values: [],
                types: []
            };
        },
        popHash: function() {
            var hash = this.hash;
            this.hash = void 0, this.options.stringParams && this.register("hashTypes", "{" + hash.types.join(",") + "}"), 
            this.push("{\n    " + hash.values.join(",\n    ") + "\n  }");
        },
        pushString: function(string) {
            this.pushStackLiteral(this.quotedString(string));
        },
        push: function(expr) {
            return this.inlineStack.push(expr), expr;
        },
        pushLiteral: function(value) {
            this.pushStackLiteral(value);
        },
        pushProgram: function(guid) {
            null != guid ? this.pushStackLiteral(this.programExpression(guid)) : this.pushStackLiteral(null);
        },
        invokeHelper: function(paramSize, name) {
            this.context.aliases.helperMissing = "helpers.helperMissing";
            var helper = this.lastHelper = this.setupHelper(paramSize, name, !0);
            this.push(helper.name), this.replaceStack(function(name) {
                return name + " ? " + name + ".call(" + helper.callParams + ") " + ": helperMissing.call(" + helper.helperMissingParams + ")";
            });
        },
        invokeKnownHelper: function(paramSize, name) {
            var helper = this.setupHelper(paramSize, name);
            this.push(helper.name + ".call(" + helper.callParams + ")");
        },
        invokeAmbiguous: function(name, helperCall) {
            this.context.aliases.functionType = '"function"', this.pushStackLiteral("{}");
            var helper = this.setupHelper(0, name, helperCall), helperName = this.lastHelper = this.nameLookup("helpers", name, "helper"), nonHelper = this.nameLookup("depth" + this.lastContext, name, "context"), nextStack = this.nextStack();
            this.source.push("if (" + nextStack + " = " + helperName + ") { " + nextStack + " = " + nextStack + ".call(" + helper.callParams + "); }"), 
            this.source.push("else { " + nextStack + " = " + nonHelper + "; " + nextStack + " = typeof " + nextStack + " === functionType ? " + nextStack + ".apply(depth0) : " + nextStack + "; }");
        },
        invokePartial: function(name) {
            var params = [ this.nameLookup("partials", name, "partial"), "'" + name + "'", this.popStack(), "helpers", "partials" ];
            this.options.data && params.push("data"), this.context.aliases.self = "this", this.push("self.invokePartial(" + params.join(", ") + ")");
        },
        assignToHash: function(key) {
            var type, value = this.popStack();
            this.options.stringParams && (type = this.popStack(), this.popStack());
            var hash = this.hash;
            type && hash.types.push("'" + key + "': " + type), hash.values.push("'" + key + "': (" + value + ")");
        },
        compiler: JavaScriptCompiler,
        compileChildren: function(environment, options) {
            for (var child, compiler, children = environment.children, i = 0, l = children.length; l > i; i++) {
                child = children[i], compiler = new this.compiler();
                var index = this.matchExistingProgram(child);
                null == index ? (this.context.programs.push(""), index = this.context.programs.length, 
                child.index = index, child.name = "program" + index, this.context.programs[index] = compiler.compile(child, options, this.context), 
                this.context.environments[index] = child) : (child.index = index, child.name = "program" + index);
            }
        },
        matchExistingProgram: function(child) {
            for (var i = 0, len = this.context.environments.length; len > i; i++) {
                var environment = this.context.environments[i];
                if (environment && environment.equals(child)) return i;
            }
        },
        programExpression: function(guid) {
            if (this.context.aliases.self = "this", null == guid) return "self.noop";
            for (var depth, child = this.environment.children[guid], depths = child.depths.list, programParams = [ child.index, child.name, "data" ], i = 0, l = depths.length; l > i; i++) depth = depths[i], 
            1 === depth ? programParams.push("depth0") : programParams.push("depth" + (depth - 1));
            return 0 === depths.length ? "self.program(" + programParams.join(", ") + ")" : (programParams.shift(), 
            "self.programWithDepth(" + programParams.join(", ") + ")");
        },
        register: function(name, val) {
            this.useRegister(name), this.source.push(name + " = " + val + ";");
        },
        useRegister: function(name) {
            this.registers[name] || (this.registers[name] = !0, this.registers.list.push(name));
        },
        pushStackLiteral: function(item) {
            return this.push(new Literal(item));
        },
        pushStack: function(item) {
            this.flushInline();
            var stack = this.incrStack();
            return item && this.source.push(stack + " = " + item + ";"), this.compileStack.push(stack), 
            stack;
        },
        replaceStack: function(callback) {
            var stack, prefix = "", inline = this.isInline();
            if (inline) {
                var top = this.popStack(!0);
                if (top instanceof Literal) stack = top.value; else {
                    var name = this.stackSlot ? this.topStackName() : this.incrStack();
                    prefix = "(" + this.push(name) + " = " + top + "),", stack = this.topStack();
                }
            } else stack = this.topStack();
            var item = callback.call(this, stack);
            return inline ? ((this.inlineStack.length || this.compileStack.length) && this.popStack(), 
            this.push("(" + prefix + item + ")")) : (/^stack/.test(stack) || (stack = this.nextStack()), 
            this.source.push(stack + " = (" + prefix + item + ");")), stack;
        },
        nextStack: function() {
            return this.pushStack();
        },
        incrStack: function() {
            return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), 
            this.topStackName();
        },
        topStackName: function() {
            return "stack" + this.stackSlot;
        },
        flushInline: function() {
            var inlineStack = this.inlineStack;
            if (inlineStack.length) {
                this.inlineStack = [];
                for (var i = 0, len = inlineStack.length; len > i; i++) {
                    var entry = inlineStack[i];
                    entry instanceof Literal ? this.compileStack.push(entry) : this.pushStack(entry);
                }
            }
        },
        isInline: function() {
            return this.inlineStack.length;
        },
        popStack: function(wrapped) {
            var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
            return !wrapped && item instanceof Literal ? item.value : (inline || this.stackSlot--, 
            item);
        },
        topStack: function(wrapped) {
            var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
            return !wrapped && item instanceof Literal ? item.value : item;
        },
        quotedString: function(str) {
            return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r") + '"';
        },
        setupHelper: function(paramSize, name, missingParams) {
            var params = [];
            this.setupParams(paramSize, params, missingParams);
            var foundHelper = this.nameLookup("helpers", name, "helper");
            return {
                params: params,
                name: foundHelper,
                callParams: [ "depth0" ].concat(params).join(", "),
                helperMissingParams: missingParams && [ "depth0", this.quotedString(name) ].concat(params).join(", ")
            };
        },
        setupParams: function(paramSize, params, useRegister) {
            var param, inverse, program, options = [], contexts = [], types = [];
            options.push("hash:" + this.popStack()), inverse = this.popStack(), program = this.popStack(), 
            (program || inverse) && (program || (this.context.aliases.self = "this", program = "self.noop"), 
            inverse || (this.context.aliases.self = "this", inverse = "self.noop"), options.push("inverse:" + inverse), 
            options.push("fn:" + program));
            for (var i = 0; paramSize > i; i++) param = this.popStack(), params.push(param), 
            this.options.stringParams && (types.push(this.popStack()), contexts.push(this.popStack()));
            return this.options.stringParams && (options.push("contexts:[" + contexts.join(",") + "]"), 
            options.push("types:[" + types.join(",") + "]"), options.push("hashTypes:hashTypes")), 
            this.options.data && options.push("data:data"), options = "{" + options.join(",") + "}", 
            useRegister ? (this.register("options", options), params.push("options")) : params.push(options), 
            params.join(", ");
        }
    };
    for (var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "), compilerWords = JavaScriptCompiler.RESERVED_WORDS = {}, i = 0, l = reservedWords.length; l > i; i++) compilerWords[reservedWords[i]] = !0;
    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name) ? !0 : !1;
    };
}(Handlebars.Compiler, Handlebars.JavaScriptCompiler), Handlebars.precompile = function(input, options) {
    if (!input || "string" != typeof input && input.constructor !== Handlebars.AST.ProgramNode) throw new Handlebars.Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    options = options || {}, "data" in options || (options.data = !0);
    var ast = Handlebars.parse(input), environment = new Handlebars.Compiler().compile(ast, options);
    return new Handlebars.JavaScriptCompiler().compile(environment, options);
}, Handlebars.compile = function(input, options) {
    function compile() {
        var ast = Handlebars.parse(input), environment = new Handlebars.Compiler().compile(ast, options), templateSpec = new Handlebars.JavaScriptCompiler().compile(environment, options, void 0, !0);
        return Handlebars.template(templateSpec);
    }
    if (!input || "string" != typeof input && input.constructor !== Handlebars.AST.ProgramNode) throw new Handlebars.Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    options = options || {}, "data" in options || (options.data = !0);
    var compiled;
    return function(context, options) {
        return compiled || (compiled = compile()), compiled.call(this, context, options);
    };
}, Handlebars.VM = {
    template: function(templateSpec) {
        var container = {
            escapeExpression: Handlebars.Utils.escapeExpression,
            invokePartial: Handlebars.VM.invokePartial,
            programs: [],
            program: function(i, fn, data) {
                var programWrapper = this.programs[i];
                return data ? Handlebars.VM.program(fn, data) : programWrapper ? programWrapper : programWrapper = this.programs[i] = Handlebars.VM.program(fn);
            },
            programWithDepth: Handlebars.VM.programWithDepth,
            noop: Handlebars.VM.noop,
            compilerInfo: null
        };
        return function(context, options) {
            options = options || {};
            var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data), compilerInfo = container.compilerInfo || [], compilerRevision = compilerInfo[0] || 1, currentRevision = Handlebars.COMPILER_REVISION;
            if (compilerRevision !== currentRevision) {
                if (currentRevision > compilerRevision) {
                    var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision], compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
                    throw "Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").";
                }
                throw "Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").";
            }
            return result;
        };
    },
    programWithDepth: function(fn, data) {
        var args = Array.prototype.slice.call(arguments, 2);
        return function(context, options) {
            return options = options || {}, fn.apply(this, [ context, options.data || data ].concat(args));
        };
    },
    program: function(fn, data) {
        return function(context, options) {
            return options = options || {}, fn(context, options.data || data);
        };
    },
    noop: function() {
        return "";
    },
    invokePartial: function(partial, name, context, helpers, partials, data) {
        var options = {
            helpers: helpers,
            partials: partials,
            data: data
        };
        if (void 0 === partial) throw new Handlebars.Exception("The partial " + name + " could not be found");
        if (partial instanceof Function) return partial(context, options);
        if (Handlebars.compile) return partials[name] = Handlebars.compile(partial, {
            data: void 0 !== data
        }), partials[name](context, options);
        throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
}, Handlebars.template = Handlebars.VM.template;

var Functional = function(parent) {
    var _ = parent._ = Function._ = {}, slice = Array.prototype.slice, _unshift = Array.prototype.unshift, unshift = function(xs, item) {
        return _unshift.call(xs, item), xs;
    }, toArray = function(x) {
        return slice.call(x);
    }, curry = function(fn) {
        var args = slice.call(arguments, 1);
        return composed = function() {
            return fn.apply(this, args.concat(toArray(arguments)));
        }, composed.curried = !0, composed;
    }, autoCurry = function(fn, numArgs) {
        return numArgs = numArgs || fn.length, composed = function() {
            return numArgs > arguments.length ? numArgs - arguments.length > 0 ? autoCurry(curry.apply(this, unshift(toArray(arguments), fn)), numArgs - arguments.length) : curry.apply(this, unshift(toArray(arguments), fn)) : fn.apply(this, arguments);
        }, composed.toString = function() {
            return "" + fn;
        }, composed.curried = !0, composed;
    }, map = (function() {
        Function.prototype.autoCurry = function(n) {
            return autoCurry(this, n);
        }, Function.prototype.curry = function() {
            return curry.apply(this, unshift(toArray(arguments), this));
        };
    }(), function(fn, sequence) {
        var i, length = sequence.length, result = Array(length);
        for (fn = Function.toFunction(fn), i = 0; length > i; i++) result[i] = fn.apply(null, [ sequence[i], i ]);
        return result;
    }.autoCurry()), compose = function() {
        var fns = map(Function.toFunction, arguments), arglen = fns.length;
        return function() {
            var i;
            for (i = arglen; --i >= 0; ) arguments = [ fns[i].apply(this, arguments) ];
            return arguments[0];
        };
    }, sequence = function() {
        var fns = map(Function.toFunction, arguments), arglen = fns.length;
        return function() {
            var i;
            for (i = 0; arglen > i; i++) arguments = [ fns[i].apply(this, arguments) ];
            return arguments[0];
        };
    }, memoize = function(fn) {
        return function() {
            var args = toArray(arguments), hash = "", i = args.length;
            for (currentArg = null; i--; ) currentArg = args[i], hash += currentArg === Object(currentArg) ? JSON.stringify(currentArg) : currentArg, 
            fn.memoize || (fn.memoize = {});
            return hash in fn.memoize ? fn.memoize[hash] : fn.memoize[hash] = fn.apply(this, args);
        };
    }, reduce = function(fn, init, sequence) {
        var i, len = sequence.length, result = init;
        for (fn = Function.toFunction(fn), i = 0; len > i; i++) result = fn.apply(null, [ result, sequence[i] ]);
        return result;
    }.autoCurry(), select = function(fn, sequence) {
        var i, x, len = sequence.length, result = [];
        for (fn = Function.toFunction(fn), i = 0; len > i; i++) x = sequence[i], fn.apply(null, [ x, i ]) && result.push(x);
        return result;
    }.autoCurry(), guard = function(guard, fn, otherwise) {
        return guard = Function.toFunction(guard || I), fn = Function.toFunction(fn), otherwise = Function.toFunction(otherwise || I), 
        function() {
            return (guard.apply(this, arguments) ? fn : otherwise).apply(this, arguments);
        };
    }.autoCurry(), flip = function(f) {
        return function() {
            var args = toArray(arguments);
            return args = args.slice(1, 2).concat(args.slice(0, 1)).concat(args.slice(2)), f.apply(null, args);
        };
    }, foldr = function(fn, init, sequence) {
        var i, len = sequence.length, result = init;
        for (fn = Function.toFunction(fn), i = len; --i >= 0; ) result = fn.apply(null, [ sequence[i], result ]);
        return result;
    }.autoCurry(), and = function() {
        var args = map(Function.toFunction, arguments), arglen = args.length;
        return function() {
            var i, value = !0;
            for (i = 0; arglen > i && (value = args[i].apply(this, arguments)); i++) ;
            return !!value;
        };
    }, or = function() {
        var args = map(Function.toFunction, arguments), arglen = args.length;
        return function() {
            var i, value = !1;
            for (i = 0; arglen > i && !(value = args[i].apply(this, arguments)); i++) ;
            return !!value;
        };
    }, some = function(fn, sequence) {
        fn = Function.toFunction(fn);
        var i, len = sequence.length, value = !1;
        for (i = 0; len > i && !(value = fn.call(this, sequence[i])); i++) ;
        return value;
    }.autoCurry(), every = function(fn, sequence) {
        fn = Function.toFunction(fn);
        var i, len = sequence.length, value = !0;
        for (i = 0; len > i && (value = fn.call(this, sequence[i])); i++) ;
        return value;
    }.autoCurry(), not = function(fn) {
        return fn = Function.toFunction(fn), function() {
            return !fn.apply(this, arguments);
        };
    }, eq = function(x) {
        var equal = function() {
            return every(function(t) {
                return x === t;
            }, arguments);
        };
        return 1 === arguments.length ? equal : equal.apply(this, arguments);
    }, equal = function() {
        var arglen = arguments.length, args = map(Function.toFunction, arguments);
        return arglen ? function() {
            var i, value = args[0].apply(this, arguments);
            for (i = 1; arglen > i; i++) if (value != args[i].apply(this, args)) return !1;
            return !0;
        } : K(!0);
    }, lambda = function(object) {
        return object.toFunction();
    }, invoke = function(methodName) {
        var args = slice.call(arguments, 1);
        return function(object) {
            return object[methodName].apply(object, slice.call(arguments, 1).concat(args));
        };
    }, pluck = function(name, obj) {
        return obj[name];
    }.autoCurry(), until = function(pred, fn) {
        return fn = Function.toFunction(fn), pred = Function.toFunction(pred), function(value) {
            for (;!pred.call(this, value); ) value = fn.call(this, value);
            return value;
        };
    }.autoCurry(), zip = function() {
        var key, i, n = Math.min.apply(this, map(".length", arguments)), results = Array(n);
        for (i = 0; n > i; i++) key = i + "", results[key] = map(pluck(key), arguments);
        return results;
    }, I = function(x) {
        return x;
    }, K = function(x) {
        return function() {
            return x;
        };
    }, S = function(f, g) {
        var toFunction = Function.toFunction;
        return f = toFunction(f), g = toFunction(g), function() {
            var return_value_of_g = g.apply(this, arguments), original_args = slice.call(arguments, 0), all_args = unshift(original_args, return_value_of_g);
            return f.apply(this, all_args);
        };
    }, partial = function() {
        var i, fn = this, args = toArray(arguments), subpos = [];
        for (i = 0; arguments.length > i; i++) arguments[i] == _ && subpos.push(i);
        return function() {
            var i, specialized = args.concat(slice.call(arguments, subpos.length));
            for (i = 0; Math.min(subpos.length, arguments.length) > i; i++) specialized[subpos[i]] = arguments[i];
            for (i = 0; specialized.length > i; i++) if (specialized[i] === _) return fn.partial.apply(fn, specialized);
            return fn.apply(this, specialized);
        };
    }, ECMAspit = "ab".split(/a*/).length > 1 ? String.prototype.split : function(separator, limit) {
        if (limit !== undefined) throw "ECMAsplit: limit is unimplemented";
        var result = this.split.apply(this, arguments), re = RegExp(separator), savedIndex = re.lastIndex, match = re.exec(this);
        return match && 0 == match.index && result.unshift(""), re.lastIndex = savedIndex, 
        result;
    }, stringLambda = function() {
        var params = [], expr = this, sections = ECMAspit.call(expr, /\s*->\s*/m);
        if (sections.length > 1) for (;sections.length; ) expr = sections.pop(), params = sections.pop().split(/\s*,\s*|\s+/m), 
        sections.length && sections.push("(function(" + params + "){return (" + expr + ")})"); else if (expr.match(/\b_\b/)) params = "_"; else {
            var leftSection = expr.match(/^\s*(?:[+*\/%&|\^\.=<>]|!=)/m), rightSection = expr.match(/[+\-*\/%&|\^\.=<>!]\s*$/m);
            if (leftSection || rightSection) leftSection && (params.push("$1"), expr = "$1" + expr), 
            rightSection && (params.push("$2"), expr += "$2"); else for (var v, regex = /(?:\b[A-Z]|\.[a-zA-Z_$])[a-zA-Z_$\d]*|[a-zA-Z_$][a-zA-Z_$\d]*\s*:|this|arguments|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"/g, vars = this.replace(regex, "").match(/([a-z_$][a-z_$\d]*)/gi) || [], i = 0; v = vars[i++]; ) params.indexOf(v) >= 0 || params.push(v);
        }
        return Function(params, "return (" + expr + ")");
    }, cacheStringLambda = function() {
        var cached, proto = String.prototype, cache = {}, uncached = proto.lambda;
        cached = function() {
            var key = "#" + this;
            return cache[key] || (cache[key] = uncached.call(this));
        }, cached.cached = function() {}, cached.uncache = function() {
            proto.lambda = uncached;
        }, proto.lambda = cached;
    }, stringToFunction = function() {
        var body = this;
        return body.match(/\breturn\b/) ? Function(this) : this.lambda();
    };
    return Function.prototype.partial = partial, Function.prototype.flip = function() {
        return flip.apply(this, unshift(toArray(arguments), this));
    }, Function.toFunction = function(value) {
        return value.toFunction();
    }, Function.prototype.toFunction = function() {
        return this;
    }, String.prototype.lambda = stringLambda, String.prototype.lambda.cache = cacheStringLambda, 
    String.prototype.toFunction = stringToFunction, {
        map: map,
        curry: curry,
        compose: compose,
        sequence: sequence,
        memoize: memoize,
        reduce: reduce,
        foldl: reduce,
        foldr: foldr,
        select: select,
        filter: select,
        guard: guard,
        flip: flip,
        and: and,
        or: or,
        some: some,
        every: every,
        eq: eq,
        not: not,
        equal: equal,
        lambda: lambda,
        invoke: invoke,
        pluck: pluck,
        until: until,
        zip: zip,
        I: I,
        K: K,
        S: S,
        install: function(except) {
            var source = functional, target = parent;
            for (var name in source) "install" == name || "_" == name.charAt(0) || except && except.contains(name) || (target[name] = source[name]);
        }
    };
}(this), prelude = function() {
    var funclib = Functional, nTimes = function(times, fun) {
        for (var result = [], i = 0; times > i; i++) result = cons(fun(), result);
        return result;
    }.autoCurry(), log = function(what) {
        return console.log(what), what;
    }, log2 = function(one, two) {
        return log(one), log(two);
    }.autoCurry(), when = function(pred, f) {
        return function() {
            return pred.apply(this, arguments) ? f.apply(this, arguments) : undefined;
        };
    }.autoCurry(), ifelse = function(pred, f, g) {
        return function() {
            return pred.apply(this, arguments) ? f.apply(this, arguments) : g.apply(this, arguments);
        };
    }.autoCurry(), negate = function(bool) {
        return !bool;
    }, andand = function(x, y) {
        return x && y;
    }.autoCurry(), oror = function(x, y) {
        return x || y;
    }.autoCurry(), equals = function(x, y) {
        return x === y;
    }.autoCurry(), isArray = function(obj) {
        return obj && obj.constructor == Array;
    }, isObj = function(obj) {
        return "object" == typeof obj && !isArray(obj);
    }, isNumber = function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }, take = function(n, xs) {
        return xs.slice(0, n);
    }.autoCurry(), drop = function(n, xs) {
        return xs.slice(n);
    }.autoCurry(), unshift = function(xs, x) {
        return x.concat(xs);
    }.autoCurry(), cons = function(x, xs) {
        return [ x ].concat(xs);
    }.autoCurry(), concat = function(xs, ys) {
        return xs.concat(ys);
    }.autoCurry(), first = function(xs) {
        return xs[0];
    }, item = function(n, xs) {
        return xs[n];
    }.autoCurry(), rest = function(xs) {
        return "string" == typeof xs ? xs.substr(1) : xs.slice(1);
    }, last = function(xs) {
        return xs[xs.length - 1];
    }, join = function(token, xs) {
        return xs.join(token);
    }.autoCurry(), groupsOf = function(n, xs) {
        return xs.length ? cons(take(n, xs), groupsOf(n, drop(n, xs))) : [];
    }.autoCurry(), zipWith = function(f, xs, ys) {
        return f = f.toFunction(), xs.reduce(function(result, x, i) {
            return result.concat(f(x, ys[i]));
        }, []);
    }.autoCurry(), uniq = function(xs) {
        for (var result = [], i = 0; xs.length > i; i++) 0 > result.indexOf(xs[i]) && result.push(xs[i]);
        return result;
    }, uniqBy = function(fun, xs) {
        for (var result = [], len = xs.length, fun = fun.toFunction(), i = 0; len > i; i++) 0 > funclib.map(fun)(result).indexOf(fun(xs[i])) && result.push(xs[i]);
        return result;
    }.autoCurry(), reverse = function(xs) {
        var mempty = "string" == typeof xs ? "" : [];
        return isArray(xs) ? xs.reverse() : funclib.reduce(function(x, acc) {
            return acc.concat(x);
        }, mempty, xs);
    }.autoCurry(), is_num_array = function(arr) {
        return reduce(andand, !0, funclib.map(isNumber, arr));
    }, sort = function(xs) {
        return num_sort_func = function(a, b) {
            return a - b;
        }, is_num_array ? xs.sort(num_sort_func) : xs.sort();
    }, element = function(arr, x) {
        return arr.indexOf(x) >= 0;
    }.autoCurry(), flatten = funclib.reduce(function(a, b) {
        return a.concat(b);
    }, []), sortBy = function(fun, xs) {
        var _sortBy = function(iterator, xs, context) {
            return map(".value", map(function(value, index) {
                return {
                    value: value,
                    criteria: iterator.call(context, value, index)
                };
            }, xs).sort(function(left, right) {
                var a = left.criteria, b = right.criteria;
                return b > a ? -1 : a > b ? 1 : 0;
            }));
        }, f = fun.toFunction();
        return _sortBy(f, xs);
    }.autoCurry(), groupBy = function(fun, xs) {
        var f = fun.toFunction(), _makeHash = function(obj, x) {
            var val = f(x);
            return obj[val] || (obj[val] = []), obj[val].push(x), obj;
        };
        return reduce(_makeHash, {}, xs);
    }.autoCurry(), strip = function(str) {
        return str.replace(/\s+/g, "");
    }, split = function(token, xs) {
        return xs.split(token);
    }.autoCurry(), test = function(expr, x) {
        return expr.test(x);
    }.autoCurry(), match = function(expr, x) {
        return x.match(expr);
    }.autoCurry(), replace = function(pattern, sub, str) {
        return str.replace(pattern, sub);
    }.autoCurry(), indexOf = function(par, kid) {
        return par.indexOf(kid);
    }.autoCurry(), contains = function(par, kid) {
        return -1 !== par.indexOf(kid);
    }.autoCurry(), setVal = function(attribute, x, val) {
        return x[attribute] = val, val;
    }.autoCurry(), getVal = function(attribute, x) {
        return function() {
            return x[attribute];
        };
    }.autoCurry(), getProp = function(x, attr) {
        return x[attr];
    }.autoCurry(), setProp = function(x, attr, val) {
        return x[attr] = val, val;
    }.autoCurry(), random = function(i) {
        return Math.floor(Math.random() * i);
    }, subtract = function(x, y) {
        return y - x;
    }.autoCurry(), sum = funclib.reduce("+", 0), div = function(x, y) {
        return x / y;
    }, average = function(xs) {
        var zerolessArr = filter("!==0", xs);
        return div(sum(zerolessArr), zerolessArr.length);
    }, repeat = function(arg, n) {
        return nTimes(n, funclib.id.curry(arg));
    }.autoCurry();
    return {
        equals: equals,
        isArray: isArray,
        isObj: isObj,
        nTimes: nTimes,
        log: log,
        log2: log2,
        take: take,
        drop: drop,
        unshift: unshift,
        cons: cons,
        concat: concat,
        first: first,
        item: item,
        rest: rest,
        last: last,
        join: join,
        isNumber: isNumber,
        groupsOf: groupsOf,
        zipWith: zipWith,
        uniq: uniq,
        uniqBy: uniqBy,
        reverse: reverse,
        sort: sort,
        element: element,
        flatten: flatten,
        sortBy: sortBy,
        groupBy: groupBy,
        strip: strip,
        split: split,
        indexOf: indexOf,
        contains: contains,
        test: test,
        match: match,
        replace: replace,
        ifelse: ifelse,
        when: when,
        negate: negate,
        andand: andand,
        oror: oror,
        setVal: setVal,
        getVal: getVal,
        setProp: setProp,
        getProp: getProp,
        random: random,
        subtract: subtract,
        sum: sum,
        div: div,
        average: average,
        repeat: repeat
    };
}();

(function(engine) {
    function compileAll(source, compiled) {
        compiled = compiled || {};
        for (var key in source) try {
            compiled[key] = engine.compile(source[key]);
        } catch (err) {
            console.log(err);
        }
        return compiled;
    }
    var source = engine.source = engine.source || {}, compiled = engine.templates = engine.templates || {};
    engine.registerPartial("player", "<span>{{user}}</span>"), source.stream = [ "<li id='tf{{class}}'>", "<span class='tf-class'>{{class}}</span>", "<span class='tf-players'>", "{{#each added}}", "{{> player this}}", "{{/each}}", "</span>", "</li>" ].join(""), 
    source.authpage = [ "<h1>Connect to {{network}} IRC</h1>", "<form id='login'>", "<div class='nick right'><span>Nickname:</span><input type='text' name='basic' id='nickname' value={{nickname}}></div>", "<div class='username right {{#unless full}}hidden{{/unless}}'><span>Gamesurge username:</span><input type='text' name='full' id='username' value='{{username}}'></div>", "<div class='password right {{#unless full}}hidden{{/unless}}'><span>Password:</span><input type='password' name='full' id='password' value='{{password}}'></div>", "<div class='authenticate'>", "<span>Authenticate (optional)</span><input type='checkbox' id='authenticate' {{check full}}>", "</div>", "<div><input type='submit' value='Connect' /></div>", "</form>" ].join(""), 
    engine.registerHelper("not", function(b) {
        return !b;
    }), engine.registerHelper("hidden", function(hidden) {
        return console.log(hidden), hidden ? "hidden" : "";
    }), engine.registerHelper("check", function(checked) {
        return checked ? "checked" : "";
    }), engine.registerHelper("chain", function() {
        var value, helpers = [];
        return $each(arguments, function(arg, i) {
            return engine.helpers[arg] ? (helpers.push(engine.helpers[arg]), void 0) : (value = arg, 
            $each(helpers, function(helper) {
                value = helper(value, arguments[i + 1]);
            }), !1);
        }), value;
    }), compileAll(source, compiled);
})(Handlebars), function(par, undefined) {
    par.QWEBIRC_BUILD = "bbc577ad5cb78d946ac1";
    var qwebirc = par.qwebirc = {}, irc = qwebirc.irc = {}, util = qwebirc.util = {}, crypto = util.crypto = {}, config = qwebirc.config = {}, auth = qwebirc.auth = {}, ui = qwebirc.ui = {}, themes = ui.themes = {}, style = ui.style = {}, sound = qwebirc.sound = {};
    qwebirc.BUILD = QWEBIRC_BUILD, qwebirc.FILE_SUFFIX = "-" + QWEBIRC_BUILD, qwebirc.VERSION = "0.92-dev";
    var Functional = par.Functional, prelude = par.prelude, BROUHAHA = "#brouhaha", CONNECTION_DETAILS = "Connection details", STATUS = "Status", OPTIONS = "Options", BASE_WINDOWS = [ BROUHAHA, CONNECTION_DETAILS, STATUS, OPTIONS ];
    irc.IRCLowercaseTable = [ "\0", "", "", "", "", "", "", "", "\b", "	", "\n", "", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ], 
    util.DaysOfWeek = {
        0: "Sun",
        1: "Mon",
        2: "Tue",
        3: "Wed",
        4: "Thu",
        5: "Fri",
        6: "Sat"
    }, util.MonthsOfYear = {
        0: "Jan",
        1: "Feb",
        2: "Mar",
        3: "Apr",
        4: "May",
        5: "Jun",
        6: "Jul",
        7: "Aug",
        8: "Sep",
        9: "Oct",
        10: "Nov",
        11: "Dec"
    }, Array.implement({
        item: function(n) {
            return this[n];
        }
    }), String.implement({
        replaceAll: function(tofind, torep) {
            for (var ns = this; ns.indexOf(tofind) > -1; ) ns = ns.replace(tofind, torep);
            return ns;
        },
        splitMax: function(by, max) {
            var items = this.split(by), len = max - 1, newitems = items.slice(0, len);
            return items.length >= max && newitems.push(items.slice(len).join(by)), newitems;
        },
        startsWith: function(what) {
            return this.substr(0, what.length) === what;
        }
    }), Object.extend({
        subset: function(object, keys) {
            for (var results = {}, i = 0, l = keys.length; l > i; i++) {
                var k = keys[i];
                k in object && (results[k] = object[k]);
            }
            return results;
        }
    });
    var whitespace = /\s/, notwhitespace = /\S+$/, $identity = Functional.I, notEqual = Functional.compose(Functional.not, Functional.eq), charAt = function(n, str) {
        return str.charAt(n);
    }.autoCurry(), splitBang = prelude.split("!"), joinEmpty = prelude.join(""), splitEmpty = prelude.split(""), joinComma = prelude.join(","), splitComma = prelude.split(","), concatUnique = Functional.compose(prelude.uniq, prelude.concat), uniqueBetweenArrays = function(arr1, arr2) {
        var notcontained = Functional.not(prelude.contains(arr2));
        return arr1.filter(notcontained);
    }, startsWith = function(what, str) {
        return str.substr(0, what.length) === what;
    }.autoCurry(), each = Array.forEach.flip().autoCurry(2);
    RegExp.escape = prelude.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), util.dictCopy = function() {
        return $extend.apply({}, arguments);
    }, util.hostToNick = Functional.compose(prelude.first, splitBang), util.hostToHost = Functional.compose(prelude.item(1), splitBang);
    var formatChannel = util.formatChannelString = function(chan) {
        return startsWith("#", chan) || (chan = "#" + chan), chan;
    }, appendChannel = function(chans, chan) {
        var sep = chans && chan ? "," : "";
        return chans.concat(sep, chan);
    }, isBaseWindow = prelude.contains(BASE_WINDOWS);
    util.formatChannelStrings = Functional.compose(joinComma, prelude.uniq, Functional.map(formatChannel), splitComma), 
    util.addChannel = Functional.compose(joinComma, prelude.uniq, splitComma, appendChannel), 
    util.prependChannel = Functional.compose(joinComma, prelude.uniq, splitComma, appendChannel.flip()), 
    util.arrayToChanString = Functional.compose(joinComma, prelude.uniq, Functional.filter.curry(Functional.not(isBaseWindow))), 
    util.removeChannel = function(list, value) {
        return joinComma(splitComma(list).erase(value));
    }, util.nickChanComparitor = function(client, nickHash) {
        var _prefixes = client.prefixes, _prefixNone = _prefixes.length, prefixWeight = function(pre) {
            return 0 !== pre.length ? _prefixes.indexOf(pre) : _prefixNone;
        }, toLower = client.toIRCLower;
        return function(nick1, nick2) {
            var p1weight = prefixWeight(nickHash[nick1].prefixes), p2weight = prefixWeight(nickHash[nick2].prefixes);
            return p1weight !== p2weight ? p1weight - p2weight : toLower(nick1).localeCompare(toLower(nick2));
        };
    }, util.nickPrefixer = function(nickHash) {
        return function(nick) {
            return nickHash[nick].prefixes.concat(nick);
        };
    }, util.validPrefix = prelude.contains, util.addPrefix = Functional.compose(joinEmpty, prelude.uniq, prelude.concat), 
    util.prefixOnNick = function(prefixes, nick) {
        var c = nick.charAt(0);
        return util.validPrefix(prefixes, c) ? [ c, nick.substr(1) ] : [ "", nick ];
    }.autoCurry(), util.getPrefix = Functional.compose(prelude.first, util.prefixOnNick), 
    util.stripPrefix = Functional.compose(prelude.item(1), util.prefixOnNick), util.toHSBColour = function(nick, client) {
        var lower = client.toIRCLower(util.stripPrefix(client.prefixes, nick));
        if (lower == client.lowerNickname) return null;
        for (var hash = 0, i = 0; lower.length > i; i++) hash = 31 * hash + lower.charCodeAt(i);
        var hue = Math.abs(hash) % 360;
        return new Color([ hue, 70, 60 ], "hsb");
    };
    var charIRCLower = Functional.compose(Array.item.curry(irc.IRCLowercaseTable), String.charCodeAt.partial(_, 0));
    irc.RFC1459toIRCLower = Functional.memoize(Functional.compose(prelude.join(""), Functional.map(charIRCLower))), 
    irc.toIRCCompletion = Functional.compose(prelude.replace(/[^\w]+/g, ""), Functional.invoke("toIRCLower")), 
    irc.ASCIItoIRCLower = String.toLowerCase, util.parseURI = function(uri) {
        var result = {}, start = uri.indexOf("?");
        if (-1 === start) return result;
        for (var querystring = uri.substring(start + 1), args = querystring.split("&"), i = 0; args.length > i; i++) {
            var part = args[i].splitMax("=", 2);
            2 > part.length || (result[unescape(part[0])] = unescape(part[1]));
        }
        return result;
    }, util.longtoduration = function(l) {
        var seconds = l % 60, minutes = Math.floor(l % 3600 / 60), hours = Math.floor(l % 86400 / 3600), days = Math.floor(l / 86400);
        return days + " days " + hours + " hours " + minutes + " minutes " + seconds + " seconds";
    };
    var pad = util.pad = function(x) {
        return x += "", 1 === x.length ? "0" + x : x;
    };
    util.browserVersion = $lambda(navigator.userAgent), util.getEnclosedWord = function(str, pos) {
        pos >>>= 0;
        var left = str.slice(0, pos + 1).search(notwhitespace), right = str.slice(pos).search(whitespace), word = 0 > right ? str.slice(left) : str.slice(left, right + pos);
        return [ left, word ];
    }, util.randHexString = function(numBytes) {
        for (var getByte = function() {
            return (0 | 256 * (1 + Math.random())).toString(16).substring(1);
        }, l = [], i = 0; numBytes > i; i++) l.push(getByte());
        return l.join("");
    }, irc.IRCTimestamp = function(date) {
        return "[" + pad(date.getHours()) + ":" + pad(date.getMinutes()) + "]";
    }, irc.IRCDate = function(d) {
        return util.DaysOfWeek[d.getDay()] + " " + util.MonthsOfYear[d.getMonth()] + " " + pad(d.getDate()) + " " + pad(d.getHours()) + ":" + pad(d.getMinutes()) + ":" + pad(d.getSeconds()) + " " + d.getFullYear();
    }, irc.NickChanEntry = function() {
        this.prefixes = "", this.lastSpoke = 0;
    }, util.deviceHasKeyboard = function() {
        var DESKTOP_UAs = [ "Chrome", "Firefox", "Camino", "Iceweasel", "K-Meleon", "Konqueror", "SeaMonkey", "Windows NT", "Windows 9" ], ua = navigator.userAgent, v = 0 !== DESKTOP_UAs.filter(Functional.compose(notEqual(-1), prelude.indexOf(ua))).length;
        return util.deviceHasKeyboard = $lambda(v), v;
    }, util.generateID = function() {
        var id = 0;
        return function() {
            return "qqa-" + id++;
        };
    }();
    var B64 = util.B64 = {
        _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        encode: function(input) {
            if (!input) return "";
            input = B64._utf8_encode(input);
            for (var chr1, chr2, chr3, enc1, enc2, enc3, enc4, output = "", i = 0; input.length > i; ) chr1 = input.charCodeAt(i++), 
            chr2 = input.charCodeAt(i++), chr3 = input.charCodeAt(i++), enc1 = chr1 >> 2, enc2 = (3 & chr1) << 4 | chr2 >> 4, 
            enc3 = (15 & chr2) << 2 | chr3 >> 6, enc4 = 63 & chr3, isNaN(chr2) ? enc3 = enc4 = 64 : isNaN(chr3) && (enc4 = 64), 
            output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
            return output;
        },
        decode: function(input) {
            if (!input) return "";
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4, output = "", i = 0;
            for (input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ""); input.length > i; ) enc1 = this._keyStr.indexOf(input.charAt(i++)), 
            enc2 = this._keyStr.indexOf(input.charAt(i++)), enc3 = this._keyStr.indexOf(input.charAt(i++)), 
            enc4 = this._keyStr.indexOf(input.charAt(i++)), chr1 = enc1 << 2 | enc2 >> 4, chr2 = (15 & enc2) << 4 | enc3 >> 2, 
            chr3 = (3 & enc3) << 6 | enc4, output += String.fromCharCode(chr1), 64 != enc3 && (output += String.fromCharCode(chr2)), 
            64 != enc4 && (output += String.fromCharCode(chr3));
            return output = B64._utf8_decode(output);
        },
        _utf8_encode: function(string) {
            string = string.replace(/\r\n/g, "\n");
            for (var utftext = "", n = 0; string.length > n; n++) {
                var c = string.charCodeAt(n);
                128 > c ? utftext += String.fromCharCode(c) : c > 127 && 2048 > c ? (utftext += String.fromCharCode(192 | c >> 6), 
                utftext += String.fromCharCode(128 | 63 & c)) : (utftext += String.fromCharCode(224 | c >> 12), 
                utftext += String.fromCharCode(128 | 63 & c >> 6), utftext += String.fromCharCode(128 | 63 & c));
            }
            return utftext;
        },
        _utf8_decode: function(utftext) {
            for (var string = "", i = 0, c = c1 = c2 = 0; utftext.length > i; ) c = utftext.charCodeAt(i), 
            128 > c ? (string += String.fromCharCode(c), i++) : c > 191 && 224 > c ? (c2 = utftext.charCodeAt(i + 1), 
            string += String.fromCharCode((31 & c) << 6 | 63 & c2), i += 2) : (c2 = utftext.charCodeAt(i + 1), 
            c3 = utftext.charCodeAt(i + 2), string += String.fromCharCode((15 & c) << 12 | (63 & c2) << 6 | 63 & c3), 
            i += 3);
            return string;
        }
    };
    crypto.MD5 = function() {
        function rhex(num) {
            for (var str = "", j = 0; 3 >= j; j++) str += hex_chr.charAt(15 & num >> 8 * j + 4) + hex_chr.charAt(15 & num >> 8 * j);
            return str;
        }
        function str2blks_MD5(str) {
            for (var nblk = (str.length + 8 >> 6) + 1, blks = Array(16 * nblk), i = 0; 16 * nblk > i; i++) blks[i] = 0;
            for (var i = 0; str.length > i; i++) blks[i >> 2] |= str.charCodeAt(i) << 8 * (i % 4);
            return blks[i >> 2] |= 128 << 8 * (i % 4), blks[16 * nblk - 2] = 8 * str.length, 
            blks;
        }
        function add(x, y) {
            return (2147483647 & x) + (2147483647 & y) ^ 2147483648 & x ^ 2147483648 & y;
        }
        function rol(num, cnt) {
            return num << cnt | num >>> 32 - cnt;
        }
        function cmn(q, a, b, x, s, t) {
            return add(rol(add(add(a, q), add(x, t)), s), b);
        }
        function ff(a, b, c, d, x, s, t) {
            return cmn(b & c | ~b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t) {
            return cmn(b & d | c & ~d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t) {
            return cmn(b ^ c ^ d, a, b, x, s, t);
        }
        function ii(a, b, c, d, x, s, t) {
            return cmn(c ^ (b | ~d), a, b, x, s, t);
        }
        function calcMD5(str) {
            for (var x = str2blks_MD5(str), a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, i = 0; x.length > i; i += 16) {
                var olda = a, oldb = b, oldc = c, oldd = d;
                a = ff(a, b, c, d, x[i + 0], 7, 3614090360), d = ff(d, a, b, c, x[i + 1], 12, 3905402710), 
                c = ff(c, d, a, b, x[i + 2], 17, 606105819), b = ff(b, c, d, a, x[i + 3], 22, 3250441966), 
                a = ff(a, b, c, d, x[i + 4], 7, 4118548399), d = ff(d, a, b, c, x[i + 5], 12, 1200080426), 
                c = ff(c, d, a, b, x[i + 6], 17, 2821735955), b = ff(b, c, d, a, x[i + 7], 22, 4249261313), 
                a = ff(a, b, c, d, x[i + 8], 7, 1770035416), d = ff(d, a, b, c, x[i + 9], 12, 2336552879), 
                c = ff(c, d, a, b, x[i + 10], 17, 4294925233), b = ff(b, c, d, a, x[i + 11], 22, 2304563134), 
                a = ff(a, b, c, d, x[i + 12], 7, 1804603682), d = ff(d, a, b, c, x[i + 13], 12, 4254626195), 
                c = ff(c, d, a, b, x[i + 14], 17, 2792965006), b = ff(b, c, d, a, x[i + 15], 22, 1236535329), 
                a = gg(a, b, c, d, x[i + 1], 5, 4129170786), d = gg(d, a, b, c, x[i + 6], 9, 3225465664), 
                c = gg(c, d, a, b, x[i + 11], 14, 643717713), b = gg(b, c, d, a, x[i + 0], 20, 3921069994), 
                a = gg(a, b, c, d, x[i + 5], 5, 3593408605), d = gg(d, a, b, c, x[i + 10], 9, 38016083), 
                c = gg(c, d, a, b, x[i + 15], 14, 3634488961), b = gg(b, c, d, a, x[i + 4], 20, 3889429448), 
                a = gg(a, b, c, d, x[i + 9], 5, 568446438), d = gg(d, a, b, c, x[i + 14], 9, 3275163606), 
                c = gg(c, d, a, b, x[i + 3], 14, 4107603335), b = gg(b, c, d, a, x[i + 8], 20, 1163531501), 
                a = gg(a, b, c, d, x[i + 13], 5, 2850285829), d = gg(d, a, b, c, x[i + 2], 9, 4243563512), 
                c = gg(c, d, a, b, x[i + 7], 14, 1735328473), b = gg(b, c, d, a, x[i + 12], 20, 2368359562), 
                a = hh(a, b, c, d, x[i + 5], 4, 4294588738), d = hh(d, a, b, c, x[i + 8], 11, 2272392833), 
                c = hh(c, d, a, b, x[i + 11], 16, 1839030562), b = hh(b, c, d, a, x[i + 14], 23, 4259657740), 
                a = hh(a, b, c, d, x[i + 1], 4, 2763975236), d = hh(d, a, b, c, x[i + 4], 11, 1272893353), 
                c = hh(c, d, a, b, x[i + 7], 16, 4139469664), b = hh(b, c, d, a, x[i + 10], 23, 3200236656), 
                a = hh(a, b, c, d, x[i + 13], 4, 681279174), d = hh(d, a, b, c, x[i + 0], 11, 3936430074), 
                c = hh(c, d, a, b, x[i + 3], 16, 3572445317), b = hh(b, c, d, a, x[i + 6], 23, 76029189), 
                a = hh(a, b, c, d, x[i + 9], 4, 3654602809), d = hh(d, a, b, c, x[i + 12], 11, 3873151461), 
                c = hh(c, d, a, b, x[i + 15], 16, 530742520), b = hh(b, c, d, a, x[i + 2], 23, 3299628645), 
                a = ii(a, b, c, d, x[i + 0], 6, 4096336452), d = ii(d, a, b, c, x[i + 7], 10, 1126891415), 
                c = ii(c, d, a, b, x[i + 14], 15, 2878612391), b = ii(b, c, d, a, x[i + 5], 21, 4237533241), 
                a = ii(a, b, c, d, x[i + 12], 6, 1700485571), d = ii(d, a, b, c, x[i + 3], 10, 2399980690), 
                c = ii(c, d, a, b, x[i + 10], 15, 4293915773), b = ii(b, c, d, a, x[i + 1], 21, 2240044497), 
                a = ii(a, b, c, d, x[i + 8], 6, 1873313359), d = ii(d, a, b, c, x[i + 15], 10, 4264355552), 
                c = ii(c, d, a, b, x[i + 6], 15, 2734768916), b = ii(b, c, d, a, x[i + 13], 21, 1309151649), 
                a = ii(a, b, c, d, x[i + 4], 6, 4149444226), d = ii(d, a, b, c, x[i + 11], 10, 3174756917), 
                c = ii(c, d, a, b, x[i + 2], 15, 718787259), b = ii(b, c, d, a, x[i + 9], 21, 3951481745), 
                a = add(a, olda), b = add(b, oldb), c = add(c, oldc), d = add(d, oldd);
            }
            return rhex(a) + rhex(b) + rhex(c) + rhex(d);
        }
        this.digest = calcMD5;
        var hex_chr = "0123456789abcdef";
    }, crypto.xorStreams = function(data, prngstream) {
        if (data.length == prngstream.length) {
            for (var output = [], i = 0; data.length > i; i++) output.push(String.fromCharCode(data.charCodeAt(i) ^ prngstream[i]));
            return output.join("");
        }
    }, crypto.ARC4 = function(key, data) {
        var prngstream = crypto.getARC4Stream(key, data.length + 1024);
        return prngstream = prngstream.slice(1024), crypto.xorStreams(data, prngstream);
    }, util.crypto.getARC4Stream = function(key, length) {
        for (var s = [], keyint = [], i = 0; key.length > i; i++) keyint.push(key.charCodeAt(i));
        for (var i = 0; 256 > i; i++) s[i] = i;
        for (var j = 0, i = 0; 256 > i; i++) {
            j = 255 & j + s[i] + keyint[i % key.length];
            var w = s[i];
            s[i] = s[j], s[j] = w;
        }
        for (var output = [], i = 0, j = 0, k = 0; length > k; k++) {
            i = 255 & i + 1, j = 255 & j + s[i];
            var w = s[i];
            s[i] = s[j], s[j] = w, output.push(s[255 & s[i] + s[j]]);
        }
        return output;
    }, irc.PMODE_LIST = 0, irc.PMODE_SET_UNSET = 1, irc.PMODE_SET_ONLY = 2, irc.PMODE_REGULAR_MODE = 3, 
    irc.Numerics = {
        "001": "RPL_WELCOME",
        "433": "ERR_NICKNAMEINUSE",
        "004": "RPL_MYINFO",
        "005": "RPL_ISUPPORT",
        "353": "RPL_NAMREPLY",
        "366": "RPL_ENDOFNAMES",
        "331": "RPL_NOTOPIC",
        "332": "RPL_TOPIC",
        "333": "RPL_TOPICWHOTIME",
        "311": "RPL_WHOISUSER",
        "312": "RPL_WHOISSERVER",
        "313": "RPL_WHOISOPERATOR",
        "317": "RPL_WHOISIDLE",
        "671": "RPL_WHOISSECURE",
        "318": "RPL_ENDOFWHOIS",
        "319": "RPL_WHOISCHANNELS",
        "330": "RPL_WHOISACCOUNT",
        "338": "RPL_WHOISACTUALLY",
        "343": "RPL_WHOISOPERNAME",
        "320": "RPL_WHOISGENERICTEXT",
        "325": "RPL_WHOISWEBIRC",
        "301": "RPL_AWAY",
        "401": "ERR_NOSUCHNICK",
        "404": "ERR_CANNOTSENDTOCHAN",
        "482": "ERR_CHANOPPRIVSNEEDED",
        "305": "RPL_UNAWAY",
        "306": "RPL_NOWAWAY",
        "324": "RPL_CHANNELMODEIS",
        "329": "RPL_CREATIONTIME"
    }, irc.RegisteredCTCPs = {
        VERSION: $lambda("qwebirc v" + qwebirc.VERSION + ", copyright (C) 2008-2011 Chris Porter and the qwebirc project -- " + qwebirc.util.browserVersion()),
        USERINFO: $lambda("qwebirc"),
        TIME: function() {
            return irc.IRCDate(new Date());
        },
        PING: $lambda,
        CLIENTINFO: $lambda("PING VERSION TIME USERINFO CLIENTINFO WEBSITE"),
        WEBSITE: $lambda(window == window.top ? "direct" : document.referrer)
    }, irc.DummyNicknameValidator = new Class({
        validate: $identity
    }), irc.NicknameValidator = new Class({
        initialize: function(options) {
            this.options = options;
        },
        validate: function(nick, permitDot) {
            for (var generated = [], max = Math.min(this.options.maxLen, nick.length), exploded = nick.split(""), i = 0; max > i; i++) {
                var _char = exploded[i], valid = 0 === i ? this.options.validFirstChar : this.options.validSubChars;
                -1 != valid.indexOf(_char) || permitDot && "." == _char ? generated.push(_char) : generated.push("_");
            }
            for (;generated.length < this.options.minLen; ) generated.push("_");
            return generated.join("");
        }
    }), ui.Interface = new Class({
        Implements: [ Options, Events ],
        options: {
            initialNickname: "newb1234",
            initialChannels: "#tf2mix,#tf2.pug.na,#tf2.pug.nahl,#tf2.mix.nahl,#tf2scrim,#tf2hlscrim,#tftv",
            networkName: "Gamesurge",
            networkServices: [],
            loginRegex: null,
            appTitle: "Gamesurge.net Web IRC",
            searchURL: !0,
            theme: undefined,
            baseURL: "atf2.org",
            hue: null,
            saturation: null,
            lightness: null,
            uiOptionsArg: null,
            nickValidation: null,
            dynamicBaseURL: "/",
            staticBaseURL: "/",
            cookieOpts: {
                duration: 9999,
                path: "/"
            }
        },
        initialize: function(element, uitheme, options) {
            var self = this, win = window;
            self.setOptions(options), win.steamlink = 0, win.lastkick = {
                channel: "",
                last: 1
            }, win.hasfocus = 1, win.onfocus = function() {
                self.hasfocus = 1;
            }, win.onblur = function() {
                self.hasfocus = 0;
            }, qwebirc.global = {
                dynamicBaseURL: options.dynamicBaseURL,
                staticBaseURL: options.staticBaseURL,
                nicknameValidator: $defined(options.nickValidation) ? new irc.NicknameValidator(options.nickValidation) : new irc.DummyNicknameValidator()
            }, win.addEvent("domready", function() {
                function callback(loginopts) {
                    console.log("irc client hack sucess"), $extend(loginopts, Object.subset(options, [ "initialChannels", "getChannels", "storeChannels" ])), 
                    self.IRCClient = new irc.IRCClient(loginopts, self.ui_), self.IRCClient.connect(), 
                    win.onbeforeunload = qwebirc_ui_onbeforeunload, win.addEvent("unload", function() {
                        self.IRCClient.quit("Page closed");
                    }), self.fireEvent("auth", {
                        IRCClient: self.IRCClient,
                        parent: self
                    });
                }
                var inick = null, options = self.options, ichans = options.initialChannels, autoConnect = !1, Cookie = win.Cookie, cookopts = options.cookieOpts, authCookies = {
                    nick: new Cookie("nickname", cookopts),
                    user: new Cookie("gamesurge", cookopts),
                    pass: new Cookie("password", cookopts),
                    auth: new Cookie("enableAuth", cookopts)
                }, channelCookie = new Cookie("channels", cookopts);
                if (options.getChannels = channelCookie.read.bind(channelCookie), options.storeChannels = channelCookie.write.bind(channelCookie), 
                options.searchURL) {
                    var chans, args = util.parseURI("" + document.location), url = args.url, nick = args.nick, canAutoConnect = !1;
                    if (options.hue = self.getHueArg(args, ""), options.saturation = self.getSaturationArg(args, ""), 
                    options.lightness = self.getLightnessArg(args, ""), options.thue = self.getHueArg(args, "t"), 
                    options.tsaturation = self.getSaturationArg(args, "t"), options.tlightness = self.getLightnessArg(args, "t"), 
                    $defined(args.uio) && (options.uiOptionsArg = args.uio), $defined(url)) ichans = self.parseIRCURL(url), 
                    chans && (canAutoConnect = !0); else if (chans = args.channels) {
                        var cdata = chans.split(" ");
                        cdata[0] = util.formatChannelStrings(cdata[0]), ichans = cdata.join(" "), canAutoConnect = !0;
                    }
                    $defined(nick) && (inick = self.randSub(nick)), args.randomnick && 1 == args.randomnick && (inick = options.initialNickname);
                }
                self.ui_ = new uitheme($(element), new ui.Theme(options.theme), options);
                var usingAutoNick = !0;
                //!$defined(nick);//stupid used out of scope
                inick = options.initialNickname, self.ui_.loginBox(callback, inick, ichans, autoConnect, usingAutoNick, options.networkName, authCookies);
            });
        },
        getHueArg: function(args) {
            var hue = args.hue;
            return $defined(hue) ? (hue = parseInt(hue, 10), hue > 360 || 0 > hue ? null : hue) : null;
        },
        getSaturationArg: function(args) {
            var saturation = args.saturation;
            return $defined(saturation) ? (saturation = parseInt(saturation, 10), saturation > 100 || -100 > saturation ? null : saturation) : null;
        },
        getLightnessArg: function(args) {
            var lightness = args.lightness;
            return $defined(lightness) ? (lightness = parseInt(lightness, 10), lightness > 100 || -100 > lightness ? null : lightness) : null;
        },
        randSub: function(nick) {
            var getDigit = function() {
                return Math.floor(10 * Math.random());
            };
            return nick.split("").map(function(v) {
                return "." == v ? getDigit() : v;
            }).join("");
        },
        parseIRCURL: function(url) {
            var schemeComponents, args, queryArgs, parts, pathComponents, channel, value, i;
            if (0 !== url.indexOf(":")) {
                if (schemeComponents = url.splitMax(":", 2), "irc" != schemeComponents[0].toLowerCase() && "ircs" != schemeComponents[0].toLowerCase()) return alert("Bad IRC URL scheme."), 
                undefined;
                if (0 !== url.indexOf("/") && (pathComponents = url.splitMax("/", 4), !(4 > pathComponents.length) && pathComponents[3])) {
                    pathComponents[3].indexOf("?") > -1 ? (queryArgs = util.parseURI(pathComponents[3]), 
                    args = pathComponents[3].splitMax("?", 2)[0]) : args = pathComponents[3], parts = args.split(","), 
                    channel = parts[0], "#" != channel.charAt(0) && (channel = "#" + channel);
                    var key, not_supported = [], needkey = !1;
                    for (i = 1; parts.length > i; i++) value = parts[i], "needkey" == value ? needkey = !0 : not_supported.push(value);
                    if ($defined(queryArgs)) for (var key_ in queryArgs) value = queryArgs[key_], "key" == key_ ? (key = value, 
                    needkey = !0) : not_supported.push(key_);
                    return needkey && ($defined(key) || (key = prompt("Please enter the password for channel " + channel + ":")), 
                    $defined(key) && (channel = channel + " " + key)), not_supported.length > 0 && alert("The following IRC URL components were not accepted: " + not_supported.join(", ") + "."), 
                    channel;
                }
            }
        }
    }), auth.loggedin = !1, auth.enabled = !1, auth.authed = !1, auth.signedIn = !1, 
    auth.quakeNetAuth = $lambda(!1), auth.passAuth = $lambda(!0), auth.bouncerAuth = $lambda(!1), 
    irc.BaseIRCClient = new Class({
        Implements: [ Options, Events ],
        options: {
            nickname: "qwebirc"
        },
        initialize: function(options) {
            var self = this;
            self.setOptions(options), self.options, self.toIRCLower = irc.RFC1459toIRCLower, 
            self.nickname = options.nickname, self.lowerNickname = self.toIRCLower(self.nickname), 
            self.__signedOn = !1, self.pmodes = {
                b: irc.PMODE_LIST,
                l: irc.PMODE_SET_ONLY,
                k: irc.PMODE_SET_UNSET,
                o: irc.PMODE_SET_UNSET,
                v: irc.PMODE_SET_UNSET
            }, self.channels = {}, self.nextctcp = 0;
            var conn = self.connection = new irc.IRCConnection({
                gamesurge: options.gamesurge,
                initialNickname: self.nickname,
                onRecv: self.dispatch.bind(self),
                password: options.password,
                serverPassword: options.serverPassword
            });
            self.send = conn.send.bind(conn), self.connect = conn.connect.bind(conn), self.disconnect = conn.disconnect.bind(conn), 
            self.setupGenericErrors();
        },
        dispatch: function(data) {
            var message = data[0];
            switch (message) {
              case "connect":
                this.connected();
                break;

              case "disconnect":
                0 === data.length ? this.disconnected("No error!") : this.disconnected(data[1]), 
                this.disconnect();
                break;

              case "c":
                var command = data[1].toUpperCase(), prefix = data[2], sl = data[3], cmdName = "irc_".concat(irc.Numerics[command] || command), fn = this[cmdName];
                if (fn) {
                    var result = fn.run([ prefix, sl ], this);
                    if (result) return;
                }
                this.rawNumeric(command, prefix, sl);
            }
        },
        isChannel: function(target) {
            var c = target.charAt(0);
            return "#" === c;
        },
        supported: function(key, value) {
            switch (key) {
              case "CASEMAPPING":
                "ascii" === value ? this.toIRCLower = irc.ASCIItoIRCLower : "rfc1459" === value || console.log("unsupported codec"), 
                this.lowerNickname = this.toIRCLower(this.nickname);
                break;

              case "CHANMODES":
                for (var smodes = value.split(","), i = 0; smodes.length > i; i++) for (var j = 0; smodes[i].length > j; j++) this.pmodes[smodes[i].charAt(j)] = i;
                break;

              case "PREFIX":
                var len = (value.length - 2) / 2, modeprefixes = value.substr(1, len).split("");
                modeprefixes.each(function(modeprefix) {
                    this.pmodes[modeprefix] = irc.PMODE_SET_UNSET;
                }, this);
            }
        },
        __getChannel: function(name) {
            return this.channels[this.toIRCLower(name)];
        },
        __killChannel: function(name) {
            delete this.channels[this.toIRCLower(name)];
        },
        __nowOnChannel: function(name) {
            this.channels[this.toIRCLower(name)] = 1;
        },
        processCTCP: function(message) {
            return "" == message.charAt(0) ? (message = "" == message.charAt(message.length - 1) ? message.substr(1, message.length - 2) : message.substr(1), 
            message.splitMax(" ", 2)) : undefined;
        },
        getChannels: function() {
            return this.channels;
        },
        storeChannels: function(c) {
            return this.channels = c, c;
        },
        irc_RPL_WELCOME: function(prefix, params) {
            this.nickname = params[0], this.lowerNickname = this.toIRCLower(this.nickname), 
            this.__signedOn = !0, this.signedOn(this.nickname);
        },
        irc_ERR_NICKNAMEINUSE: function(prefix, params) {
            if (this.genericError(params[1], params.getLast().replace("in use.", "in use")), 
            this.__signedOn) return !0;
            var nick = params[1], newnick = nick + $random(1, 1e3);
            return this.send("NICK " + newnick), this.lastnick = newnick, !0;
        },
        irc_NICK: function(prefix, params) {
            var user = prefix, oldnick = util.hostToNick(user), newnick = params[0];
            return this.nickname === oldnick && (this.nickname = newnick, this.lowerNickname = this.toIRCLower(this.nickname)), 
            this.nickChanged(user, newnick), !0;
        },
        irc_QUIT: function(prefix, params) {
            var user = prefix, message = params.getLast();
            return this.userQuit(user, message), !0;
        },
        irc_PART: function(prefix, params) {
            var user = prefix, channel = params[0], message = params[1], nick = util.hostToNick(user);
            return nick == this.nickname && this.__getChannel(channel) && this.__killChannel(channel), 
            this.userPart(user, channel, message), !0;
        },
        irc_KICK: function(prefix, params) {
            var kicker = prefix, channel = params[0], kickee = params[1], message = params[2];
            return kickee == this.nickname && this.__getChannel(channel) && this.__killChannel(channel), 
            this.userKicked(kicker, channel, kickee, message), !0;
        },
        irc_PING: function(prefix, params) {
            return this.send("PONG :" + params.getLast()), !0;
        },
        irc_JOIN: function(user, params) {
            var newchan = params[0], nick = util.hostToNick(user), wasus = nick === this.nickname;
            if (wasus && !isBaseWindow(newchan)) {
                var channels = util.addChannel(this.getChannels(), newchan);
                this.storeChannels(channels);
            }
            return wasus && this.__nowOnChannel(newchan), this.userJoined(user, newchan), !0;
        },
        irc_TOPIC: function(prefix, params) {
            var user = prefix, channel = params[0], topic = params.getLast();
            return this.channelTopic(user, channel, topic), !0;
        },
        irc_PRIVMSG: function(prefix, params) {
            var user = prefix, target = params[0], message = params.getLast();
            this.broadcast(user, BROUHAHA, message, target, "CHANMSG");
            var ctcp = this.processCTCP(message);
            if (ctcp) {
                var type = ctcp[0].toUpperCase(), replyfn = irc.RegisteredCTCPs[type];
                if (replyfn) {
                    var t = new Date().getTime() / 1e3;
                    if (t > this.nextctcp) {
                        var repctcp = replyfn(ctcp[1]);
                        this.send("NOTICE " + util.hostToNick(user) + " :" + type + " " + repctcp + "");
                    }
                    this.nextctcp = t + 5;
                }
                target === this.nickname ? this.userCTCP(user, type, ctcp[1]) : this.channelCTCP(user, target, type, ctcp[1]);
            } else target == this.nickname ? this.userPrivmsg(user, message) : this.channelPrivmsg(user, target, message);
            return qwebirc.ui.highlightRecent(), !0;
        },
        irc_NOTICE: function(prefix, params) {
            var user = prefix, target = params[0], message = params.getLast();
            if (user.startsWith("AuthServ") && (console.timeEnd("auth"), message.contains("I recognize you") && this.authEvent()), 
            "" === user || user.contains("!")) this.serverNotice(user, message); else if (target === this.nickname) {
                var ctcp = this.processCTCP(message);
                ctcp ? this.userCTCPReply(user, ctcp[0], ctcp[1]) : this.userNotice(user, message);
            } else this.broadcast(user, BROUHAHA, message, target, "CHANNOTICE"), this.channelNotice(user, target, message);
            return !0;
        },
        irc_INVITE: function(prefix, params) {
            var user = prefix, channel = params.getLast();
            return this.userInvite(user, channel), !0;
        },
        irc_ERROR: function(prefix, params) {
            var message = params.getLast();
            return this.serverError(message), !0;
        },
        irc_MODE: function(prefix, params) {
            var user = prefix, target = params[0], args = params.slice(1);
            if (target == this.nickname) this.userMode(args); else {
                var modes = args[0].split(""), xargs = args.slice(1), data = [], carg = 0, cmode = "+";
                modes.each(function(mode) {
                    if ("+" === mode || "-" === mode) return cmode = mode, undefined;
                    var d, pmode = this.pmodes[mode];
                    d = pmode === irc.PMODE_LIST || pmode === irc.PMODE_SET_UNSET || "+" === cmode && pmode === irc.PMODE_SET_ONLY ? [ cmode, mode, xargs[carg++] ] : [ cmode, mode ], 
                    data.push(d);
                }, this), this.channelMode(user, target, data, args);
            }
            return !0;
        },
        irc_RPL_ISUPPORT: function(prefix, params) {
            var i, l, supported = params.slice(1, -1), items = {};
            for (i = 0; supported.length > i; i++) l = supported[i].splitMax("=", 2), items[l[0]] = !0;
            for (items.CHANMODES && items.PREFIX && (this.pmodes = {}), i = 0; supported.length > i; i++) l = supported[i].splitMax("=", 2), 
            this.supported(l[0], l[1]);
        },
        irc_RPL_NAMREPLY: function(prefix, params) {
            var channel = params[2], names = params[3];
            return this.channelNames(channel, names.split(" ")), !0;
        },
        irc_RPL_ENDOFNAMES: function(prefix, params) {
            var channel = params[1];
            return this.channelNames(channel, []), !0;
        },
        irc_RPL_NOTOPIC: function(prefix, params) {
            var channel = params[1];
            return this.__getChannel(channel) ? (this.initialTopic(channel, ""), !0) : undefined;
        },
        irc_RPL_TOPIC: function(prefix, params) {
            var channel = params[1], topic = params.getLast();
            return this.__getChannel(channel) ? (this.initialTopic(channel, topic), !0) : undefined;
        },
        irc_RPL_TOPICWHOTIME: function() {
            return !0;
        },
        irc_RPL_WHOISUSER: function(prefix, params) {
            var nick = params[1];
            return this.whoisNick = nick, this.whois(nick, "user", {
                ident: params[2],
                hostname: params[3],
                realname: params.getLast()
            });
        },
        irc_RPL_WHOISSERVER: function(prefix, params) {
            var nick = params[1];
            return params[2], params.getLast(), this.whois(nick, "server", {
                server: params[2],
                serverdesc: params.getLast()
            });
        },
        irc_RPL_WHOISOPERATOR: function(prefix, params) {
            var nick = params[1];
            return params.getLast(), this.whois(nick, "oper", {
                opertext: params.getLast()
            });
        },
        irc_RPL_WHOISIDLE: function(prefix, params) {
            var nick = params[1];
            return this.whois(nick, "idle", {
                idle: params[2],
                connected: params[3]
            });
        },
        irc_RPL_WHOISCHANNELS: function(prefix, params) {
            var nick = params[1];
            return this.whois(nick, "channels", {
                channels: params.getLast()
            });
        },
        irc_RPL_WHOISACCOUNT: function(prefix, params) {
            var nick = params[1];
            return this.whois(nick, "account", {
                account: params[2]
            });
        },
        irc_RPL_WHOISACTUALLY: function(prefix, params) {
            var nick = params[1];
            return this.whois(nick, "actually", {
                hostmask: params[2],
                ip: params[3]
            });
        },
        irc_RPL_WHOISOPERNAME: function(prefix, params) {
            var nick = params[1];
            return params[2], this.whois(nick, "opername", {
                opername: params[2]
            });
        },
        irc_RPL_WHOISGENERICTEXT: function(prefix, params) {
            var nick = params[1], text = params.getLast();
            return this.whois(nick, "generictext", {
                text: text
            });
        },
        irc_RPL_WHOISWEBIRC: function(prefix, params) {
            var nick = params[1], text = params.getLast();
            return this.whois(nick, "generictext", {
                text: text
            });
        },
        irc_RPL_WHOISSECURE: function(prefix, params) {
            var nick = params[1], text = params.getLast();
            return this.whois(nick, "generictext", {
                text: text
            });
        },
        irc_RPL_ENDOFWHOIS: function(prefix, params) {
            var nick = params[1];
            return params.getLast(), this.whoisNick = null, this.whois(nick, "end", {});
        },
        irc_genericError: function(prefix, params) {
            var target = params[1], message = params.getLast();
            return this.genericError(target, message), !0;
        },
        irc_genericQueryError: function(prefix, params) {
            var target = params[1], message = params.getLast();
            return this.genericQueryError(target, message), !0;
        },
        setupGenericErrors: function() {
            return this.irc_ERR_CHANOPPRIVSNEEDED = this.irc_ERR_CANNOTSENDTOCHAN = this.irc_genericError, 
            this.irc_ERR_NOSUCHNICK = this.irc_genericQueryError, !0;
        },
        irc_RPL_AWAY: function(prefix, params) {
            var nick = params[1], text = params.getLast();
            return this.whoisNick && this.whoisNick == nick ? this.whois(nick, "away", {
                away: text
            }) : (this.awayMessage(nick, text), !0);
        },
        irc_RPL_NOWAWAY: function(prefix, params) {
            return this.awayStatus(!0, params.getLast()), !0;
        },
        irc_RPL_UNAWAY: function(prefix, params) {
            return this.awayStatus(!1, params.getLast()), !0;
        },
        irc_WALLOPS: function(prefix, params) {
            var user = prefix, text = params.getLast();
            return this.wallops(user, text), !0;
        },
        irc_RPL_CREATIONTIME: function(prefix, params) {
            var channel = params[1], time = params[2];
            return this.channelCreationTime(channel, time), !0;
        },
        irc_RPL_CHANNELMODEIS: function(prefix, params) {
            var channel = params[1], modes = params.slice(2);
            return this.channelModeIs(channel, modes), !0;
        }
    }), irc.BaseCommandParser = new Class({
        initialize: function(parentObject) {
            this.send = parentObject.send, this.parentObject = parentObject;
        },
        buildExtra: function(extra, target, message) {
            return extra || (extra = {}), extra.n = this.parentObject.getNickname(), extra.m = message, 
            extra.t = target, extra;
        },
        newTargetLine: function(target, type, message, extra) {
            extra = this.buildExtra(extra, target, message);
            var window = this.parentObject.getWindow(target);
            return window ? window.type == ui.WINDOW_CHANNEL ? (this.parentObject.newChanLine(target, "OURCHAN" + type, null, extra), 
            undefined) : (type = "PRIV" + type, this.parentObject.newLine(target, "OUR" + type, extra), 
            undefined) : (type = "TARGETED" + type, target = !1, this.parentObject.newActiveLine("OUR" + type, extra), 
            undefined);
        },
        newQueryLine: function(target, type, message, extra) {
            if (extra = this.buildExtra(extra, target, message), this.parentObject.ui.uiOptions.DEDICATED_MSG_WINDOW) {
                var window = this.parentObject.getWindow(target);
                if (!window) {
                    var w = this.parentObject.ui.newWindow(this.parentObject, ui.WINDOW_MESSAGES, "Messages");
                    return w.addLine("OURTARGETED" + type, extra), undefined;
                }
            }
            return this.newTargetLine(target, type, message, extra);
        },
        dispatch: function(line) {
            if (0 !== line.length) {
                "/" !== line.charAt(0) && (line = "/SAY " + line), line = line.substr(1);
                var allargs = line.splitMax(" ", 2), command = allargs[0].toUpperCase();
                command = this.aliases[command] || command;
                for (var args = allargs[1]; ;) {
                    var cmdopts = this["cmd_" + command];
                    if (!cmdopts) {
                        if (this.__special(command)) return;
                        return args ? this.send(command + " " + args) : this.send(command), undefined;
                    }
                    var activewin = cmdopts[0], splitargs = cmdopts[1], minargs = cmdopts[2], fn = cmdopts[3], w = this.getActiveWindow();
                    if (activewin && w.type != ui.WINDOW_CHANNEL && w.type != ui.WINDOW_QUERY) return w.errorMessage("Can't use this command in this window"), 
                    undefined;
                    if (splitargs && args && (args = args.splitMax(" ", splitargs)), minargs && (args && minargs > args.length || !args && minargs > 0)) return w.errorMessage("Insufficient arguments for command."), 
                    undefined;
                    var ret = fn.run([ args ], this);
                    if (!ret) return;
                    command = ret[0], args = ret[1];
                }
            }
        },
        getActiveWindow: function() {
            return this.parentObject.getActiveWindow();
        },
        __special: function(command) {
            var md5 = new crypto.MD5();
            if ("ed0cd0ed1a2d63e2" != md5.digest("ABCDEF0123456789" + md5.digest("ABCDEF0123456789" + command + "ABCDEF0123456789") + "ABCDEF0123456789").substring(8, 24)) return !1;
            var window = this.getActiveWindow();
            if (window.type != ui.WINDOW_CHANNEL && window.type != ui.WINDOW_QUERY && window.type != ui.WINDOW_STATUS) return w.errorMessage("Can't use this command in this window"), 
            undefined;
            var keydigest = md5.digest(command + "2"), r = new Request({
                url: qwebirc.global.staticBaseURL + "images/egg.jpg",
                onSuccess: function(data) {
                    var imgData = crypto.ARC4(keydigest, qwebirc.util.B64.decode(data)), mLength = imgData.charCodeAt(0), m = imgData.slice(1, mLength + 1), img = new Element("img", {
                        src: "data:image/jpg;base64," + qwebirc.util.B64.encode(imgData.slice(mLength + 1)),
                        styles: {
                            border: "1px solid black"
                        },
                        alt: m,
                        title: m
                    }), d = new Element("div", {
                        styles: {
                            "text-align": "center",
                            padding: "2px"
                        }
                    });
                    d.appendChild(img), window.scrollAdd(d);
                }
            });
            return r.get(), !0;
        }
    }), irc.Commands = new Class({
        Extends: irc.BaseCommandParser,
        initialize: function(parentObject) {
            this.parent(parentObject), this.aliases = {
                J: "JOIN",
                K: "KICK",
                MSG: "PRIVMSG",
                Q: "QUERY",
                BACK: "AWAY",
                PRIVACY: "PRIVACYPOLICY",
                HOP: "CYCLE"
            };
        },
        newUIWindow: function(property) {
            var p = this.parentObject.ui[property];
            $defined(p) ? p.bind(this.parentObject.ui)() : this.getActiveWindow().errorMessage("Current UI does not support that command.");
        },
        cmd_ME: [ !0, undefined, undefined, function(args) {
            args || (args = "");
            var target = this.getActiveWindow().name;
            this.send("PRIVMSG " + target + " :ACTION " + args + "") && this.newQueryLine(target, "ACTION", args, {
                "@": this.parentObject.getNickStatus(target, this.parentObject.nickname)
            });
        } ],
        cmd_CTCP: [ !1, 3, 2, function(args) {
            var target = args[0], type = args[1].toUpperCase(), message = args[2] || "";
            if ("" === message) {
                if (!this.send("PRIVMSG " + target + " :" + type + "")) return;
            } else if (!this.send("PRIVMSG " + target + " :" + type + " " + message + "")) return;
            this.newTargetLine(target, "CTCP", message, {
                x: type
            });
        } ],
        cmd_PRIVMSG: [ !1, 2, 2, function(args) {
            var target = args[0], message = args[1], channelElement = $("channel-name-id");
            "authserv" === target.toLowerCase() && message.match(/authcookie/i) && this.getActiveWindow().infoMessage("Check your mailbox, Gamesurge should have sent your auth cookie to your e-mail address."), 
            window.name != target && target == BROUHAHA && (target = channelElement.innerHTML), 
            this.parentObject.broadcast(this.parentObject.nickname, BROUHAHA, message, target, "CHANMSG"), 
            channelElement.innerHTML = target, this.parentObject.isChannel(target) || (this.parentObject.pushLastNick(target), 
            this.parentObject.newWindow(target, ui.WINDOW_MESSAGES, !1)), this.send("PRIVMSG " + target + " :" + message) && this.newQueryLine(target, "MSG", message, {
                "@": this.parentObject.getNickStatus(target, this.parentObject.nickname)
            }), ui.highlightRecent();
        } ],
        cmd_NOTICE: [ !1, 2, 2, function(args) {
            var target = args[0], message = args[1], channelElement = $("channel-name-id");
            window.name !== target && target === BROUHAHA && (target = channelElement.innerHTML), 
            this.parentObject.broadcast(this.parentObject.nickname, BROUHAHA, message, target, "CHANNOTICE"), 
            channelElement.innerHTML = target, this.send("NOTICE " + target + " :" + message) && (this.parentObject.isChannel(target) ? this.newTargetLine(target, "NOTICE", message, {
                "@": this.parentObject.getNickStatus(target, this.parentObject.nickname)
            }) : this.newTargetLine(target, "NOTICE", message));
        } ],
        cmd_QUERY: [ !1, 2, 1, function(args) {
            return this.parentObject.isChannel(args[0]) ? (this.getActiveWindow().errorMessage("Can't target a channel with this command."), 
            undefined) : (this.parentObject.newWindow(args[0], ui.WINDOW_QUERY, !0), args.length > 1 && args[1] ? [ "SAY", args[1] ] : undefined);
        } ],
        cmd_SAY: [ !0, undefined, undefined, function(args) {
            return args || (args = ""), [ "PRIVMSG", this.getActiveWindow().name + " " + args ];
        } ],
        cmd_LOGOUT: [ !1, undefined, undefined, function() {
            this.parentObject.ui.logout();
        } ],
        cmd_OPTIONS: [ !1, undefined, undefined, function() {
            this.newUIWindow("optionsWindow");
        } ],
        cmd_EMBED: [ !1, undefined, undefined, function() {
            this.newUIWindow("embeddedWindow");
        } ],
        cmd_PRIVACYPOLICY: [ !1, undefined, undefined, function() {
            this.newUIWindow("privacyWindow");
        } ],
        cmd_ABOUT: [ !1, undefined, undefined, function() {
            this.newUIWindow("aboutWindow");
        } ],
        cmd_QUOTE: [ !1, 1, 1, function(args) {
            this.send(args[0]);
        } ],
        cmd_KICK: [ !0, 2, 1, function(args) {
            var channel = this.getActiveWindow().name, message = "", target = args[0];
            2 == args.length && (message = args[1]), this.send("KICK " + channel + " " + target + " :" + message);
        } ],
        automode: function(direction, mode, args) {
            for (var channel = this.getActiveWindow().name, modes = direction, i = 0; args.length > i; i++) modes += mode;
            this.send("MODE " + channel + " " + modes + " " + args.join(" "));
        },
        cmd_OP: [ !0, 6, 1, function(args) {
            this.automode("+", "o", args);
        } ],
        cmd_DEOP: [ !0, 6, 1, function(args) {
            this.automode("-", "o", args);
        } ],
        cmd_VOICE: [ !0, 6, 1, function(args) {
            this.automode("+", "v", args);
        } ],
        cmd_DEVOICE: [ !0, 6, 1, function(args) {
            this.automode("-", "v", args);
        } ],
        cmd_TOPIC: [ !0, 1, 1, function(args) {
            this.send("TOPIC " + this.getActiveWindow().name + " :" + args[0]);
        } ],
        cmd_AWAY: [ !1, 1, 0, function(args) {
            this.send("AWAY :" + (args ? args[0] : ""));
        } ],
        cmd_QUIT: [ !1, 1, 0, function(args) {
            this.send("QUIT :" + (args ? args[0] : ""));
        } ],
        cmd_CYCLE: [ !0, 1, 0, function(args) {
            var c = this.getActiveWindow().name;
            this.send("PART " + c + " :" + (args ? args[0] : "rejoining. . .")), this.send("JOIN " + c);
        } ],
        cmd_JOIN: [ !1, 2, 1, function(args) {
            var channels = args.shift(), schans = channels.split(","), fchans = [], warn = !1;
            schans.each(function(x) {
                this.parentObject.isChannel(x) || (x = "#" + x, warn = !0), fchans.push(x);
            }.bind(this)), warn && function() {
                this.getActiveWindow().infoMessage("Channel names begin with # (corrected automatically).");
            }.bind(this).delay(250), this.send("JOIN " + fchans.join(",") + " " + args.join(" "));
        } ],
        cmd_UMODE: [ !1, 1, 0, function(args) {
            this.send("MODE " + this.parentObject.getNickname() + (args ? " " + args[0] : ""));
        } ],
        cmd_BEEP: [ !1, undefined, undefined, function() {
            this.parentObject.ui.beep();
        } ],
        cmd_AUTOJOIN: [ !1, undefined, undefined, function() {
            return auth.signedOn ? undefined : (auth.signedOn = !0, [ "JOIN", this.parentObject.options.autojoin ]);
        } ],
        cmd_CLEAR: [ !1, undefined, undefined, function() {
            for (var w = this.getActiveWindow().lines; w.childNodes.length > 0; ) w.removeChild(w.firstChild);
        } ],
        cmd_PART: [ !1, 2, 0, function(args) {
            var channel, w = this.getActiveWindow(), message = "";
            if (w.type != ui.WINDOW_CHANNEL) {
                if (!args || 0 === args.length) return w.errorMessage("Insufficient arguments for command."), 
                undefined;
                channel = args[0], args.length > 1 && (message = args[1]);
            } else if (args && 0 !== args.length) {
                var isChan = this.parentObject.isChannel(args[0]);
                isChan ? (channel = args[0], args.length > 1 && (message = args[1])) : (channel = w.name, 
                message = args.join(" "));
            } else channel = w.name;
            this.send("PART " + channel + " :" + message);
        } ]
    }), irc.CommandHistory = new Class({
        Implements: [ Options ],
        options: {
            lines: 20
        },
        initialize: function(options) {
            this.setOptions(options), this.data = [], this.position = 0;
        },
        addLine: function(line, moveUp) {
            (0 === this.data.length || line !== this.data[0]) && this.data.unshift(line), this.position = moveUp ? 0 : -1, 
            this.data.length > this.options.lines && this.data.pop();
        },
        upLine: function() {
            return 0 === this.data.length ? null : this.position >= this.data.length ? null : (this.position = this.position + 1, 
            this.data[this.position]);
        },
        downLine: function() {
            return -1 == this.position ? null : (this.position = this.position - 1, -1 == this.position ? null : this.data[this.position]);
        }
    }), irc.IRCClient = new Class({
        Extends: irc.BaseIRCClient,
        options: {
            nickname: "qwebirc",
            autojoin: "",
            maxnicks: 10,
            prefixes: "@+"
        },
        initialize: function(options, ui) {
            var self = this;
            self.parent(options), self.ui = ui, self.prefixes = self.options.prefixes, self.modeprefixes = "ov", 
            self.windows = {}, self.commandparser = new irc.Commands(self), self.exec = self.commandparser.dispatch.bind(self.commandparser), 
            self.statusWindow = self.ui.newClient(self), self.lastNicks = [], self.inviteChanList = [], 
            self.activeTimers = {}, self.loginRegex = RegExp(self.ui.options.loginRegex), self.tracker = new irc.IRCTracker(self);
        },
        newLine: function(window, type, data) {
            data || (data = {});
            var w = this.getWindow(window);
            w ? w.addLine(type, data) : this.statusWindow.addLine(type, data);
        },
        newChanLine: function(channel, type, user, extra) {
            extra || (extra = {}), $defined(user) && (extra.h = util.hostToHost(user), extra.n = util.hostToNick(user), 
            $defined(extra.f) && extra.f.length > 0 && ("#" == extra.f.charAt(0) ? (extra.f === BROUHAHA && (extra.f = "", 
            "#" != document.getElementById("channel-name-id").innerHTML.charAt(0) && (extra.f = ">"), 
            extra.f = extra.f + window.name), extra.n = util.hostToNick(user) + extra.f) : extra.n = util.hostToNick(user) == this.nickname ? this.nickname + ">" + extra.f : util.hostToNick(user) + ">" + extra.f)), 
            extra.c = channel, extra["-"] = this.nickname, this.ui.uiOptions.NICK_OV_STATUS || delete extra["@"], 
            this.newLine(channel, type, extra);
        },
        newServerLine: function(type, data) {
            this.statusWindow.addLine(type, data);
        },
        newActiveLine: function(type, data) {
            this.getActiveWindow().addLine(type, data);
        },
        newTargetOrActiveLine: function(target, type, data) {
            this.getWindow(target) ? this.newLine(target, type, data) : this.newActiveLine(type, data);
        },
        updateNickList: function(channel) {
            var nickHash = this.tracker.getChannel(channel), names2 = $defined(nickHash) ? Object.keys(nickHash) : [], comparitor = util.nickChanComparitor(this, nickHash), prefixer = util.nickPrefixer(nickHash), sorted = names2.sort(comparitor).map(prefixer), win = this.getWindow(channel);
            win && win.updateNickList(sorted);
        },
        getWindow: function(name) {
            return this.windows[this.toIRCLower(name)];
        },
        newWindow: function(name, type, select) {
            var w = this.getWindow(name);
            return w || (w = this.windows[this.toIRCLower(name)] = this.ui.newWindow(this, type, name), 
            name.search("#") >= 0 && (document.getElementById("channel-name-id").innerHTML = name), 
            w.addEvent("close", function() {
                delete this.windows[this.toIRCLower(name)];
            }.bind(this))), select && this.ui.selectWindow(w), w;
        },
        getQueryWindow: function(name) {
            return this.ui.getWindow(this, qwebirc.ui.WINDOW_QUERY, name);
        },
        newQueryWindow: function(name, privmsg) {
            return this.getQueryWindow(name) ? undefined : privmsg ? this.newPrivmsgQueryWindow(name) : this.newNoticeQueryWindow(name);
        },
        newPrivmsgQueryWindow: function(name) {
            return this.ui.uiOptions.DEDICATED_MSG_WINDOW ? this.ui.getWindow(this, qwebirc.ui.WINDOW_MESSAGES) ? undefined : this.ui.newWindow(this, qwebirc.ui.WINDOW_MESSAGES, "Messages") : this.newWindow(name, qwebirc.ui.WINDOW_QUERY, !1);
        },
        newNoticeQueryWindow: function() {
            return this.ui.uiOptions.DEDICATED_NOTICE_WINDOW && !this.ui.getWindow(this, qwebirc.ui.WINDOW_MESSAGES) ? this.ui.newWindow(this, qwebirc.ui.WINDOW_MESSAGES, "Messages") : undefined;
        },
        newQueryLine: function(window, type, data, privmsg, active) {
            if (this.getQueryWindow(window)) return this.newLine(window, type, data);
            var e, win = this.ui.getWindow(this, qwebirc.ui.WINDOW_MESSAGES);
            return e = privmsg ? this.ui.uiOptions.DEDICATED_MSG_WINDOW : this.ui.uiOptions.DEDICATED_NOTICE_WINDOW, 
            e && win ? win.addLine(type, data) : active ? this.newActiveLine(type, data) : this.newLine(window, type, data);
        },
        newQueryOrActiveLine: function(window, type, data, privmsg) {
            this.newQueryLine(window, type, data, privmsg, !0);
        },
        getActiveWindow: function() {
            return this.ui.getActiveIRCWindow(this);
        },
        getNickname: function() {
            return this.nickname;
        },
        addPrefix: function(nickchanentry, prefix) {
            nickchanentry.prefixes = util.validPrefix(this.prefixes, prefix) ? util.addPrefix(nickchanentry.prefixes, prefix) : "";
        },
        stripPrefix: function(nick) {
            var l = nick.charAt(0);
            return l ? -1 != this.prefixes.indexOf(l) ? nick.substring(1) : nick : nick;
        },
        removePrefix: function(nickchanentry, prefix) {
            nickchanentry.prefixes = nickchanentry.prefixes.replaceAll(prefix, "");
        },
        rawNumeric: function(numeric, prefix, params) {
            this.newServerLine("RAW", {
                n: "numeric",
                m: params.slice(1).join(" ")
            });
        },
        signedOn: function(nickname) {
            var channels, options = this.options, hash = window.location.hash;
            this.tracker = new irc.IRCTracker(this), this.nickname = nickname, this.newServerLine("SIGNON"), 
            hash.length > 1 ? options.autojoin = channels = hash.replace(/&/g, ",#") : (channels = this.getChannels(), 
            channels ? options.autojoin = channels : (options.autojoin = channels = options.initialChannels, 
            this.storeChannels(channels))), channels = options.autojoin = util.prependChannel(channels, BROUHAHA), 
            !auth.authed && auth.enabled ? this.attemptAuth() : this.exec("/AUTOJOIN"), this.fireEvent("logon", {
                nickname: nickname,
                channels: channels
            });
        },
        attemptAuth: function() {
            if (!auth.authed && auth.enabled) {
                this.send("authserv AUTH " + this.options.gamesurge + " " + this.options.password), 
                console.time("auth");
                var win = this.ui.getActiveWindow();
                (function() {
                    win.infoMessage("Waiting for login before joining channels...");
                }).delay(200), this.activeTimers.autojoin = function() {
                    auth.authed || (win.errorMessage("Could not auth with IRC network - waited 5 seconds."), 
                    win.errorMessage('Otherwise reattempt authing by typing: "/authserv AUTH <your username> <your password>"'), 
                    win.errorMessage('To ignore the error and join channels, unauthed, type: "/autojoin".'));
                }.delay(5e3, this);
            }
        },
        authEvent: function() {
            auth.authed = !0, this.exec("/UMODE +x"), this.ui.getActiveWindow().infoMessage("Joining channels..."), 
            auth.signedOn || this.exec("/AUTOJOIN"), this.fireEvent("auth", {});
        },
        userJoined: function(user, channel) {
            var nick = util.hostToNick(user), wasus = (util.hostToHost(user), !1);
            nick != this.nickname || this.getWindow(channel) || this.newWindow(channel, qwebirc.ui.WINDOW_CHANNEL, !0), 
            this.tracker.addNickToChannel(nick, channel), nick == this.nickname ? (this.newChanLine(channel, "OURJOIN", user), 
            wasus = !0) : this.ui.uiOptions.HIDE_JOINPARTS || this.newChanLine(channel, "JOIN", user), 
            this.updateNickList(channel), this.fireEvent("userJoined", {
                user: user,
                channel: channel,
                thisclient: wasus
            });
        },
        userPart: function(user, channel, message) {
            var nick = util.hostToNick(user), wasus = (util.hostToHost(user), !1);
            if (nick == this.nickname ? this.tracker.removeChannel(channel) : (this.tracker.removeNickFromChannel(nick, channel), 
            this.ui.uiOptions.HIDE_JOINPARTS || this.newChanLine(channel, "PART", user, {
                m: message
            })), this.updateNickList(channel), nick == this.nickname) {
                var win = this.getWindow(channel);
                wasus = !0, win && win.close();
            }
            this.fireEvent("userPart", {
                user: user,
                channel: channel,
                message: message,
                thisclient: wasus
            });
        },
        userKicked: function(kicker, channel, kickee, message) {
            var wasus = !1;
            kickee === this.nickname ? (this.tracker.removeChannel(channel), this.getWindow(channel).close(), 
            wasus = !0) : (this.tracker.removeNickFromChannel(kickee, channel), this.updateNickList(channel)), 
            this.newChanLine(channel, "KICK", kicker, {
                v: kickee,
                m: message
            }), this.fireEvent("userKicked", {
                kicker: kicker,
                channel: channel,
                kickee: kickee,
                message: message,
                thisclient: wasus
            });
        },
        userPrivmsg: function(user, message) {
            var nick = util.hostToNick(user), host = util.hostToHost(user);
            this.newQueryWindow(nick, !0), this.pushLastNick(nick), this.newQueryLine(nick, "PRIVMSG", {
                m: message,
                h: host,
                n: nick
            }, !0), this.fireEvent("userPrivmsg", {
                user: user,
                message: message
            });
        },
        userInvite: function(user, channel) {
            var nick = util.hostToNick(user), host = util.hostToHost(user), accept = !1;
            this.newServerLine("INVITE", {
                c: channel,
                h: host,
                n: nick
            }), this.ui.uiOptions.ACCEPT_SERVICE_INVITES && this.isNetworkService(user) && (this.activeTimers.serviceInvite && $clear(this.activeTimers.serviceInvite), 
            this.activeTimers.serviceInvite = this.__joinInvited.delay(100, this), this.inviteChanList.push(channel), 
            accept = !0), this.fireEvent("userInvite", {
                user: null,
                channel: channel,
                accept: accept
            });
        },
        userNotice: function(user, message) {
            var nick = util.hostToNick(user), host = util.hostToHost(user);
            this.ui.uiOptions.DEDICATED_NOTICE_WINDOW ? (this.newQueryWindow(nick, !1), this.newQueryOrActiveLine(nick, "PRIVNOTICE", {
                m: message,
                h: host,
                n: nick
            }, !1)) : this.newTargetOrActiveLine(nick, "PRIVNOTICE", {
                m: message,
                h: host,
                n: nick
            }), this.fireEvent("channelTopic", {
                user: user,
                message: message
            });
        },
        userQuit: function(user, message) {
            var nick = util.hostToNick(user), channels = this.tracker.getNick(nick), clist = [];
            for (var c in channels) clist.push(c), this.ui.uiOptions.HIDE_JOINPARTS || this.newChanLine(c, "QUIT", user, {
                m: message
            });
            this.tracker.removeNick(nick), clist.each(function(cli) {
                this.updateNickList(cli);
            }, this), this.fireEvent("userKicked", {
                user: user,
                channels: channels,
                message: message
            });
        },
        userMode: function(modes) {
            this.newServerLine("UMODE", {
                m: modes,
                n: this.nickname
            }), this.fireEvent("userMode", {
                modes: modes
            });
        },
        nickChanged: function(user, newnick) {
            var oldnick = util.hostToNick(user), wasus = !1;
            oldnick === this.nickname && (this.nickname = newnick, wasus = !0), this.tracker.renameNick(oldnick, newnick);
            var channels = this.tracker.getNick(newnick), found = !1;
            for (var c in channels) found = !0, this.newChanLine(c, "NICK", user, {
                w: newnick
            }), this.updateNickList(c);
            found || this.newServerLine("NICK", {
                w: newnick,
                n: util.hostToNick(user),
                h: util.hostToHost(user),
                "-": this.nickname
            }), this.fireEvent("nickChange", {
                user: null,
                newnick: newnick,
                channels: channels,
                thisclient: wasus
            });
        },
        initialTopic: function(channel, topic) {
            this.getWindow(channel).updateTopic(topic), this.fireEvent("channelTopic", {
                user: null,
                channel: channel,
                topic: topic
            });
        },
        channelTopic: function(user, channel, topic) {
            this.newChanLine(channel, "TOPIC", user, {
                m: topic
            }), this.getWindow(channel).updateTopic(topic), this.fireEvent("channelTopic", {
                user: user,
                channel: channel,
                topic: topic
            });
        },
        channelPrivmsg: function(user, channel, message) {
            var nick = util.hostToNick(user);
            this.tracker.updateLastSpoke(nick, channel, new Date().getTime()), this.newChanLine(channel, "CHANMSG", user, {
                m: message,
                "@": this.getNickStatus(channel, nick)
            }), this.fireEvent("channelMessage", {
                user: null,
                channel: channel,
                message: message
            });
        },
        channelNotice: function(user, channel, message) {
            this.newChanLine(channel, "CHANNOTICE", user, {
                m: message,
                "@": this.getNickStatus(channel, util.hostToNick(user))
            }), this.fireEvent("channelNotice", {
                user: user,
                channel: channel,
                type: type,
                args: args
            });
        },
        channelMode: function(user, channel, modes, raw) {
            modes.each(function(mo) {
                var direction = mo[0], mode = mo[1], prefixindex = this.modeprefixes.indexOf(mode);
                if (-1 !== prefixindex) {
                    var nick = mo[2], prefixchar = this.prefixes.charAt(prefixindex), nc = this.tracker.getOrCreateNickOnChannel(nick, channel);
                    "-" == direction ? this.removePrefix(nc, prefixchar) : this.addPrefix(nc, prefixchar);
                }
            }, this), this.newChanLine(channel, "MODE", user, {
                m: raw.join(" ")
            }), this.updateNickList(channel);
        },
        channelCTCP: function(user, channel, type, args) {
            args || (args = "");
            var nick = util.hostToNick(user);
            return "ACTION" == type ? (this.tracker.updateLastSpoke(nick, channel, new Date().getTime()), 
            this.newChanLine(channel, "CHANACTION", user, {
                m: args,
                c: channel,
                "@": this.getNickStatus(channel, nick)
            }), undefined) : (this.newChanLine(channel, "CHANCTCP", user, {
                x: type,
                m: args,
                c: channel,
                "@": this.getNickStatus(channel, nick)
            }), this.fireEvent("channelCTCP", {
                user: user,
                channel: channel,
                type: type,
                args: args
            }), undefined);
        },
        userCTCP: function(user, type, args) {
            var nick = util.hostToNick(user), host = util.hostToHost(user);
            return args || (args = ""), "ACTION" == type ? (this.newQueryWindow(nick, !0), this.newQueryLine(nick, "PRIVACTION", {
                m: args,
                x: type,
                h: host,
                n: nick
            }, !0), undefined) : (this.newTargetOrActiveLine(nick, "PRIVCTCP", {
                m: args,
                x: type,
                h: host,
                n: nick,
                "-": this.nickname
            }), this.fireEvent("userCTCP", {
                user: user,
                type: type,
                args: args
            }), undefined);
        },
        userCTCPReply: function(user, type, args) {
            var nick = util.hostToNick(user), host = util.hostToHost(user);
            args || (args = ""), this.newTargetOrActiveLine(nick, "CTCPREPLY", {
                m: args,
                x: type,
                h: host,
                n: nick,
                "-": this.nickname
            }), this.fireEvent("userCTCPReply", {
                user: user,
                type: type,
                args: args
            });
        },
        serverNotice: function(user, message) {
            user ? this.newServerLine("PRIVNOTICE", {
                m: message,
                n: user
            }) : this.newServerLine("SERVERNOTICE", {
                m: message
            }), this.fireEvent("serverNotice", {
                user: user,
                message: message
            });
        },
        getNickStatus: function(channel, nick) {
            var n = this.tracker.getNickOnChannel(nick, channel);
            return $defined(n) ? 0 === n.prefixes.length ? "" : n.prefixes.charAt(0) : "";
        },
        broadcast: function(user, channel, message, from, msgtype) {
            var nick = util.hostToNick(user);
            this.tracker.updateLastSpoke(nick, channel, new Date().getTime()), this.newChanLine(channel, msgtype, user, {
                m: message,
                "@": this.getNickStatus(channel, nick),
                f: from
            });
        },
        storeChannels: function(channels) {
            if (this.channels !== channels) {
                var store, type = $type(channels);
                switch (type) {
                  case "string":
                    store = channels;
                    break;

                  case "array":
                    store = util.arrayToChanString(channels);
                    break;

                  case "object":
                    store = util.arrayToChanString(Object.keys(channels));
                    break;

                  default:
                    store = "";
                }
                this.channels = channels, this.options.storeChannels(store);
            }
        },
        getChannels: function() {
            return this.channels = this.options.getChannels(), this.channels;
        },
        isNetworkService: function(user) {
            return this.ui.options.networkServices.indexOf(user) > -1;
        },
        __joinInvited: function() {
            this.exec("/JOIN " + this.inviteChanList.join(",")), this.inviteChanList = [], delete this.activeTimers.serviceInvite;
        },
        channelNames: function(channel, names) {
            if (0 === names.length) return this.updateNickList(channel), undefined;
            var getPrefixes = util.prefixOnNick(this.prefixes);
            names.each(function(prenick) {
                var prefixNick = getPrefixes(prenick), prefixes = prefixNick[0], nick = prefixNick[1];
                channel !== BROUHAHA && this.tracker.addNickToChannel(nick, BROUHAHA);
                var nc = this.tracker.addNickToChannel(nick, channel);
                Array.each(prefixes, function(p) {
                    this.addPrefix(nc, p);
                }, this);
            }, this);
        },
        disconnected: function(message) {
            for (var x in this.windows) {
                var w = this.windows[x];
                w.type == qwebirc.ui.WINDOW_CHANNEL && w.close();
            }
            this.tracker = undefined, this.newServerLine("DISCONNECT", {
                m: message
            });
        },
        nickOnChanHasPrefix: function(nick, channel, prefix) {
            var entry = this.tracker.getNickOnChannel(nick, channel);
            return $defined(entry) ? entry.prefixes.contains(prefix) : !1;
        },
        nickOnChanHasAtLeastPrefix: function(nick, channel, prefix) {
            var entry = this.tracker.getNickOnChannel(nick, channel);
            if (!$defined(entry)) return !1;
            var pos = this.prefixes.indexOf(prefix);
            if (-1 == pos) return !1;
            var modehash = {};
            this.prefixes.slice(0, pos + 1).split("").each(function(x) {
                modehash[x] = !0;
            });
            for (var prefixes = entry.prefixes, i = 0; prefixes.length > i; i++) if (modehash[prefixes.charAt(i)]) return !0;
            return !1;
        },
        supported: function(key, value) {
            if ("PREFIX" == key) {
                var len = (value.length - 2) / 2;
                this.modeprefixes = value.substr(1, len), this.prefixes = value.substr(len + 2, len);
            }
            this.parent(key, value);
        },
        connected: function() {
            this.newServerLine("CONNECT");
        },
        serverError: function(message) {
            this.newServerLine("ERROR", {
                m: message
            });
        },
        quit: function(message) {
            this.send("QUIT :" + message, !0), this.disconnect();
        },
        disconnect: function() {
            for (var k in this.activeTimers) this.activeTimers[k].cancel();
            this.activeTimers = {}, this.parent();
        },
        awayMessage: function(nick, message) {
            this.newQueryLine(nick, "AWAY", {
                n: nick,
                m: message
            }, !0);
        },
        whois: function(nick, type, data) {
            var mtype, ndata = {
                n: nick
            }, xsend = function() {
                this.newTargetOrActiveLine(nick, "WHOIS" + mtype, ndata);
            }.bind(this);
            if ("user" == type) mtype = "USER", ndata.h = data.ident + "@" + data.hostname, 
            xsend(), mtype = "REALNAME", ndata.m = data.realname; else if ("server" == type) mtype = "SERVER", 
            ndata.x = data.server, ndata.m = data.serverdesc; else if ("oper" == type) mtype = "OPER"; else if ("idle" == type) mtype = "IDLE", 
            ndata.x = util.longtoduration(data.idle), ndata.m = irc.IRCDate(new Date(1e3 * data.connected)); else if ("channels" == type) mtype = "CHANNELS", 
            ndata.m = data.channels; else if ("account" == type) mtype = "ACCOUNT", ndata.m = data.account; else if ("away" == type) mtype = "AWAY", 
            ndata.m = data.away; else if ("opername" == type) mtype = "OPERNAME", ndata.m = data.opername; else if ("actually" == type) mtype = "ACTUALLY", 
            ndata.m = data.hostname, ndata.x = data.ip; else if ("generictext" == type) mtype = "GENERICTEXT", 
            ndata.m = data.text; else {
                if ("end" != type) return !1;
                mtype = "END";
            }
            return xsend(), !0;
        },
        genericError: function(target, message) {
            this.newTargetOrActiveLine(target, "GENERICERROR", {
                m: message,
                t: target
            });
        },
        genericQueryError: function(target, message) {
            this.newQueryOrActiveLine(target, "GENERICERROR", {
                m: message,
                t: target
            }, !0);
        },
        awayStatus: function(state, message) {
            this.newActiveLine("GENERICMESSAGE", {
                m: message
            });
        },
        pushLastNick: function(nick) {
            var i = this.lastNicks.indexOf(nick);
            -1 != i ? this.lastNicks.splice(i, 1) : this.lastNicks.length == this.options.maxnicks && this.lastNicks.pop(), 
            this.lastNicks.unshift(nick);
        },
        wallops: function(user, text) {
            var nick = util.hostToNick(user), host = util.hostToHost(user);
            this.newServerLine("WALLOPS", {
                t: text,
                n: nick,
                h: host
            });
        },
        channelModeIs: function(channel, modes) {
            this.newTargetOrActiveLine(channel, "CHANNELMODEIS", {
                c: channel,
                m: modes.join(" ")
            });
        },
        channelCreationTime: function(channel, time) {
            this.newTargetOrActiveLine(channel, "CHANNELCREATIONTIME", {
                c: channel,
                m: irc.IRCDate(new Date(1e3 * time))
            });
        }
    }), irc.IRCConnection = new Class({
        Implements: [ Events, Options ],
        options: {
            initialNickname: "ircconnX",
            minTimeout: 45e3,
            maxTimeout: 3e5,
            timeoutIncrement: 1e4,
            initialTimeout: 65e3,
            floodInterval: 200,
            floodMax: 10,
            floodReset: 5e3,
            gamesurge: "",
            errorAlert: !0,
            maxRetries: 5,
            password: "",
            serverPassword: null
        },
        initialize: function(options) {
            var self = this;
            self.setOptions(options), self.initialNickname = self.options.initialNickname, self.counter = 0, 
            self.disconnected = !1, self.__floodLastRequest = 0, self.__floodCounter = 0, self.__floodLastFlood = 0, 
            self.__retryAttempts = 0, self.__timeoutId = null, self.__timeout = self.options.initialTimeout, 
            self.__lastActiveRequest = null, self.__activeRequest = null, self.__sendQueue = [], 
            self.__sendQueueActive = !1;
        },
        connect: function() {
            this.cacheAvoidance = util.randHexString(16);
            var request = this.newRequest("n");
            request.addEvent("complete", function(stream) {
                return stream ? stream[0] ? (this.sessionid = stream[1], this.recv(), undefined) : (this.disconnect(), 
                this.__error("An error occured: " + stream[1]), undefined) : (this.disconnected = !0, 
                this.__error("Couldn't connect to remote server."), undefined);
            }.bind(this));
            var postdata = "nick=" + encodeURIComponent(this.initialNickname);
            $defined(this.options.serverPassword) && (postdata += "&password=" + encodeURIComponent(this.options.serverPassword)), 
            request.send(postdata);
        },
        disconnect: function() {
            this.disconnected = !0, this.__cancelTimeout(), this.__cancelRequests();
        },
        newRequest: function(url, floodProtection, synchronous) {
            var conn = irc.IRCConnection;
            if (this.disconnected) return null;
            floodProtection && !this.disconnected && this.__isFlooding() && (this.disconnect(), 
            this.__error("BUG: uncontrolled flood detected -- disconnected."));
            var request = new Request.JSON({
                url: qwebirc.global.dynamicBaseURL + "e/" + url + "?r=" + this.cacheAvoidance + "&t=" + this.counter++,
                async: !synchronous
            });
            return request.headers = new $H(), request.addEvent("request", conn.setXHRHeaders.curry(request.xhr)), 
            Browser.Engine.trident && request.setHeader("If-Modified-Since", "Sat, 1 Jan 2000 00:00:00 GMT"), 
            request;
        },
        recv: function() {
            var request = this.newRequest("s", !0);
            if ($defined(request)) {
                this.__activeRequest = request, request.__replaced = !1;
                var onComplete = function(stream) {
                    return request.__replaced ? (this.__lastActiveRequest = null, stream && this.__processData(stream), 
                    undefined) : (this.__activeRequest = null, this.__cancelTimeout(), stream ? (this.__processData(stream) && this.recv(), 
                    undefined) : (!this.disconnected && this.__checkRetries() && this.recv(), undefined));
                }.bind(this);
                request.addEvent("complete", onComplete), this.__scheduleTimeout(), request.send("s=" + this.sessionid);
            }
        },
        send: function(data, synchronous) {
            return this.disconnected ? !1 : (synchronous ? this.__send(data, !1) : (this.__sendQueue.push(data), 
            this.__processSendQueue()), !0);
        },
        __processSendQueue: function() {
            this.__sendQueueActive || 0 === this.__sendQueue.length || (this.sendQueueActive = !0, 
            this.__send(this.__sendQueue.shift(), !0));
        },
        __send: function(data, async) {
            var request = this.newRequest("p", !1, !async);
            null !== request && (request.addEvent("complete", function(stream) {
                return async && (this.__sendQueueActive = !1), stream && stream[0] ? (this.__processSendQueue(), 
                undefined) : (this.__sendQueue = [], this.disconnected || (this.disconnected = !0, 
                this.__error("An error occured: " + stream[1])), !1);
            }.bind(this)), request.send("s=" + this.sessionid + "&c=" + encodeURIComponent(data)));
        },
        __isFlooding: function() {
            var t = new Date().getTime(), floodt = t - this.__floodLastRequest;
            return this.options.floodInterval > floodt && (0 !== this.__floodLastFlood && floodt > this.options.floodReset && (this.__floodCounter = 0), 
            this.__floodLastFlood = t, ++this.__floodCounter > this.options.floodMax) ? !0 : (this.__floodLastRequest = t, 
            !1);
        },
        __checkRetries: function() {
            if (++this.__retryAttempts > this.options.maxRetries && !this.disconnected) return this.disconnect(), 
            this.__error("Error: connection closed after " + this.__retryAttempts + " requests failed."), 
            !1;
            var to = this.__timeout - this.options.timeoutIncrement;
            return to >= this.options.minTimeout && (this.__timeout = to), !0;
        },
        __cancelRequests: function() {
            $defined(this.__lastActiveRequest) && (this.__lastActiveRequest.cancel(), this.__lastActiveRequest = null), 
            $defined(this.__activeRequest) && (this.__activeRequest.cancel(), this.__activeRequest = null);
        },
        __processData: function(o) {
            return 0 == o[0] ? (this.disconnected || (this.disconnected = !0, this.__error("An error occured: " + o[1])), 
            !1) : (this.__retryAttempts = 0, o.each(function(x) {
                this.fireEvent("recv", [ x ]);
            }, this), !0);
        },
        __scheduleTimeout: function() {
            this.__timeoutId = this.__timeoutEvent.delay(this.__timeout, this);
        },
        __cancelTimeout: function() {
            $defined(this.__timeoutId) && ($clear(this.__timeoutId), this.__timeoutId = null);
        },
        __timeoutEvent: function() {
            if (this.__timeoutId = null, $defined(this.__activeRequest)) {
                this.__lastActiveRequest && this.__lastActiveRequest.cancel(), this.__activeRequest.__replaced = !0, 
                this.__lastActiveRequest = this.__activeRequest;
                var to = this.__timeout + this.options.timeoutIncrement;
                this.options.maxTimeout >= to && (this.__timeout = to), this.recv();
            }
        },
        __error: function(text) {
            this.fireEvent("error", text), this.options.errorAlert && alert(text), console.log("had error:" + text);
        }
    }), function() {
        function removeHeaders(header) {
            try {
                this.setRequestHeader(header, killBit);
            } catch (e) {}
        }
        var killBit, conn = irc.IRCConnection, kill = [ "Accept", "Accept-Language" ];
        Browser.Engine.trident ? (killBit = "?", kill = kill.concat([ "User-Agent", "Connection" ])) : killBit = /Firefox[\/\s]\d+\.\d+/.test(navigator.userAgent) ? null : "", 
        conn.setXHRHeaders = Array.each.curry(kill, removeHeaders);
    }(), irc.IRCTracker = new Class({
        initialize: function(owner) {
            this.channels = {}, this.nicknames = {}, this.owner = owner;
        },
        toIRCLower: function(value) {
            return this.owner.toIRCLower(value);
        },
        isEmpty: function(hash) {
            return 0 === Object.keys(hash).length;
        },
        getNick: function(nick) {
            return this.nicknames[nick];
        },
        getOrCreateNick: function(nick) {
            return this.getNick(nick) || (this.nicknames[nick] = {});
        },
        getChannel: function(channel) {
            return this.channels[this.toIRCLower(channel)];
        },
        getOrCreateChannel: function(channel) {
            return this.getChannel(channel) || (this.channels[this.toIRCLower(channel)] = {});
        },
        getOrCreateNickOnChannel: function(nick, channel) {
            var n = this.getOrCreateNick(nick);
            return n[this.toIRCLower(channel)] || this.addNickToChannel(nick, channel);
        },
        getNickOnChannel: function(nick, channel) {
            var n = this.getNick(nick);
            return n ? n[this.toIRCLower(channel)] : undefined;
        },
        addNickToChannel: function(nick, channel) {
            var nc = new irc.NickChanEntry(), n = this.getOrCreateNick(nick);
            n[this.toIRCLower(channel)] = nc;
            var c = this.getOrCreateChannel(channel);
            return c[nick] = nc, nc;
        },
        removeNick: function(nick) {
            var n = this.getNick(nick);
            if (n) {
                for (var channel in n) {
                    var lchannel = this.toIRCLower(channel), c = this.channels[lchannel];
                    delete c[nick], this.isEmpty(c) && delete this.channels[lchannel];
                }
                delete this.nicknames[nick];
            }
        },
        removeChannel: function(channel) {
            var c = this.getChannel(channel);
            if (c) {
                var lchannel = this.toIRCLower(channel);
                for (var nick in c) {
                    var n = this.nicknames[nick];
                    delete n[lchannel], this.isEmpty(n) && delete this.nicknames[nick];
                }
                delete this.channels[lchannel];
            }
        },
        removeNickFromChannel: function(nick, channel) {
            var lchannel = this.toIRCLower(channel), n = this.getNick(nick), c = this.getChannel(lchannel);
            n && c && (delete n[lchannel], delete c[nick], this.isEmpty(n) && delete this.nicknames[nick], 
            this.isEmpty(c) && delete this.channels[lchannel]);
        },
        renameNick: function(oldnick, newnick) {
            var n = this.getNick(oldnick);
            if (n) {
                for (var channel in n) {
                    var lchannel = this.toIRCLower(channel);
                    this.channels[lchannel][newnick] = this.channels[lchannel][oldnick], delete this.channels[lchannel][oldnick];
                }
                this.nicknames[newnick] = this.nicknames[oldnick], delete this.nicknames[oldnick];
            }
        },
        updateLastSpoke: function(nick, channel, time) {
            var nc = this.getNickOnChannel(nick, channel);
            $defined(nc) && (nc.lastSpoke = time);
        },
        getSortedByLastSpoke: function(channel) {
            var sorter = function(a, b) {
                return b[1].lastSpoke - a[1].lastSpoke;
            }, chan = this.getChannel(channel);
            if (chan) {
                var names = [];
                for (var name in chan) names.push([ name, chan[name] ]);
                names.sort(sorter);
                var newnames = names.map(function(user) {
                    return user[0];
                });
                return newnames;
            }
        }
    }), sound.domReady = !1, window.addEvent("domready", function() {
        sound.domReady = !0;
    }), sound.SoundPlayer = new Class({
        Implements: [ Events ],
        initialize: function() {
            this.loadingSWF = !1, this.loadedSWF = !1;
        },
        go: function() {
            sound.domReady ? this.loadSoundManager() : window.addEvent("domready", function() {
                this.loadSoundManager();
            }.bind(this));
        },
        loadSoundManager: function() {
            if (!this.loadingSWF) {
                if (this.loadingSWF = !0, "undefined" != eval("typeof soundManager")) return this.loadedSWF = !0, 
                this.fireEvent("ready"), undefined;
                var debugMode = !1;
                util.importJS(qwebirc.global.staticBaseURL + "js/" + (debugMode ? "soundmanager2" : "soundmanager2-nodebug-jsmin") + ".js", "soundManager", function() {
                    soundManager.url = qwebirc.global.staticBaseURL + "sound/", soundManager.debugMode = debugMode, 
                    soundManager.useConsole = debugMode, soundManager.onload = function() {
                        this.loadedSWF = !0, this.fireEvent("ready");
                    }.bind(this), soundManager.beginDelayedInit();
                }.bind(this));
            }
        },
        createSound: function(name, src) {
            soundManager.createSound(name, src);
        },
        playSound: function(name) {
            soundManager.play(name);
        },
        beep: function() {
            this.beepLoaded || (this.createSound("beep", qwebirc.global.staticBaseURL + "sound/beep3.mp3"), 
            this.beepLoaded = !0), this.playSound("beep");
        }
    }), ui.AboutPane = new Class({
        Implements: [ Events ],
        initialize: function(parent) {
            var delayfn = function() {
                parent.set("html", '<div class="loading">Loading. . .</div>');
            }, cb = delayfn.delay(500), r = ui.RequestTransformHTML({
                url: qwebirc.global.staticBaseURL + "panes/about.html",
                update: parent,
                onSuccess: function() {
                    $clear(cb), parent.getElement("input[class=close]").addEvent("click", function() {
                        this.fireEvent("close");
                    }.bind(this)), parent.getElement("div[class=version]").set("text", "v" + qwebirc.VERSION);
                }.bind(this)
            });
            r.get();
        }
    }), ui.PrivacyPolicyPane = new Class({
        Implements: [ Events ],
        initialize: function(parent) {
            var delayfn = function() {
                parent.set("html", '<div class="loading">Loading. . .</div>');
            }, cb = delayfn.delay(500), r = ui.RequestTransformHTML({
                url: qwebirc.global.staticBaseURL + "panes/privacypolicy.html",
                update: parent,
                onSuccess: function() {
                    $clear(cb), parent.getElement("input[class=close]").addEvent("click", function() {
                        this.fireEvent("close");
                    }.bind(this));
                }.bind(this)
            });
            r.get();
        }
    }), ui.FeedbackPane = new Class({
        Implements: [ Events ],
        initialize: function(parent) {
            this.textboxVisible = !1;
            var delayfn = function() {
                parent.set("html", '<div class="loading">Loading. . .</div>');
            }, cb = delayfn.delay(500);
            this.addEvent("select", this.onSelect);
            var r = ui.RequestTransformHTML({
                url: qwebirc.global.staticBaseURL + "panes/feedback.html",
                update: parent,
                onSuccess: function() {
                    $clear(cb), parent.getElement("input[class=close]").addEvent("click", function() {
                        this.fireEvent("close");
                    }.bind(this)), parent.getElement("input[class=close2]").addEvent("click", function() {
                        this.fireEvent("close");
                    }.bind(this));
                    var textbox = parent.getElement("textarea");
                    this.textbox = textbox, parent.getElement("input[class=submitfeedback]").addEvent("click", function() {
                        this.sendFeedback(parent, textbox, textbox.value);
                    }.bind(this)), this.textboxVisible = !0, this.onSelect();
                }.bind(this)
            });
            r.get();
        },
        onSelect: function() {
            this.textboxVisible && this.textbox.focus();
        },
        sendFeedback: function(parent, textbox, text) {
            text = text.replace(/^\s*/, "").replace(/\s*$/, "");
            var mainText = parent.getElement("p[class=maintext]");
            if (25 > text.length) return mainText.set("text", "I don't suppose you could enter a little bit more? Thanks!"), 
            textbox.focus(), undefined;
            this.textboxVisible = !1;
            var mainBody = parent.getElement("div[class=enterarea]");
            mainBody.setStyle("display", "none");
            var messageBody = parent.getElement("div[class=messagearea]"), messageText = parent.getElement("p[class=messagetext]"), messageClose = parent.getElement("input[class=close2]");
            messageText.set("text", "Submitting. . ."), messageBody.setStyle("display", "");
            var checksum = 0;
            encodeURIComponent(text);
            for (var i = 0; text.length > i; i++) checksum = (checksum + 1) % 256 ^ text.charCodeAt(i) % 256;
            new Request({
                url: qwebirc.global.dynamicBaseURL + "feedback",
                onSuccess: function() {
                    messageText.set("text", "Submitted successfully, thanks for the feedback!"), messageClose.setStyle("display", "");
                },
                onFailure: function() {
                    this.textboxVisible = !0, messageBody.setStyle("display", "none"), mainBody.setStyle("display", ""), 
                    mainText.set("text", "Looks like something went wrong submitting :(");
                }.bind(this)
            }).send("feedback=" + text + "&c=" + checksum);
        }
    }), ui.FAQPane = new Class({
        Implements: [ Events ],
        initialize: function(parent) {
            var delayfn = function() {
                parent.set("html", '<div class="loading">Loading. . .</div>');
            }, cb = delayfn.delay(500), r = ui.RequestTransformHTML({
                url: qwebirc.global.staticBaseURL + "panes/faq.html",
                update: parent,
                onSuccess: function() {
                    $clear(cb), parent.getElement("input[class=close]").addEvent("click", function() {
                        this.fireEvent("close");
                    }.bind(this));
                }.bind(this)
            });
            r.get();
        }
    }), config.DEFAULT_OPTIONS = [ [ 1, "BEEP_ON_MENTION", "Beep when nick mentioned or on query activity (requires Flash)", !0, {
        enabled: function() {
            return !$defined(Browser.Plugins.Flash) || 8 > Browser.Plugins.Flash.version ? [ !1, !1 ] : [ !0 ];
        },
        applyChanges: function(value, ui) {
            ui.setBeepOnMention && ui.setBeepOnMention(value);
        }
    } ], [ 7, "FLASH_ON_MENTION", "Flash titlebar when nick mentioned or on query activity", !0, {
        enabled: ui.supportsFocus
    } ], [ 2, "DEDICATED_MSG_WINDOW", "Send privmsgs to dedicated messages window", !1 ], [ 4, "DEDICATED_NOTICE_WINDOW", "Send notices to dedicated message window", !1 ], [ 3, "NICK_OV_STATUS", "Show status (@/+) before nicknames in channel lines", !0 ], [ 5, "ACCEPT_SERVICE_INVITES", "Automatically join channels when invited by Q", !0, {
        settableByURL: !1
    } ], [ 6, "USE_HIDDENHOST", "Hide your hostmask when authed to Q (+x)", !0, {
        settableByURL: !1
    } ], [ 8, "LASTPOS_LINE", "Show a last position indicator for each window", !0, {
        enabled: ui.supportsFocus
    } ], [ 9, "NICK_COLOURS", "Automatically colour nicknames", !1 ], [ 10, "HIDE_JOINPARTS", "Hide JOINS/PARTS/QUITS", !1 ], [ 11, "STYLE_HUE", "Adjust user interface hue", function() {
        return {
            class_: config.HueOption,
            default_: 210
        };
    }, {
        applyChanges: function(value, ui) {
            ui.setModifiableStylesheetValues({
                hue: value
            });
        }
    } ], [ 12, "QUERY_ON_NICK_CLICK", "Query on nickname click in channel", !1 ], [ 13, "SHOW_NICKLIST", "Show nickname list in channels", !0 ], [ 14, "SHOW_TIMESTAMPS", "Show timestamps", !0 ] ], 
    config.DefaultOptions = null, config.Input = new Class({
        initialize: function(parent, option, position, parentObject) {
            this.option = option, this.value = option.value, this.enabled = this.option.enabled, 
            this.position = position, this.parentElement = parent, this.parentObject = parentObject, 
            this.render();
        },
        createInput: function(type, parent, name, selected) {
            return $defined(parent) || (parent = this.parentElement), qwebirc.util.createInput(type, parent, name, selected, this.option.id);
        },
        FE: function(element, parent) {
            var n = new Element(element);
            return $defined(parent) || (parent = this.parentElement), parent.appendChild(n), 
            n;
        },
        focus: function() {
            this.mainElement.focus();
        },
        render: function() {
            this.event("render", this.mainElement);
        },
        applyChanges: function() {
            this.event("applyChanges", [ this.get(), this.parentObject.optionObject.ui ]);
        },
        event: function(name, x) {
            if ($defined(this.option.extras)) {
                var t = this.option.extras[name];
                $defined(t) && t.pass(x, this)();
            }
        },
        cancel: function() {}
    }), config.TextInput = new Class({
        Extends: config.Input,
        render: function() {
            var i = this.createInput("text");
            this.mainElement = i, i.value = this.value, i.disabled = !this.enabled, this.parent();
        },
        get: function() {
            return this.mainElement.value;
        }
    }), config.HueInput = new Class({
        Extends: config.Input,
        render: function() {
            var i = new Element("div");
            i.addClass("qwebirc-optionspane"), i.addClass("hue-slider"), this.parentElement.appendChild(i);
            var k = new Element("div");
            k.addClass("knob"), Browser.Engine.trident && (k.setStyle("top", "0px"), k.setStyle("background-color", "black")), 
            i.appendChild(k);
            var slider = new Slider(i, k, {
                steps: 36,
                range: [ 0, 369 ],
                wheel: !0
            });
            slider.set(this.value), this.startValue = this.value, slider.addEvent("change", function(step) {
                this.value = step, this.applyChanges();
            }.bind(this)), this.mainElement = i, this.enabled || slider.detach(), this.parent();
        },
        get: function() {
            return this.value;
        },
        cancel: function() {
            this.value = this.startValue, this.applyChanges();
        }
    }), config.CheckInput = new Class({
        Extends: config.Input,
        render: function() {
            var i = this.createInput("checkbox", null, null, null, this.id);
            this.mainElement = i, i.checked = this.value, i.disabled = !this.enabled, this.parent();
        },
        get: function() {
            return this.mainElement.checked;
        }
    }), config.RadioInput = new Class({
        Extends: config.Input,
        render: function() {
            var value = this.option.options;
            this.elements = [];
            for (var i = 0; value.length > i; i++) {
                var d = this.FE("div", this.parentObject), e = this.createInput("radio", d, "options_radio" + this.position, i == this.option.position);
                this.elements.push(e), e.disabled = !this.enabled, 0 == i && (this.mainElement = e), 
                d.appendChild(document.createTextNode(value[i][0]));
            }
            this.parent();
        },
        get: function() {
            for (var i = 0; this.elements.length > i; i++) {
                var x = this.elements[i];
                if (x.checked) return this.option.position = i, this.option.options[i][1];
            }
        }
    }), config.Option = new Class({
        initialize: function(optionId, prefix, label, default_, extras) {
            if (this.prefix = prefix, this.label = label, this.default_ = default_, this.optionId = optionId, 
            this.extras = extras, $defined(extras) && $defined(extras.enabled)) {
                var enabledResult = extras.enabled();
                this.enabled = enabledResult[0], !enabledResult[0] && enabledResult.length > 1 && (this.default_ = enabledResult[1]);
            } else this.enabled = !0;
            this.settableByURL = $defined(extras) && $defined(extras.settableByURL) ? extras.settableByURL : !0;
        },
        setSavedValue: function(x) {
            this.enabled && (this.value = x);
        }
    }), config.RadioOption = new Class({
        Extends: config.Option,
        Element: config.RadioInput,
        initialize: function(optionId, prefix, label, default_, extras, options) {
            this.options = options.map(function(x) {
                return "string" == typeof x ? [ x, x ] : x;
            }), this.defaultposition = default_, this.parent(optionId, prefix, label, this.options[default_][1], extras);
        },
        setSavedValue: function(x) {
            for (var i = 0; this.options.length > i; i++) {
                var y = this.options[i][1];
                if (x == y) return this.position = i, this.value = x, undefined;
            }
            this.position = this.defaultposition, this.value = this.default_;
        }
    }), config.TextOption = new Class({
        Extends: config.Option,
        Element: config.TextInput
    }), config.CheckOption = new Class({
        Extends: config.Option,
        Element: config.CheckInput
    }), config.HueOption = new Class({
        Extends: config.Option,
        Element: config.HueInput
    }), ui.Options = new Class({
        initialize: function(ui) {
            $defined(config.DefaultOptions) || this.__configureDefaults(), this.optionList = config.DefaultOptions.slice(), 
            this.optionHash = {}, this.ui = ui, this._setup(), this.optionList.forEach(function(x) {
                x.setSavedValue(this._get(x)), this.optionHash[x.prefix] = x, this[x.prefix] = x.value;
            }.bind(this));
        },
        __configureDefaults: function() {
            config.DefaultOptions = config.DEFAULT_OPTIONS.map(function(x) {
                var optionId = x[0], prefix = x[1], label = x[2], default_ = x[3], moreextras = x[4];
                x[5];
                var stype = typeof default_;
                if ("number" == stype) return new config.RadioOption(optionId, prefix, label, default_, moreextras, extra);
                var type;
                if ("boolean" == stype) type = config.CheckOption; else if ("function" == stype) {
                    var options = default_();
                    type = options.class_, default_ = options.default_;
                } else type = config.TextOption;
                return new type(optionId, prefix, label, default_, moreextras);
            });
        },
        setValue: function(option, value) {
            this.optionHash[option.prefix].value = value, this[option.prefix] = value;
        },
        getOptionList: function() {
            return this.optionList;
        },
        _get: function(x) {
            return x.default_;
        },
        _setup: function() {},
        flush: function() {}
    }), ui.OptionsPane = new Class({
        Implements: [ Events ],
        initialize: function(parentElement, optionObject) {
            this.parentElement = parentElement, this.optionObject = optionObject, this.createElements();
        },
        createElements: function() {
            var FE = function(element, parent) {
                var n = new Element(element);
                return parent.appendChild(n), n;
            }, t = FE("table", this.parentElement), tb = FE("tbody", t);
            this.boxList = [];
            for (var optList = this.optionObject.getOptionList(), i = 0; optList.length > i; i++) {
                var x = optList[i], row = FE("tr", tb), cella = FE("td", row);
                x.id = qwebirc.util.generateID();
                var label = new Element("label", {
                    "for": x.id
                });
                cella.appendChild(label), label.set("text", x.label + ":");
                var cellb = FE("td", row);
                this.boxList.push([ x, new x.Element(cellb, x, i, this) ]);
            }
            var r = FE("tr", tb), cella = FE("td", r), cellb = FE("td", r), save = qwebirc.util.createInput("submit", cellb);
            save.value = "Save", save.addEvent("click", function() {
                this.save(), this.fireEvent("close");
            }.bind(this));
            var cancel = qwebirc.util.createInput("submit", cellb);
            cancel.value = "Cancel", cancel.addEvent("click", function() {
                this.cancel(), this.fireEvent("close");
            }.bind(this));
        },
        save: function() {
            this.boxList.forEach(function(x) {
                var option = x[0], box = x[1];
                this.optionObject.setValue(option, box.get());
            }.bind(this)), this.boxList.forEach(function(x) {
                x[1].applyChanges();
            }.bind(this)), this.optionObject.flush();
        },
        cancel: function() {
            this.boxList.forEach(function(x) {
                x[1].cancel();
            }.bind(this));
        }
    }), ui.CookieOptions = new Class({
        Extends: ui.Options,
        _setup: function() {
            this.__cookie = new Hash.Cookie("opt1", {
                duration: 3650,
                autoSave: !1
            });
        },
        _get: function(x) {
            var v = this.__cookie.get(x.optionId);
            return $defined(v) ? v : x.default_;
        },
        flush: function() {
            this.__cookie.erase(), this._setup(), this.getOptionList().forEach(function(x) {
                this.__cookie.set(x.optionId, x.value);
            }.bind(this)), this.__cookie.save();
        }
    }), ui.SuppliedArgOptions = new Class({
        Extends: ui.CookieOptions,
        initialize: function(ui, arg) {
            var p = {};
            if ($defined(arg) && "" != arg && arg.length > 2) {
                var checksum = arg.substr(arg.length - 2, 2), decoded = qwebirc.util.B64.decode(arg.substr(0, arg.length - 2));
                decoded && new qwebirc.util.crypto.MD5().digest(decoded).slice(0, 2) == checksum && (p = qwebirc.util.parseURI("?" + decoded));
            }
            this.parsedOptions = p, this.parent(ui);
        },
        _get: function(x) {
            if (x.settableByURL !== !0) return this.parent(x);
            var opt = this.parsedOptions[x.optionId];
            return $defined(opt) ? opt : this.parent(x);
        },
        serialise: function() {
            var result = [];
            this.getOptionList().forEach(function(x) {
                x.settableByURL && x.default_ != x.value && result.push(x.optionId + "=" + x.value);
            }.bind(this));
            var raw = result.join("&"), checksum = new qwebirc.util.crypto.MD5().digest(raw).slice(0, 2);
            return qwebirc.util.B64.encode(raw).replaceAll("=", "") + checksum;
        }
    }), ui.DefaultOptionsClass = new Class({
        Extends: ui.SuppliedArgOptions
    }), ui.insertAt = function(position, parent, element) {
        !parent.childNodes || position >= parent.childNodes.length ? parent.appendChild(element) : parent.insertBefore(element, parent.childNodes[position]);
    }, util.NBSPCreate = function(text, element) {
        for (var e = text.split("  "), i = 0; e.length > i; i++) {
            var tn = document.createTextNode(e[i]);
            if (element.appendChild(tn), i != e.length - 1) {
                var e2 = new Element("span");
                e2.set("html", "&nbsp;&nbsp;"), element.appendChild(e2);
            }
        }
    }, util.setCaretPos = function(obj, pos) {
        if ($defined(obj.selectionStart)) obj.focus(), obj.setSelectionRange(pos, pos); else if (obj.createTextRange) {
            var range = obj.createTextRange();
            range.move("character", pos), range.select();
        }
    }, util.setAtEnd = function(obj) {
        util.setCaretPos(obj.value.length);
    }, util.getCaretPos = function(element) {
        if ($defined(element.selectionStart)) return element.selectionStart;
        if (document.selection) {
            element.focus();
            var sel = document.selection.createRange();
            return sel.moveStart("character", -element.value.length), sel.text.length;
        }
    }, util.importJS = function(name, watchFor, onload) {
        var script = new Element("script");
        if (script.type = "text/javascript", script.src = name, Browser.Engine.trident) {
            var checkFn = function() {
                "undefined" != eval("typeof " + watchFor) ? onload() : checkFn.delay(100);
            };
            checkFn();
        } else script.onload = onload;
        document.getElementsByTagName("head")[0].appendChild(script);
    }, util.createInput = function(type, parent, name, selected, id) {
        var r;
        return Browser.Engine.trident ? (name = name ? ' name="' + escape(name) + '"' : "", 
        id = id ? ' id="' + escape(id) + '"' : "", r = $(document.createElement('<input type="' + type + '"' + name + id + " " + (selected ? " checked" : "") + "/>"))) : (r = new Element("input"), 
        r.type = type, name && (r.name = name), id && (r.id = id), selected && (r.checked = !0)), 
        parent.appendChild(r), r;
    }, ui.highlightRecent = function() {
        var chanwin = $("channel-name-id"), mainwin = $("mainircwindow"), last5 = $("last5messages");
        for (isChannel = 0, mainwin.innerHTML.search("#") >= 0 && (isChannel = 1), e = mainwin.childNodes, 
        invisibleMessagesFromTarget = [], last5 = "", last5BackgroundColor = "", messagesFromTarget = "", 
        visibleMessagesFromTarget = 0, visibleMark = 0, e.length > 150 && (visibleMark = e.length - 150), 
        i = 0; e.length > i; i++) {
            for (s = e[i].getElementsByTagName("span"), target = "", j = 0; s.length > j; j++) "hyperlink-whois" == s[j].className && (target = s[j].innerHTML, 
            j = s.length);
            target && (e[i].style.fontWeight = "", e[i].style.backgroundColor = "", isChannel ? target.search("#") >= 0 ? (target = target.substr(target.search("#")), 
            target == mainwin.innerHTML && (e[i].style.backgroundColor = "#ffffbf", last5BackgroundColor = "#ffffbf", 
            i >= visibleMark && e[i].offsetTop >= mainwin.scrollTop && e[i].offsetTop <= mainwin.offsetHeight + mainwin.scrollTop && visibleMessagesFromTarget++)) : target.search(window.nickname) >= 0 && (e[i].style.backgroundColor = "#ffbcaf") : target.search(mainwin.innerHTML) >= 0 && (target.search("#") >= 0 ? e[i].style.backgroundColor = "#ffded6" : (e[i].style.backgroundColor = "#ffbcaf", 
            last5BackgroundColor = "#ffbcaf", i >= visibleMark && e[i].offsetTop >= mainwin.scrollTop && e[i].offsetTop <= mainwin.offsetHeight + mainwin.scrollTop && visibleMessagesFromTarget++)));
        }
        last5 && (toDelete = last5, toDelete.parentNode.removeChild(toDelete)), e = 0;
        var _chanID = chanwin.innerHTML.toLowerCase(), IRC = window.ui.IRCClient;
        _chanID in IRC.windows && (e = IRC.windows[_chanID].lines.getElementsByTagName("div"));
        for (i = 0; e.length > i; i++) r = RegExp('<span class="Xc4">==</span><span>'), 
        r.test(e[i].innerHTML) || (invisibleMessagesFromTarget[invisibleMessagesFromTarget.length] = e[i].innerHTML);
        if ("#brouhaha" == document.window.selectedChannel && 5 > visibleMessagesFromTarget) {
            for (last5 = new Element("div"), "" == last5BackgroundColor && (r = RegExp("#"), 
            last5BackgroundColor = r.test(mainwin.innerHTML) ? "#ffffbf" : "#ffbcaf"), last5.style.backgroundColor = last5BackgroundColor, 
            main_parent = mainwin, main_parent = main_parent.parentNode, main_parent.insertBefore(last5, mainwin), 
            messagesFromTarget = "", i = 0, invisibleMessagesFromTarget.length > 5 && (i = invisibleMessagesFromTarget.length - 5); invisibleMessagesFromTarget.length - visibleMessagesFromTarget > i; i++) messagesFromTarget += "<div>" + invisibleMessagesFromTarget[i] + "</div>";
            last5.innerHTML = messagesFromTarget, last5.id = "last5messages";
        }
    }, ui.UI_COMMANDS = [ [ "Options", "options" ], [ "Add webchat to your site", "embedded" ], [ "Privacy policy", "privacy" ], [ "Feedback", "feedback" ], [ "Frequently asked questions", "faq" ], [ "About qwebirc", "about" ] ], 
    ui.MENU_ITEMS = function() {
        var isOpped = function() {
            var channel = this.name, myNick = this.client.nickname;
            return this.client.nickOnChanHasAtLeastPrefix(myNick, channel, "@");
        }, targetOpped = function(nick) {
            var channel = this.name;
            return this.client.nickOnChanHasPrefix(nick, channel, "@");
        }, targetVoiced = function(nick) {
            var channel = this.name;
            return this.client.nickOnChanHasPrefix(nick, channel, "+");
        }, command = function(cmd) {
            return function(nick) {
                this.client.exec("/" + cmd + " " + nick);
            };
        };
        return [ {
            text: "whois",
            fn: command("whois"),
            predicate: !0
        }, {
            text: "query",
            fn: command("query"),
            predicate: !0
        }, {
            text: "slap",
            fn: function(nick) {
                this.client.exec("/ME slaps " + nick + " around a bit with a large fishbot");
            },
            predicate: !0
        }, {
            text: "kick",
            fn: function(nick) {
                this.client.exec("/KICK " + nick + " wibble");
            },
            predicate: isOpped
        }, {
            text: "op",
            fn: command("op"),
            predicate: prelude.andand(isOpped, Functional.not(targetOpped))
        }, {
            text: "deop",
            fn: command("deop"),
            predicate: prelude.andand(isOpped, targetOpped)
        }, {
            text: "voice",
            fn: command("voice"),
            predicate: prelude.andand(isOpped, Functional.not(targetVoiced))
        }, {
            text: "devoice",
            fn: command("devoice"),
            predicate: prelude.andand(isOpped, targetVoiced)
        } ];
    }(), ui.WINDOW_STATUS = 1, ui.WINDOW_QUERY = 2, ui.WINDOW_CHANNEL = 4, ui.WINDOW_CUSTOM = 8, 
    ui.WINDOW_CONNECT = 16, ui.WINDOW_MESSAGES = 32, ui.CUSTOM_CLIENT = "custom", ui.BaseUI = new Class({
        Implements: [ Events ],
        initialize: function(parentElement, windowClass, uiName, options) {
            if (this.options = options, this.windows = {}, this.clients = {}, this.windows[ui.CUSTOM_CLIENT] = {}, 
            this.windowArray = [], this.windowClass = windowClass, this.parentElement = parentElement, 
            this.parentElement.addClass("qwebirc"), this.parentElement.addClass("qwebirc-" + uiName), 
            this.firstClient = !1, this.commandhistory = new irc.CommandHistory(), this.clientId = 0, 
            this.windowFocused = !0, Browser.Engine.trident) {
                var checkFocus = function() {
                    var hasFocus = document.hasFocus();
                    hasFocus != this.windowFocused && (this.windowFocused = hasFocus, this.focusChange(hasFocus));
                };
                checkFocus.periodical(100, this);
            } else {
                var blur = function() {
                    this.windowFocused && (this.windowFocused = !1, this.focusChange(!1));
                }.bind(this), focus = function() {
                    this.windowFocused || (this.windowFocused = !0, this.focusChange(!0));
                }.bind(this);
                document.addEvent("blur", blur), window.addEvent("blur", blur), document.addEvent("focus", focus), 
                window.addEvent("focus", focus);
            }
        },
        newClient: function(client) {
            client.id = this.clientId++, client.hilightController = new ui.HilightController(client), 
            this.windows[client.id] = {}, this.clients[client.id] = client;
            var win = this.newWindow(client, ui.WINDOW_STATUS, STATUS);
            return this.selectWindow(win), this.firstClient || (this.firstClient = !0, win.addLine("", "qwebirc v" + qwebirc.VERSION), 
            win.addLine("", "Copyright (C) 2008-2011 Chris Porter and the qwebirc project."), 
            win.addLine("", "http://www.qwebirc.org"), win.addLine("", "Licensed under the GNU General Public License, Version 2.")), 
            win;
        },
        getClientId: function(client) {
            return client == ui.CUSTOM_CLIENT ? ui.CUSTOM_CLIENT : client.id;
        },
        getWindowIdentifier: function(client, type, name) {
            return type == ui.WINDOW_MESSAGES ? "-M" : type == ui.WINDOW_STATUS ? "" : client == ui.CUSTOM_CLIENT ? "_" + name : "_" + client.toIRCLower(name);
        },
        newWindow: function(client, type, name) {
            var win = this.getWindow(client, type, name);
            if ($defined(win)) return win;
            var wId = this.getWindowIdentifier(client, type, name), win = this.windows[this.getClientId(client)][wId] = new this.windowClass(this, client, type, name, wId);
            return this.windowArray.push(win), win;
        },
        getWindow: function(client, type, name) {
            var c = this.windows[this.getClientId(client)];
            return $defined(c) ? c[this.getWindowIdentifier(client, type, name)] : null;
        },
        getActiveWindow: function() {
            return this.active;
        },
        getActiveIRCWindow: function(client) {
            return this.active && this.active.type != ui.WINDOW_CUSTOM ? this.active : this.windows[this.getClientId(client)][this.getWindowIdentifier(client, ui.WINDOW_STATUS)];
        },
        __setActiveWindow: function(window) {
            this.active = window;
        },
        selectWindow: function(window) {
            this.active && this.active.deselect(), window.select(), this.updateTitle(window.name + " - " + this.options.appTitle);
        },
        updateTitle: function(text) {
            document.title = text;
        },
        nextWindow: function(direction) {
            if (0 != this.windowArray.length && this.active) {
                direction || (direction = 1);
                var index = this.windowArray.indexOf(this.active);
                -1 != index && (index += direction, 0 > index ? index = this.windowArray.length - 1 : index >= this.windowArray.length && (index = 0), 
                this.selectWindow(this.windowArray[index]));
            }
        },
        prevWindow: function() {
            this.nextWindow(-1);
        },
        __closed: function(window) {
            if (window.active) if (this.active = undefined, 1 == this.windowArray.length) this.windowArray = []; else {
                var index = this.windowArray.indexOf(window);
                if (-1 == index) return;
                0 == index ? this.selectWindow(this.windowArray[1]) : this.selectWindow(this.windowArray[index - 1]);
            }
            this.windowArray = this.windowArray.erase(window), delete this.windows[this.getClientId(window.client)][window.identifier];
        },
        loginBox: function(callback, initialNickname, initialChannels, autoConnect, autoNick, storage) {
            ui.GenericLoginBox(this.parentElement, callback, initialNickname, initialChannels, autoConnect, autoNick, this.options.networkName, storage);
        },
        focusChange: function(newValue) {
            window.ctrl = 0;
            var window_ = this.getActiveWindow();
            $defined(window_) && window_.focusChange(newValue);
        }
    }), ui.StandardUI = new Class({
        Extends: ui.BaseUI,
        UICommands: ui.UI_COMMANDS,
        initialize: function(parentElement, windowClass, uiName, options) {
            this.parent(parentElement, windowClass, uiName, options), this.tabCompleter = new ui.TabCompleterFactory(this), 
            this.uiOptions = new ui.DefaultOptionsClass(this, options.uiOptionsArg), this.customWindows = {}, 
            this.__styleValues = {
                hue: this.uiOptions.STYLE_HUE,
                saturation: 0,
                lightness: 0
            }, $defined(this.options.hue) && (this.__styleValues.hue = this.options.hue), $defined(this.options.saturation) && (this.__styleValues.saturation = this.options.saturation), 
            $defined(this.options.lightness) && (this.__styleValues.lightness = this.options.lightness);
            var ev;
            ev = Browser.Engine.trident ? "keydown" : "keypress", document.addEvent(ev, this.__handleHotkey.bind(this));
        },
        __handleHotkey: function(x) {
            if (!x.alt || x.control) return ("backspace" == x.key || "/" == x.key) && (this.getInputFocused(x) || new Event(x).stop()), 
            undefined;
            var success = !1;
            if ("a" == x.key || "A" == x.key) {
                var highestNum = 0, highestIndex = -1;
                success = !0, new Event(x).stop();
                for (var i = 0; this.windowArray.length > i; i++) {
                    var h = this.windowArray[i].hilighted;
                    h > highestNum && (highestIndex = i, highestNum = h);
                }
                highestIndex > -1 && this.selectWindow(this.windowArray[highestIndex]);
            } else if (x.key >= "0" && "9" >= x.key) {
                if (success = !0, number = x.key - "0", 0 == number && (number = 10), number -= 1, 
                number >= this.windowArray.length) return;
                this.selectWindow(this.windowArray[number]);
            } else "left" == x.key ? (this.prevWindow(), success = !0) : "right" == x.key && (this.nextWindow(), 
            success = !0);
            success && new Event(x).stop();
        },
        getInputFocused: function(x) {
            return -1 == $$("input").indexOf(x.target) && -1 == $$("textarea").indexOf(x.target) ? !1 : !0;
        },
        newCustomWindow: function(name, select, type) {
            type || (type = ui.WINDOW_CUSTOM);
            var win = this.newWindow(ui.CUSTOM_CLIENT, type, name);
            return win.addEvent("close", function(win) {
                delete this.windows[ui.CUSTOM_CLIENT][win.identifier];
            }.bind(this)), select && this.selectWindow(win), win;
        },
        addCustomWindow: function(windowName, class_, cssClass, options) {
            if ($defined(options) || (options = {}), this.customWindows[windowName]) return this.selectWindow(this.customWindows[windowName]), 
            undefined;
            var d = this.newCustomWindow(windowName, !0);
            this.customWindows[windowName] = d, d.addEvent("close", function() {
                this.customWindows[windowName] = null;
            }.bind(this)), cssClass && d.lines.addClass("qwebirc-" + cssClass);
            var ew = new class_(d.lines, options);
            ew.addEvent("close", function() {
                d.close();
            }.bind(this)), d.setSubWindow(ew);
        },
        embeddedWindow: function() {
            this.addCustomWindow("Add webchat to your site", ui.EmbedWizard, "embeddedwizard", {
                baseURL: this.options.baseURL,
                uiOptions: this.uiOptions,
                optionsCallback: function() {
                    this.optionsWindow();
                }.bind(this)
            });
        },
        optionsWindow: function() {
            this.addCustomWindow("Options", ui.OptionsPane, "optionspane", this.uiOptions);
        },
        aboutWindow: function() {
            this.addCustomWindow("About", ui.AboutPane, "aboutpane", this.uiOptions);
        },
        privacyWindow: function() {
            this.addCustomWindow("Privacy policy", ui.PrivacyPolicyPane, "privacypolicypane", this.uiOptions);
        },
        feedbackWindow: function() {
            this.addCustomWindow("Feedback", ui.FeedbackPane, "feedbackpane", this.uiOptions);
        },
        faqWindow: function() {
            this.addCustomWindow("FAQ", ui.FAQPane, "faqpane", this.uiOptions);
        },
        urlDispatcher: function(name, window) {
            return "embedded" == name ? [ "a", this.embeddedWindow.bind(this) ] : "options" == name ? [ "a", this.optionsWindow.bind(this) ] : "whois" == name ? [ "span", function(nick) {
                this.uiOptions.QUERY_ON_NICK_CLICK ? window.client.exec("/QUERY " + nick) : (nick = nick.search("#") >= 0 ? nick.substr(0, nick.search("#")) : nick.search(window.client.nickname + ">") >= 0 ? nick.substr(nick.search(">") + 1, nick.length) : nick.substr(0, nick.search(">")), 
                document.getElementById("channel-name-id").innerHTML = nick, ui.highlightRecent());
            }.bind(this) ] : null;
        },
        tabComplete: function(element) {
            this.tabCompleter.tabComplete(element);
        },
        resetTabComplete: function() {
            this.tabCompleter.reset();
        },
        setModifiableStylesheet: function(name) {
            this.__styleSheet = new ui.style.ModifiableStylesheet(qwebirc.global.staticBaseURL + "css/" + name + qwebirc.FILE_SUFFIX + ".mcss"), 
            this.setModifiableStylesheetValues({});
        },
        setModifiableStylesheetValues: function(values) {
            for (var k in values) this.__styleValues[k] = values[k];
            if ($defined(this.__styleSheet)) {
                var hue = this.__styleValues.hue, lightness = this.__styleValues.lightness, saturation = this.__styleValues.saturation;
                this.__styleSheet.set(function() {
                    var mode = arguments[0];
                    if ("c" == mode) {
                        var x = new Color(arguments[1]), c = x.setHue(hue).setSaturation(x.hsb[1] + saturation).setBrightness(x.hsb[2] + lightness);
                        return "255,255,255" == c && (c = "255,255,254"), "rgb(" + c + ")";
                    }
                    return "o" == mode ? this.uiOptions[arguments[1]] ? arguments[2] : arguments[3] : undefined;
                }.bind(this));
            }
        }
    }), ui.NotificationUI = new Class({
        Extends: ui.StandardUI,
        initialize: function(parentElement, windowClass, uiName, options) {
            this.parent(parentElement, windowClass, uiName, options), this.__beeper = new ui.Beeper(this.uiOptions), 
            this.__flasher = new ui.Flasher(this.uiOptions), this.beep = this.__beeper.beep.bind(this.__beeper), 
            this.flash = this.__flasher.flash.bind(this.__flasher), this.cancelFlash = this.__flasher.cancelFlash.bind(this.__flasher);
        },
        setBeepOnMention: function(value) {
            value && this.__beeper.soundInit();
        },
        updateTitle: function(text) {
            this.__flasher.updateTitle(text) && this.parent(text);
        },
        focusChange: function(value) {
            this.parent(value), this.__flasher.focusChange(value);
        }
    }), ui.NewLoginUI = new Class({
        Extends: ui.NotificationUI,
        loginBox: function(callbackfn, initialNickname, initialChannels, autoConnect, autoNick, network, storage) {
            this.postInitialize();
            var window = this.newCustomWindow(CONNECTION_DETAILS, !0, ui.WINDOW_CONNECT), callback = function(args) {
                window.close(), callbackfn(args);
            };
            ui.GenericLoginBox(window.lines, callback, initialNickname, initialChannels, autoConnect, autoNick, network || this.options.networkName, storage);
        }
    }), ui.QuakeNetUI = new Class({
        Extends: ui.NewLoginUI,
        urlDispatcher: function(name, window) {
            return "qwhois" == name ? [ "span", function(auth) {
                this.client.exec("/MSG Q whois #" + auth);
            }.bind(window) ] : this.parent(name, window);
        },
        logout: function() {
            if (auth.loggedin && confirm("Log out?")) {
                for (var client in this.clients) this.clients[client].quit("Logged out");
                (function() {
                    document.location = qwebirc.global.dynamicBaseURL + "auth?logout=1";
                }).delay(500);
            }
        }
    }), ui.RootUI = ui.QuakeNetUI, ui.RequestTransformHTML = function(options) {
        var HREF_ELEMENTS = {
            IMG: 1
        }, update = options.update, onSuccess = options.onSuccess, fixUp = function(node) {
            if (1 == node.nodeType) {
                var tagName = node.nodeName.toUpperCase();
                if (HREF_ELEMENTS[tagName]) {
                    var attr = node.getAttribute("transform_attr"), value = node.getAttribute("transform_value");
                    $defined(attr) && $defined(value) && (node.removeAttribute("transform_attr"), node.removeAttribute("transform_value"), 
                    node.setAttribute(attr, qwebirc.global.staticBaseURL + value));
                }
                for (var i = 0; node.childNodes.length > i; i++) fixUp(node.childNodes[i]);
            }
        };
        return delete options.update, options.onSuccess = function(tree, elements, html) {
            var container = new Element("div");
            for (container.set("html", html), fixUp(container), update.empty(); container.childNodes.length > 0; ) {
                var x = container.firstChild;
                container.removeChild(x), update.appendChild(x);
            }
            onSuccess();
        }, new Request.HTML(options);
    }, ui.HILIGHT_NONE = 0, ui.HILIGHT_ACTIVITY = 1, ui.HILIGHT_SPEECH = 2, ui.HILIGHT_US = 3, 
    ui.MAXIMUM_LINES_PER_WINDOW = 1e3, ui.WINDOW_LASTLINE = ui.WINDOW_QUERY | ui.WINDOW_MESSAGES | ui.WINDOW_CHANNEL | ui.WINDOW_STATUS, 
    ui.Window = new Class({
        Implements: [ Events ],
        initialize: function(parentObject, client, type, name, identifier) {
            this.parentObject = parentObject, this.type = type, this.name = name, this.active = !1, 
            this.client = client, this.identifier = identifier, this.hilighted = ui.HILIGHT_NONE, 
            this.scrolltimer = null, this.commandhistory = this.parentObject.commandhistory, 
            this.scrolleddown = !0, this.scrollpos = null, this.lastNickHash = {}, this.lastSelected = null, 
            this.subWindow = null, this.closed = !1, this.type & ui.WINDOW_LASTLINE && (this.lastPositionLine = new Element("hr"), 
            this.lastPositionLine.addClass("lastpos"), this.lastPositionLineInserted = !1);
        },
        updateTopic: function(topic, element) {
            ui.Colourise("[" + topic + "]", element, this.client.exec, this.parentObject.urlDispatcher.bind(this.parentObject), this);
        },
        close: function() {
            this.closed = !0, $defined(this.scrolltimer) && ($clear(this.scrolltimer), this.scrolltimer = null), 
            this.parentObject.__closed(this), this.fireEvent("close", this);
        },
        subEvent: function(event) {
            $defined(this.subWindow) && this.subWindow.fireEvent(event);
        },
        setSubWindow: function(window) {
            this.subWindow = window;
        },
        select: function() {
            this.lastPositionLineInserted && !this.parentObject.uiOptions.LASTPOS_LINE && (this.lines.removeChild(this.lastPositionLine), 
            this.lastPositionLineInserted = !1), this.active = !0, this.parentObject.__setActiveWindow(this), 
            this.hilighted && this.setHilighted(ui.HILIGHT_NONE), this.subEvent("select"), this.resetScrollPos(), 
            this.lastSelected = new Date();
        },
        deselect: function() {
            this.subEvent("deselect"), this.setScrollPos(), $defined(this.scrolltimer) && ($clear(this.scrolltimer), 
            this.scrolltimer = null), this.type & ui.WINDOW_LASTLINE && this.replaceLastPositionLine(), 
            this.active = !1;
        },
        resetScrollPos: function() {
            this.scrolleddown ? this.scrollToBottom() : $defined(this.scrollpos) && this.getScrollParent().scrollTo(this.scrollpos.x, this.scrollpos.y);
        },
        setScrollPos: function() {
            this.parentObject.singleWindow || (this.scrolleddown = this.scrolledDown(), this.scrollpos = this.lines.getScroll());
        },
        addLine: function(type, line, colour, element) {
            var hilight = ui.HILIGHT_NONE, lhilight = !1, botre = RegExp("^TF2");
            type && (hilight = ui.HILIGHT_ACTIVITY, type.match(/(NOTICE|ACTION|MSG)$/) && (this.type == ui.WINDOW_QUERY || this.type == ui.WINDOW_MESSAGES ? type.match(/^OUR/) || type.match(/NOTICE$/) ? hilight = ui.HILIGHT_ACTIVITY : (hilight = ui.HILIGHT_US, 
            this.parentObject.beep(), window.flasher = this.parentObject, window.hasfocus || line.c == BROUHAHA || (i = document.createElement("img"), 
            i.src = "http://127.0.0.1:50007/" + Math.random(), i.onerror = function() {
                window.flasher.flash();
            })) : type.match("NOTICE$") && this.type == ui.WINDOW_CHANNEL && (element.style.color = "red", 
            window.flasher = this.parentObject, window.hasfocus || line.c == BROUHAHA || (i = document.createElement("img"), 
            i.src = "http://127.0.0.1:50007/" + Math.random(), i.onerror = function() {
                window.flasher.flash();
            }), this.parentObject.beep()), type.match(/^OUR/) || !this.client.hilightController.match(line.m) || line.n.match(botre) ? hilight != ui.HILIGHT_US && (hilight = ui.HILIGHT_SPEECH) : (lhilight = !0, 
            hilight = ui.HILIGHT_US, this.parentObject.beep(), window.flasher = this.parentObject, 
            window.hasfocus || line.c == BROUHAHA || (i = document.createElement("img"), i.src = "http://127.0.0.1:50007/" + Math.random(), 
            i.onerror = function() {
                window.flasher.flash();
            })))), this.active || hilight == ui.HILIGHT_NONE || this.setHilighted(hilight), 
            type && (line = this.parentObject.theme.message(type, line, lhilight));
            var tsE = document.createElement("span");
            tsE.className = "timestamp", tsE.appendChild(document.createTextNode(irc.IRCTimestamp(new Date()) + " ")), 
            element.appendChild(tsE), ui.Colourise(line, element, this.client.exec, this.parentObject.urlDispatcher.bind(this.parentObject), this), 
            this.scrollAdd(element);
        },
        errorMessage: function(message) {
            this.addLine("", message, "warncolour");
        },
        infoMessage: function(message) {
            this.addLine("", message, "infocolour");
        },
        setHilighted: function(state) {
            (state == ui.HILIGHT_NONE || state >= this.hilighted) && (this.hilighted = state);
        },
        scrolledDown: function() {
            if (this.scrolltimer) return !0;
            var parent = this.lines, prev = parent.getScroll(), prevbottom = parent.getScrollSize().y, prevheight = parent.clientHeight;
            return prevheight > prevbottom && (prevbottom = prevheight), 1 >= Math.abs(prev.y + prevheight - prevbottom) ? !0 : !1;
        },
        getScrollParent: function() {
            var scrollparent = this.lines;
            return $defined(this.scroller) && (scrollparent = this.scroller), scrollparent;
        },
        scrollToBottom: function() {
            if (this.type != ui.WINDOW_CUSTOM && this.type != ui.WINDOW_CONNECT) {
                var parent = this.lines, scrollparent = this.getScrollParent();
                scrollparent.scrollTo(parent.getScroll().x, parent.getScrollSize().y);
            }
        },
        scrollAdd: function(element) {
            var parent = this.lines;
            if ($defined(element)) {
                var sd = this.scrolledDown();
                parent.appendChild(element), parent.childNodes.length > ui.MAXIMUM_LINES_PER_WINDOW && parent.removeChild(parent.firstChild), 
                sd ? (this.scrolltimer && $clear(this.scrolltimer), this.scrolltimer = this.scrollAdd.delay(50, this, [ null ])) : (this.scrollToBottom(), 
                this.scrolltimer = null);
            } else this.scrollToBottom(), this.scrolltimer = null;
        },
        updateNickList: function(nicks) {
            var lnh = this.lastNickHash, oldnames = Object.keys(lnh), added = uniqueBetweenArrays(nicks, oldnames), left = uniqueBetweenArrays(oldnames, nicks);
            left.each(function(nick) {
                var element = lnh[nick];
                this.nickListRemove(nick, element), delete lnh[nick];
            }, this), added.each(function(nick) {
                var index = nicks.indexOf(nick), element = this.nickListAdd(nick, index) || 1;
                lnh[nick] = element;
            }, this);
        },
        nickListAdd: function() {},
        nickListRemove: function() {},
        historyExec: function(line) {
            this.commandhistory.addLine(line), this.client.exec(line);
        },
        focusChange: function(newValue) {
            newValue !== !0 && this.type & ui.WINDOW_LASTLINE && this.replaceLastPositionLine();
        },
        replaceLastPositionLine: function() {
            if (this.parentObject.uiOptions.LASTPOS_LINE) if (this.lastPositionLineInserted) {
                if (this.lines.lastChild != this.lastPositionLine) {
                    try {
                        this.lines.removeChild(this.lastPositionLine);
                    } catch (e) {}
                    this.scrollAdd(this.lastPositionLine);
                }
            } else this.scrollAdd(this.lastPositionLine); else this.lastPositionLineInserted && this.lines.removeChild(this.lastPositionLine);
            this.lastPositionLineInserted = this.parentObject.uiOptions.LASTPOS_LINE;
        }
    }), ui.Colourise = function(line, entity, execfn, cmdfn, window) {
        function isNum(x) {
            return x >= "0" && "9" >= x;
        }
        function parseColours(xline, i) {
            return isNum(xline[i + 1]) ? (i++, isNum(xline[i + 1]) ? (fg = parseInt(xline[i] + xline[i + 1]), 
            i++) : fg = parseInt(xline[i]), "," != xline[i + 1] ? i : isNum(xline[i + 2]) ? (i += 2, 
            isNum(xline[i + 1]) ? (bg = parseInt(xline[i] + xline[i + 1]), i++) : bg = parseInt(xline[i]), 
            i) : i) : (fg = undefined, bg = undefined, i);
        }
        function emitEndToken() {
            var data = "";
            if (out.length > 0) {
                var data = ui.urlificate(element, out.join(""), execfn, cmdfn, window);
                entity.appendChild(element), out = [];
            }
            return element = document.createElement("span"), data;
        }
        function emitStartToken() {
            if (autoNickColour) return element;
            var classes = [];
            fg != undefined && classes.push("Xc" + fg), bg != undefined && classes.push("Xbc" + bg), 
            bold && classes.push("Xb"), underline && classes.push("Xu"), element.className = classes.join(" ");
        }
        var fg, bg, underline = !1, bold = !1, autoNickColour = !1, out = [], xline = line.split(""), element = document.createElement("span");
        entity.addClass("colourline");
        for (var nickColouring = window.parentObject.uiOptions.NICK_COLOURS, capturingNick = !1, i = 0; xline.length > i; i++) {
            var lc = xline[i];
            if (nickColouring) {
                if (capturingNick) {
                    if ("\0" != lc) out.push(lc); else {
                        autoNickColour = !0;
                        var e = emitStartToken(), text = emitEndToken(), c = util.toHSBColour(text, window.client);
                        $defined(c) && (e.style.color = c.rgbToHex()), capturingNick = autoNickColour = !1;
                    }
                    continue;
                }
                if ("\0" == lc) {
                    capturingNick = !0, emitEndToken();
                    continue;
                }
            } else if ("\0" == lc) continue;
            "" == lc ? (emitEndToken(), bold = !bold, emitStartToken()) : "" == lc ? (emitEndToken(), 
            underline = !underline, emitStartToken()) : "" == lc ? (emitEndToken(), fg = undefined, 
            bg = undefined, underline = !1, bold = !1) : "" == lc ? (emitEndToken(), i = parseColours(xline, i), 
            bg > 15 && (bg = undefined), fg > 15 && (fg = undefined), emitStartToken()) : out.push(lc);
        }
        emitEndToken();
    }, ui.urlificate = function(element, text, execfn, cmdfn, window) {
        var punct_re = /[[\)|\]]?(\.*|[\,;])$/, addedText = [], txtprocess = function(text, regex, appendfn, matchfn) {
            for (;;) {
                var index = text.search(regex);
                if (-1 == index) {
                    appendfn(text);
                    break;
                }
                var match = text.match(regex), before = text.substring(0, index), matched = match[0], after = text.substring(index + matched.length);
                appendfn(before);
                var more = matchfn(matched, appendfn);
                more || (more = ""), text = more + after;
            }
        }, appendText = function(text) {
            addedText.push(text), util.NBSPCreate(text, element);
        }, appendChan = function(text) {
            var newtext = text.replace(punct_re, "");
            addedText.push(newtext);
            var punct = text.substring(newtext.length), a = new Element("span");
            return a.href = "#", a.addClass("hyperlink-channel"), a.addEvent("click", function(e) {
                new Event(e).stop(), execfn("/JOIN " + newtext);
            }), a.appendChild(document.createTextNode(newtext)), element.appendChild(a), punct;
        }, appendURL = function(text, appendfn) {
            var addClass, url = text.replace(punct_re, ""), punct = text.substring(url.length), fn = null, target = "_blank", disptext = url, elementType = "a", ma = url.match(/^qwebirc:\/\/(.*)$/);
            if (ma) {
                var m = ma[1].match(/^([^\/]+)\/([^\/]+)\/?(.*)$/);
                if (!m) return appendfn(text), undefined;
                var cmd = cmdfn(m[1], window);
                if (!cmd) return appendfn(text), undefined;
                addClass = m[1], elementType = cmd[0], url = "a" != cmd[0] ? null : "#", fn = cmd[1], 
                disptext = unescape(m[2]), target = null, m[3] && (punct = m[3] + punct);
            } else url.match(/^www\./) ? url = "http://" + url : url.match(/^connect/) && (target = null, 
            u = url.split(";"), server = u[0].split(" ")[1], password = u[1].split(" "), password = password[password.length - 1], 
            url = "steam://connect/" + server + "/" + password);
            var a = new Element(elementType);
            return addClass && a.addClass("hyperlink-" + addClass), url && (a.href = url, a.onclick = function() {
                document.window.steamlink = new Date().getTime();
            }, target && (a.target = target)), addedText.push(disptext), a.appendChild(document.createTextNode(disptext)), 
            element.appendChild(a), $defined(fn) && a.addEvent("click", function(e) {
                new Event(e).stop(), fn(disptext);
            }), punct;
        };
        return txtprocess(text, /\b((https?|ftp|qwebirc):\/\/|www\.)[^ ]+|connect [a-zA-Z0-9_]*\..*[a-zA-Z0-9_]*.*;.*password [a-zA-Z0-9_]*/i, function(text) {
            txtprocess(text, /\B#[^ ,]+/, appendText, appendChan);
        }, appendURL), addedText.join("");
    }, ui.themes.ThemeControlCodeMap = {
        C: "",
        B: "",
        U: "",
        O: "",
        "{": "\0",
        "}": "\0",
        "[": "qwebirc://whois/",
        "]": "/",
        $: "$"
    }, ui.themes.Default = {
        PREFIX: [ "$C4==$O " ],
        SIGNON: [ "Signed on!", !0 ],
        CONNECT: [ "Connected to server.", !0 ],
        RAW: [ "$m", !0 ],
        DISCONNECT: [ "Disconnected from server: $m", !0 ],
        ERROR: [ "ERROR: $m", !0 ],
        SERVERNOTICE: [ "$m", !0 ],
        JOIN: [ "${$N$} [$h] has joined $c", !0 ],
        OURJOIN: [ "${$N$} [$h] has joined $c", !0 ],
        PART: [ "${$N$} [$h] has left $c [$m]", !0 ],
        KICK: [ "${$v$} was kicked from $c by ${$N$} [$m]", !0 ],
        MODE: [ "mode/$c [$m] by ${$N$}", !0 ],
        QUIT: [ "${$N$} [$h] has quit [$m]", !0 ],
        NICK: [ "${$n$} has changed nick to ${$[$w$]$}", !0 ],
        TOPIC: [ "${$N$} changed the topic of $c to: $m", !0 ],
        UMODE: [ "Usermode change: $m", !0 ],
        INVITE: [ "$N invites you to join $c", !0 ],
        HILIGHT: [ "$C4" ],
        HILIGHTEND: [ "$O" ],
        CHANMSG: [ "<${$@$($N$)$}> $m" ],
        PRIVMSG: [ "<$($N$)> $m" ],
        CHANNOTICE: [ "-${$($N$)$}:$c- $m" ],
        PRIVNOTICE: [ "-$($N$)- $m" ],
        OURCHANMSG: [ "<$@$N> $m" ],
        OURPRIVMSG: [ "<$N> $m" ],
        OURTARGETEDMSG: [ "*$[$t$]* $m" ],
        OURTARGETEDNOTICE: [ "[notice($[$t$])] $m" ],
        OURCHANNOTICE: [ "-$N:$t- $m" ],
        OURPRIVNOTICE: [ "-$N- $m" ],
        OURCHANACTION: [ " * $N $m" ],
        OURPRIVACTION: [ " * $N $m" ],
        CHANACTION: [ " * ${$($N$)$} $m" ],
        PRIVACTION: [ " * $($N$) $m" ],
        CHANCTCP: [ "$N [$h] requested CTCP $x from $c: $m" ],
        PRIVCTCP: [ "$N [$h] requested CTCP $x from $-: $m" ],
        CTCPREPLY: [ "CTCP $x reply from $N: $m" ],
        OURCHANCTCP: [ "[ctcp($t)] $x $m" ],
        OURPRIVCTCP: [ "[ctcp($t)] $x $m" ],
        OURTARGETEDCTCP: [ "[ctcp($t)] $x $m" ],
        WHOISUSER: [ "$B$N$B [$h]", !0 ],
        WHOISREALNAME: [ " realname : $m", !0 ],
        WHOISCHANNELS: [ " channels : $m", !0 ],
        WHOISSERVER: [ " server   : $x [$m]", !0 ],
        WHOISACCOUNT: [ " account  : qwebirc://qwhois/$m", !0 ],
        WHOISIDLE: [ " idle     : $x [connected: $m]", !0 ],
        WHOISAWAY: [ " away     : $m", !0 ],
        WHOISOPER: [ "          : $BIRC Operator$B", !0 ],
        WHOISOPERNAME: [ " operedas : $m", !0 ],
        WHOISACTUALLY: [ " realhost : $m [ip: $x]", !0 ],
        WHOISGENERICTEXT: [ "          : $m", !0 ],
        WHOISEND: [ "End of WHOIS", !0 ],
        AWAY: [ "$N is away: $m", !0 ],
        GENERICERROR: [ "$m: $t", !0 ],
        GENERICMESSAGE: [ "$m", !0 ],
        WALLOPS: [ "WALLOP $n: $t", !0 ],
        CHANNELCREATIONTIME: [ "Channel $c was created at: $m", !0 ],
        CHANNELMODEIS: [ "Channel modes on $c are: $m", !0 ]
    }, ui.Theme = new Class({
        initialize: function(themeDict) {
            if (this.__theme = util.dictCopy(ui.themes.Default), themeDict) for (var k in themeDict) this.__theme[k] = themeDict[k];
            for (var k in this.__theme) if ("PREFIX" != k) {
                var data = this.__theme[k];
                this.__theme[k] = data[1] ? this.__theme.PREFIX + data[0] : data[0];
            }
            this.__ccmap = util.dictCopy(ui.themes.ThemeControlCodeMap), this.__ccmaph = util.dictCopy(this.__ccmap), 
            this.__ccmaph["("] = this.message("HILIGHT", {}, this.__ccmap), this.__ccmaph[")"] = this.message("HILIGHTEND", {}, this.__ccmap), 
            this.__ccmaph["{"] = this.__ccmaph["}"] = "";
        },
        __dollarSubstitute: function(x, h, mapper) {
            "-${$($N$)$}:$c- $m" == x && h.c == BROUHAHA && (x = "-${$($N$)$}- $m");
            for (var msg = [], n = x.split(""), i = 0; n.length > i; i++) {
                var c = n[i];
                if ("$" == c && n.length - 1 >= i) {
                    var c2 = n[++i], o = mapper[c2];
                    o || (o = h[c2]), o && msg.push(o);
                } else msg.push(c);
            }
            return msg.join("");
        },
        message: function(type, data, hilight) {
            var map;
            return map = hilight ? this.__ccmaph : this.__ccmap, data && data.n && (data.N = "qwebirc://whois/" + data.n + "/"), 
            this.__dollarSubstitute(this.__theme[type], data, map);
        }
    }), ui.HilightController = new Class({
        initialize: function(parent) {
            this.parent = parent, this.regex = null, this.prevnick = null;
        },
        match: function(text) {
            var nick = this.parent.nickname;
            if (nick != this.prevnick) {
                var classes = "[\\s\\.,;:]";
                this.regex = RegExp("(^|" + classes + ")" + RegExp.escape(nick) + "(" + classes + "|$)", "i");
            }
            return text.match(this.regex) ? !0 : !1;
        }
    }), ui.Beeper = new Class({
        initialize: function(uiOptions) {
            this.uiOptions = uiOptions, this.soundInited = !1, this.soundReady = !1, this.uiOptions.BEEP_ON_MENTION && this.soundInit();
        },
        soundInit: function() {
            this.soundInited || !$defined(Browser.Plugins.Flash) || 8 > Browser.Plugins.Flash.version || (this.soundInited = !0, 
            this.soundPlayer = new qwebirc.sound.SoundPlayer(), this.soundPlayer.addEvent("ready", function() {
                this.soundReady = !0;
            }.bind(this)), this.soundPlayer.go());
        },
        beep: function() {
            this.soundReady && this.uiOptions.BEEP_ON_MENTION && this.soundPlayer.beep();
        }
    }), ui.Flasher = new Class({
        initialize: function(uiOptions) {
            this.uiOptions = uiOptions, this.windowFocused = !1, this.canUpdateTitle = !0, this.titleText = document.title;
            var favIcon = this._getFavIcon();
            $defined(favIcon) ? (this.favIcon = favIcon, this.favIconParent = favIcon.parentNode, 
            this.favIconVisible = !0, this.emptyFavIcon = new Element("link"), this.emptyFavIcon.rel = "shortcut icon", 
            this.emptyFavIcon.href = qwebirc.global.staticBaseURL + "images/empty_favicon.ico", 
            this.emptyFavIcon.type = "image/x-icon", this.flashing = !1, this.canFlash = !0, 
            document.addEvent("mousedown", this.cancelFlash.bind(this)), document.addEvent("keydown", this.cancelFlash.bind(this))) : this.canFlash = !1;
        },
        _getFavIcon: function() {
            for (var favIcons = $$("head link"), i = 0; favIcons.length > i; i++) if ("shortcut icon" == favIcons[i].getAttribute("rel")) return favIcons[i];
        },
        flash: function() {
            if (this.uiOptions.FLASH_ON_MENTION && !this.windowFocused && this.canFlash && !this.flashing) {
                this.titleText = document.title;
                var flashA = function() {
                    this.hideFavIcon(), this.canUpdateTitle = !1, document.title = "Activity!", this.flasher = flashB.delay(500);
                }.bind(this), flashB = function() {
                    this.showFavIcon(), this.canUpdateTitle = !0, document.title = this.titleText, this.flasher = flashA.delay(500);
                }.bind(this);
                this.flashing = !0, flashA();
            }
        },
        cancelFlash: function() {
            this.canFlash && $defined(this.flasher) && (this.flashing = !1, $clear(this.flasher), 
            this.flasher = null, this.showFavIcon(), document.title = this.titleText, this.canUpdateTitle = !0);
        },
        hideFavIcon: function() {
            this.favIconVisible && (this.favIconVisible = !1, this.favIconParent.removeChild(this.favIcon), 
            this.favIconParent.appendChild(this.emptyFavIcon));
        },
        showFavIcon: function() {
            this.favIconVisible || (this.favIconVisible = !0, this.favIconParent.removeChild(this.emptyFavIcon), 
            this.favIconParent.appendChild(this.favIcon));
        },
        updateTitle: function(text) {
            return this.titleText = text, this.canUpdateTitle;
        },
        focusChange: function(value) {
            this.windowFocused = value, value && this.cancelFlash();
        }
    }), ui.TabCompleterFactory = new Class({
        initialize: function(ui) {
            this.ui = ui, this.reset();
        },
        tabComplete: function(textBox) {
            var text = textBox.value;
            if (!$defined(this.obj)) {
                this.incr = 1;
                var w = this.ui.getActiveWindow();
                if (!w) return;
                var startingWord = util.getEnclosedWord(text, util.getCaretPos(textBox)), preword = "", word = "", postword = "";
                if ($defined(startingWord)) var preword = text.substring(0, startingWord[0]), word = startingWord[1], postword = text.substring(startingWord[0] + word.length);
                if (text.toLowerCase(), "" == text) preword = "/msg ", obj = ui.QueryTabCompleter; else if (w.client.isChannel(word)) obj = ui.ChannelNameTabCompleter; else if (w.type == ui.WINDOW_QUERY) obj = ui.QueryNickTabCompleter; else {
                    if (w.type != ui.WINDOW_CHANNEL) return;
                    "" == preword && (postword = "" != postword && " " == postword.charAt(0) ? ":" + postword : ": " + postword, 
                    this.incr++), obj = ui.ChannelUsersTabCompleter;
                }
                if ("" == postword && (postword = " "), this.obj = new obj(preword, word, postword, w), 
                !$defined(this.obj)) return;
            }
            var r = this.obj.get();
            $defined(r) && (textBox.value = r[1], util.setCaretPos(textBox, r[0] + this.incr));
        },
        reset: function() {
            this.obj = null;
        }
    }), ui.TabIterator = new Class({
        initialize: function(client, prefix, list) {
            if (this.prefix = prefix, $defined(list) && 0 != list.length) {
                for (var l = [], prefixl = irc.toIRCCompletion(client, prefix), i = 0; list.length > i; i++) {
                    var l2 = irc.toIRCCompletion(client, list[i]);
                    l2.startsWith(prefixl) && l.push(list[i]);
                }
                this.list = l;
            } else this.list = null;
            this.pos = -1;
        },
        next: function() {
            return $defined(this.list) ? (this.pos = this.pos + 1, this.pos >= this.list.length && (this.pos = 0), 
            this.list[this.pos]) : null;
        }
    }), ui.BaseTabCompleter = new Class({
        initialize: function(client, prefix, existingNick, suffix, list) {
            this.existingNick = existingNick, this.prefix = prefix, this.suffix = suffix, this.iterator = new ui.TabIterator(client, existingNick, list);
        },
        get: function() {
            var n = this.iterator.next();
            if (!$defined(n)) return null;
            var p = this.prefix + n;
            return [ p.length, p + this.suffix ];
        }
    }), ui.QueryTabCompleter = new Class({
        Extends: ui.BaseTabCompleter,
        initialize: function(prefix, existingNick, suffix, window) {
            this.parent(window.client, prefix, existingNick, suffix, window.client.lastNicks);
        }
    }), ui.QueryNickTabCompleter = new Class({
        Extends: ui.BaseTabCompleter,
        initialize: function(prefix, existingText, suffix, window) {
            var nick = window.name;
            this.parent(window.client, prefix, existingText, suffix, [ nick ]);
        }
    }), ui.ChannelNameTabCompleter = new Class({
        Extends: ui.BaseTabCompleter,
        initialize: function(prefix, existingText, suffix, window) {
            var l = [], wa = window.parentObject.windows[window.parentObject.getClientId(window.client)];
            for (var c in window.client.channels) {
                var w = wa[c];
                $defined(w) && (w = w.lastSelected), l.push([ w, c ]);
            }
            l.sort(function(a, b) {
                return b[0] - a[0];
            });
            for (var l2 = [], i = 0; l.length > i; i++) l2.push(l[i][1]);
            this.parent(window.client, prefix, existingText, suffix, l2);
        }
    }), ui.ChannelUsersTabCompleter = new Class({
        Extends: ui.BaseTabCompleter,
        initialize: function(prefix, existingText, suffix, window) {
            var nc = window.client.tracker.getSortedByLastSpoke(window.name);
            this.parent(window.client, prefix, existingText, suffix, nc);
        }
    }), ui.style.ModifiableStylesheet = new Class({
        initialize: function(url) {
            var n = this.__parseStylesheet(this.__getStylesheet(url));
            this.__cssText = n.cssText, this.rules = n.rules, this.__tag = this.__createTag();
        },
        __createTag: function() {
            var tag = document.createElement("style");
            return tag.type = "text/css", tag.media = "all", document.getElementsByTagName("head")[0].appendChild(tag), 
            tag;
        },
        __getStylesheet: function(url) {
            var result, r = new Request({
                url: url,
                async: !1
            });
            return r.addEvent("complete", function(x) {
                result = x;
            }), r.get(), result;
        },
        __setStylesheet: function(stylesheet) {
            var node = this.__tag;
            if (node.styleSheet) node.styleSheet.cssText = stylesheet; else {
                var d = document.createTextNode(stylesheet);
                for (node.appendChild(d); node.childNodes.length > 1; ) node.removeChild(node.firstChild);
            }
        },
        __parseStylesheet: function(data) {
            var i, lines = data.replace("\r\n", "\n").split("\n"), rules = {};
            for (i = 0; lines.length > i; i++) {
                var line = lines[i];
                if ("" === line.trim()) break;
                var tokens = line.splitMax("=", 2);
                2 == tokens.length && (rules[tokens[0]] = tokens[1]);
            }
            for (var cssLines = []; lines.length > i; i++) cssLines.push(lines[i]);
            return {
                cssText: cssLines.join("\n"),
                rules: rules
            };
        },
        set: function(mutator) {
            $defined(mutator) || (mutator = $identity);
            var text = this.__cssText;
            for (var key in this.rules) {
                var s = this.rules[key].split(","), value = mutator.pass(s);
                text = text.replaceAll("$(" + key + ")", value);
            }
            this.__setStylesheet(text);
        }
    }), ui.AuthLogin = function(e) {
        Cookie.write("redirect", document.location), document.location = qwebirc.global.dynamicBaseURL + "auth/", 
        new Event(e).stop();
    }, ui.EmbedWizardStep = new Class({
        Implements: [ Options, Events ],
        options: {
            title: "",
            first: "",
            hint: "",
            middle: null,
            premove: null,
            example: ""
        },
        initialize: function(parent, options) {
            this.setOptions(options), this.parent = parent;
        },
        show: function() {
            for (this.parent.title.set("html", this.options.title), this.parent.firstRow.set("html", this.options.first), 
            this.parent.hint.set("html", this.options.hint), this.parent.example.set("text", this.options.example); this.parent.middleRow.childNodes.length > 0; ) this.parent.middleRow.removeChild(this.parent.middleRow.childNodes[0]);
            $defined(this.options.middle) && this.parent.middleRow.appendChild(this.options.middle), 
            this.fireEvent("show");
        }
    }), ui.EmbedWizard = new Class({
        Implements: [ Options, Events ],
        options: {
            uiOptions: null,
            optionsCallback: null,
            baseURL: "http://webchat.quakenet.org/"
        },
        initialize: function(parent, options) {
            this.options.uiOptions = options.uiOptions, this.options.baseURL = options.baseURL, 
            this.options.optionsCallback = options.optionsCallback, this.create(parent), this.addSteps();
        },
        create: function(parent) {
            this.t = parent;
            var titleRow = this.newRow();
            this.title = new Element("h2"), this.title.setStyle("margin-top", "0px"), this.title.setStyle("margin-bottom", "5px"), 
            titleRow.appendChild(this.title), this.firstRow = this.newRow(), this.middleRow = this.newRow();
            var hintRow = this.newRow();
            this.hint = new Element("div"), this.hint.setStyle("font-size", "0.8em"), this.hint.setStyle("font-style", "italic"), 
            hintRow.appendChild(this.hint);
            var exampleRow = this.newRow();
            this.example = new Element("pre"), exampleRow.appendChild(this.example);
            var nextRow = this.newRow();
            nextRow.addClass("wizardcontrols");
            var backBtn = new Element("input");
            backBtn.type = "submit", backBtn.value = "< Back", backBtn.addEvent("click", this.back.bind(this)), 
            nextRow.appendChild(backBtn);
            var nextBtn = new Element("input");
            nextBtn.type = "submit", nextBtn.value = "Next >", nextRow.appendChild(nextBtn), 
            nextBtn.addEvent("click", this.next.bind(this)), this.nextBtn = nextBtn, this.backBtn = backBtn;
        },
        newRow: function() {
            var cell = new Element("div");
            return this.t.appendChild(cell), cell;
        },
        newStep: function(options) {
            return new ui.EmbedWizardStep(this, options);
        },
        newRadio: function(parent, text, name, selected) {
            var p = new Element("div");
            parent.appendChild(p);
            var id = util.generateID(), r = util.createInput("radio", p, name, selected, id), label = new Element("label", {
                "for": id
            });
            return label.appendChild(document.createTextNode(text)), p.appendChild(label), r;
        },
        addSteps: function() {
            var af = function(select) {
                if (Browser.Engine.trident) {
                    var f = function() {
                        this.focus(), select && this.select();
                    };
                    f.delay(100, this, []);
                } else this.focus(), this.select();
            };
            this.welcome = this.newStep({
                title: "Add webchat to your website",
                first: "This wizard will help you create an embedded client by asking you questions then giving you the code to add to your website.<br/><br/>You can use the <b>Next</b> and <b>Back</b> buttons to navigate through the wizard; click <b>Next</b> to continue."
            }), this.chanBox = new Element("input"), this.chanBox.addClass("text"), this.chans = this.newStep({
                title: "Set channels",
                first: "Enter the channels you would like the client to join on startup:",
                hint: "You can supply multiple channels by seperating them with a comma, e.g.:",
                example: "#rogue,#eu-mage",
                middle: this.chanBox
            }).addEvent("show", af.bind(this.chanBox));
            var customnickDiv = new Element("div");
            this.customnick = this.newStep({
                title: "Choose a nickname mode",
                first: "At startup would you like the client to use a random nickname, a preset nickname or a nickname of the users choice?",
                hint: "It is recommended that you only use a preset nickname if the client is for your own personal use.",
                middle: customnickDiv
            }), this.choosenick = this.newRadio(customnickDiv, "Make the user choose a nickname.", "nick", !0), 
            this.randnick = this.newRadio(customnickDiv, "Use a random nickname, e.g. qwebirc12883.", "nick"), 
            this.presetnick = this.newRadio(customnickDiv, "Use a preset nickname of your choice.", "nick");
            var promptdiv = new Element("form");
            this.connectdialog = this.newStep({
                title: "Display connect dialog?",
                first: "Do you want the user to be shown the connect dialog (with the values you have supplied pre-entered) or just a connect confirmation?",
                middle: promptdiv,
                hint: "You need to display the dialog if you want the user to be able to set their nickname before connecting."
            });
            var changeOptions = new Element("div");
            this.currentLF = this.newRadio(changeOptions, "Use the current look and feel (", "lookandfeel", !0);
            var alterButton = new Element("input");
            alterButton.type = "submit", alterButton.value = "alter", alterButton.addEvent("click", this.options.optionsCallback), 
            changeOptions.firstChild.appendChild(alterButton), changeOptions.firstChild.appendChild(document.createTextNode(").")), 
            this.defaultLF = this.newRadio(changeOptions, "Use the default look and feel.", "lookandfeel"), 
            this.lookandfeel = this.newStep({
                title: "Configure look and feel",
                first: "The look and feel will be copied from the current settings.",
                middle: changeOptions
            }), this.newRadio(promptdiv, "Connect without displaying the dialog.", "prompt", !0), 
            this.connectdialogr = this.newRadio(promptdiv, "Show the connect dialog.", "prompt"), 
            this.nicknameBox = new Element("input"), this.nicknameBox.addClass("text"), this.nickname = this.newStep({
                title: "Set nickname",
                first: "Enter the nickname you would like the client to use by default:",
                premove: function() {
                    if ("" == this.nicknameBox.value) return alert("You must supply a nickname."), this.nicknameBox.focus(), 
                    !1;
                    var v = qwebirc.global.nicknameValidator.validate(this.nicknameBox.value, !0);
                    return v != this.nicknameBox.value ? (this.nicknameBox.value = v, alert("The supplied nickname was invalid and has been corrected."), 
                    this.nicknameBox.focus(), !1) : !0;
                }.bind(this),
                middle: this.nicknameBox,
                hint: "If you use a . (dot/period) then it will be substituted with a random number."
            }).addEvent("show", af.bind(this.nicknameBox));
            var codeDiv = new Element("div");
            this.finish = this.newStep({
                title: "Finished!",
                first: "Your custom link is:",
                middle: codeDiv
            }).addEvent("show", function() {
                var alink = new Element("a"), abox = new Element("input");
                abox.addClass("iframetext");
                var url = this.generateURL(!1);
                alink.href = url, alink.target = "_blank", alink.appendChild(document.createTextNode(url)), 
                abox.value = '<iframe src="' + url + '" width="647" height="400"></iframe>';
                for (var mBox = [ alink, new Element("br"), new Element("br"), document.createTextNode("You can embed this into your page with the following code:"), new Element("br"), abox ]; codeDiv.childNodes.length > 0; ) codeDiv.removeChild(codeDiv.childNodes[0]);
                mBox.forEach(function(x) {
                    codeDiv.appendChild(x);
                }), af.bind(abox)(!0), abox.addEvent("click", function() {
                    this.select();
                }.bind(abox));
            }.bind(this)), this.updateSteps(), this.step = 0, this.showStep();
        },
        updateSteps: function() {
            this.steps = [ this.welcome, this.customnick ], this.presetnick.checked && this.steps.push(this.nickname), 
            this.steps.push(this.chans), "" == this.chanBox.value || this.choosenick.checked || this.steps.push(this.connectdialog), 
            this.steps.push(this.lookandfeel), this.steps.push(this.finish);
        },
        showStep: function() {
            this.backBtn.disabled = !(this.step > 0), this.nextBtn.value = this.step >= this.steps.length - 1 ? "Close" : "Next >", 
            this.steps[this.step].show();
        },
        next: function() {
            var pm = this.steps[this.step].options.premove;
            if (!pm || pm()) {
                if (this.updateSteps(), this.step >= this.steps.length - 1) return this.close(), 
                undefined;
                this.step = this.step + 1, this.showStep();
            }
        },
        close: function() {
            this.fireEvent("close");
        },
        back: function() {
            0 >= this.step || (this.step = this.step - 1, this.showStep());
        },
        generateURL: function() {
            var chans = this.chanBox.value, nick = this.nicknameBox.value, connectdialog = this.connectdialogr.checked && "" != chans && !this.choosenick.checked, URL = [];
            if (this.presetnick.checked ? URL.push("nick=" + escape(nick)) : this.choosenick.checked || URL.push("randomnick=1"), 
            chans) {
                var d = chans.split(","), d2 = [];
                d.forEach(function(x) {
                    "#" == x.charAt(0) && (x = x.substring(1)), d2.push(x);
                }), URL.push("channels=" + escape(d2.join(",")));
            }
            if (connectdialog && URL.push("prompt=1"), this.currentLF.checked) {
                var uioptions = this.options.uiOptions.serialise();
                "" != uioptions && URL.push("uio=" + uioptions);
            }
            return this.options.baseURL + (URL.length > 0 ? "?" : "") + URL.join("&");
        }
    }), ui.supportsFocus = function() {
        var ua = navigator.userAgent;
        return $defined(ua) ? Browser.Engine.ipod || -1 != ua.indexOf("Konqueror") ? [ !1, !1 ] : [ !0 ] : [ !0 ];
    }, ui.QUI = new Class({
        Extends: ui.RootUI,
        initialize: function(parentElement, theme, options) {
            this.parent(parentElement, ui.QUI.Window, "qui", options), this.theme = theme, this.parentElement = parentElement, 
            this.setModifiableStylesheet("qui");
        },
        postInitialize: function() {
            this.qjsui = new ui.QUI.JSUI("qwebirc-qui", this.parentElement), this.qjsui.addEvent("reflow", function() {
                var w = this.getActiveWindow();
                $defined(w) && w.onResize();
            }.bind(this)), this.qjsui.top.addClass("outertabbar"), this.qjsui.bottom.addClass("input"), 
            this.qjsui.right.addClass("nicklist"), this.qjsui.properties.addClass("properties"), 
            this.qjsui.topic.addClass("topic"), this.qjsui.middle.addClass("lines"), this.outerTabs = this.qjsui.top, 
            this.tabs = new Element("div"), this.tabs.addClass("tabbar"), this.__createDropdownMenu(), 
            this.outerTabs.appendChild(this.tabs), this.origtopic = this.topic = this.qjsui.topic, 
            this.origlines = this.lines = this.qjsui.middle, this.orignicklist = this.nicklist = this.qjsui.right, 
            this.input = this.qjsui.bottom, this.reflow = this.qjsui.reflow.bind(this.qjsui), 
            this.tabs.addEvent("mousewheel", function(x) {
                var event = new Event(x);
                event.wheel > 0 ? this.nextWindow() : 0 > event.wheel && this.prevWindow(), event.stop();
            }.bind(this)), this.createProperties(), this.createInput(), this.reflow(), this.reflow.delay(100), 
            this.__createDropdownHint.delay(100, this);
        },
        __createDropdownMenu: function() {
            var dropdownMenu = new Element("span");
            dropdownMenu.addClass("dropdownmenu"), dropdownMenu.hide = function() {
                dropdownMenu.setStyle("display", "none"), dropdownMenu.visible = !1, document.removeEvent("mousedown", hideEvent);
            }.bind(this);
            var hideEvent = function() {
                dropdownMenu.hide();
            };
            dropdownMenu.hide(), this.parentElement.appendChild(dropdownMenu), this.UICommands.forEach(function(x) {
                var text = x[0], fn = this[x[1] + "Window"].bind(this), e = new Element("a");
                e.addEvent("mousedown", function(e) {
                    new Event(e).stop();
                }), e.addEvent("click", function() {
                    dropdownMenu.hide(), fn();
                }), e.set("text", text), dropdownMenu.appendChild(e);
            }.bind(this));
            var dropdown = new Element("div");
            dropdown.addClass("dropdown-tab"), dropdown.appendChild(new Element("img", {
                src: qwebirc.global.staticBaseURL + "images/icon.png",
                title: "menu",
                alt: "menu"
            })), dropdown.setStyle("opacity", 1);
            var dropdownEffect = new Fx.Tween(dropdown, {
                duration: "long",
                property: "opacity",
                link: "chain"
            });
            dropdownEffect.start(.25), dropdownEffect.start(1), dropdownEffect.start(.33), dropdownEffect.start(1), 
            this.outerTabs.appendChild(dropdown), dropdownMenu.show = function(x) {
                if (new Event(x).stop(), this.hideHint(), dropdownMenu.visible) return dropdownMenu.hide(), 
                undefined;
                var top = this.outerTabs.getSize().y;
                dropdownMenu.setStyle("left", 0), dropdownMenu.setStyle("top", top - 1), dropdownMenu.setStyle("display", "inline-block"), 
                dropdownMenu.visible = !0, document.addEvent("mousedown", hideEvent);
            }.bind(this), dropdown.addEvent("mousedown", function(e) {
                new Event(e).stop();
            }), dropdown.addEvent("click", dropdownMenu.show);
        },
        __createDropdownHint: function() {
            var dropdownhint = new Element("div");
            dropdownhint.addClass("dropdownhint"), dropdownhint.set("text", "Click the icon for the main menu."), 
            dropdownhint.setStyle("top", this.outerTabs.getSize().y + 5), this.parentElement.appendChild(dropdownhint), 
            new Fx.Morph(dropdownhint, {
                duration: "normal",
                transition: Fx.Transitions.Sine.easeOut
            }).start({
                left: [ 900, 5 ]
            }), function() {
                new Fx.Morph(dropdownhint, {
                    duration: "long"
                }).start({
                    left: [ 5, -900 ]
                });
            }.delay(4e3, this);
            var hider2 = function(e) {
                element = document.getElementsByTagName("input")[0], "keyboard-input" == element.className && e && "keydown" == e.type && (17 == e.code && (window.ctrl = 1), 
                1 != window.ctrl && (active = 0, element == document.activeElement && (active = 1), 
                element.focus(), active || (element.value = element.value))), dropdownhint.hidden || (this.parentElement.removeChild(dropdownhint), 
                dropdownhint.hidden = 1);
            }.bind(this);
            hider2.delay(4e3), this.hideHint = hider2;
            var hider3 = function(e) {
                17 == e.code && (window.ctrl = 0);
            }.bind(this);
            document.addEvent("mousedown", hider2), document.addEvent("keydown", hider2), document.addEvent("keyup", hider3);
        },
        createProperties: function() {
            this.qjsui.properties.innerHTML = '<div id="channel-name-id" class="channel-name">#</div>';
        },
        createInput: function() {
            var form = new Element("form");
            this.input.appendChild(form), form.addClass("input");
            var inputbox = new Element("input");
            form.appendChild(inputbox), this.inputbox = inputbox;
            var sendInput = function() {
                "" != inputbox.value && (this.resetTabComplete(), this.getActiveWindow().historyExec(inputbox.value), 
                inputbox.value = "");
            }.bind(this);
            if (util.deviceHasKeyboard()) inputbox.addClass("keyboard-input"), inputbox.addEvent("blur", function() {
                window.keyboardInputFocus = 0;
            }), inputbox.addEvent("focus", function() {
                window.keyboardInputFocus = 1;
            }); else {
                inputbox.addClass("mobile-input");
                var inputButton = new Element("input", {
                    type: "button"
                });
                inputButton.addClass("mobile-button"), inputButton.addEvent("click", function() {
                    sendInput(), inputbox.focus();
                }), inputButton.value = ">", this.input.appendChild(inputButton);
                var reflowButton = function() {
                    var containerSize = this.input.getSize(), buttonSize = inputButton.getSize(), buttonLeft = containerSize.x - buttonSize.x - 5;
                    inputButton.setStyle("left", buttonLeft), inputbox.setStyle("width", buttonLeft - 5), 
                    inputButton.setStyle("height", containerSize.y);
                }.bind(this);
                this.qjsui.addEvent("reflow", reflowButton);
            }
            form.addEvent("submit", function(e) {
                new Event(e).stop(), sendInput();
            }), inputbox.addEvent("focus", this.resetTabComplete.bind(this)), inputbox.addEvent("mousedown", this.resetTabComplete.bind(this)), 
            inputbox.addEvent("keydown", function(e) {
                var resultfn, cvalue = inputbox.value;
                if ("up" == e.key) resultfn = this.commandhistory.upLine; else {
                    if ("down" != e.key) return "tab" == e.key && 1 != window.ctrl ? (new Event(e).stop(), 
                    this.tabComplete(inputbox), undefined) : (this.resetTabComplete(), undefined);
                    resultfn = this.commandhistory.downLine;
                }
                this.resetTabComplete(), "" != cvalue && this.lastcvalue != cvalue && this.commandhistory.addLine(cvalue, !0);
                var result = resultfn.bind(this.commandhistory)();
                new Event(e).stop(), result || (result = ""), this.lastcvalue = result, inputbox.value = result, 
                util.setAtEnd(inputbox);
            }.bind(this));
        },
        setLines: function(lines) {
            this.lines.parentNode.replaceChild(lines, this.lines), this.qjsui.middle = this.lines = lines;
        },
        setChannelItems: function(nicklist, topic) {
            $defined(nicklist) || (nicklist = this.orignicklist, topic = this.origtopic), this.nicklist.parentNode.replaceChild(nicklist, this.nicklist), 
            this.qjsui.right = this.nicklist = nicklist, this.topic.parentNode.replaceChild(topic, this.topic), 
            this.qjsui.topic = this.topic = topic;
        }
    }), ui.QUI.JSUI = new Class({
        Implements: [ Events ],
        initialize: function(class_, parent, sizer) {
            this.parent = parent, this.sizer = $defined(sizer) ? sizer : parent, this.class_ = class_, 
            this.create(), this.reflowevent = null, window.addEvent("resize", function() {
                this.reflow(100);
            }.bind(this));
        },
        applyClasses: function(pos, l) {
            l.addClass("dynamicpanel"), l.addClass(this.class_), "middle" == pos ? l.addClass("leftboundpanel") : "top" == pos ? (l.addClass("topboundpanel"), 
            l.addClass("widepanel")) : "topic" == pos ? l.addClass("widepanel") : "right" == pos ? l.addClass("rightboundpanel") : "bottom" == pos && (l.addClass("bottomboundpanel"), 
            l.addClass("widepanel"));
        },
        create: function() {
            var XE = function(pos) {
                var element = new Element("div");
                return this.applyClasses(pos, element), this.parent.appendChild(element), element;
            }.bind(this);
            this.top = XE("top"), this.topic = XE("topic"), this.middle = XE("middle"), this.right = XE("right"), 
            this.properties = XE("properties"), this.bottom = XE("bottom");
        },
        reflow: function(delay) {
            delay || (delay = 1), this.reflowevent && $clear(this.reflowevent), this.__reflow(), 
            this.reflowevent = this.__reflow.delay(delay, this);
        },
        __reflow: function() {
            var properties = this.properties, bottom = this.bottom, middle = this.middle, right = this.right, topic = this.topic, top = this.top, topicsize = topic.getSize(), topsize = top.getSize(), rightsize = right.getSize(), bottomsize = bottom.getSize(), docsize = this.sizer.getSize(), mheight = docsize.y - topsize.y - bottomsize.y - topicsize.y, mwidth = docsize.x - rightsize.x;
            topic.setStyle("top", topsize.y), last5_height = 0, document.getElementById("last5messages") ? (last5 = document.getElementById("last5messages"), 
            last5.className = "qwebirc-qui ircwindow dynamicpanel lines", last5.style.top = topsize.y + topicsize.y + "px", 
            last5.style.width = mwidth + "px", last5.style.zIndex = "1", last5.style.borderBottom = "1px dashed #C8D1DB", 
            last5_height = last5.offsetHeight, middle.setStyle("top", topsize.y + topicsize.y + last5.offsetHeight)) : middle.setStyle("top", topsize.y + topicsize.y), 
            mheight > 0 && (middle.setStyle("height", mheight - 25 - last5_height), right.setStyle("height", mheight)), 
            mwidth > 0 && (middle.setStyle("width", mwidth), properties.setStyle("width", mwidth)), 
            right.setStyle("top", topsize.y + topicsize.y), right.setStyle("left", mwidth), 
            properties.setStyle("top", docsize.y - bottomsize.y - 25), bottom.setStyle("top", docsize.y - bottomsize.y), 
            this.fireEvent("reflow");
        },
        showChannel: function(state, nicklistVisible) {
            var display = "none";
            state && (display = "block"), this.right.setStyle("display", nicklistVisible ? display : "none"), 
            this.topic.setStyle("display", display);
        },
        showInput: function(state) {
            this.bottom.isVisible = state, this.bottom.setStyle("display", state ? "block" : "none");
        }
    }), ui.QUI.Window = new Class({
        Extends: ui.Window,
        initialize: function(parentObject, client, type, name, identifier) {
            if (this.parent(parentObject, client, type, name, identifier), this.tab = new Element("a", {
                href: "#"
            }), this.tab.addClass("tab"), this.tab.addEvent("focus", function() {
                this.blur();
            }.bind(this.tab)), this.spaceNode = document.createTextNode(" "), parentObject.tabs.appendChild(this.tab), 
            parentObject.tabs.appendChild(this.spaceNode), name == BROUHAHA ? (this.tab.addClass("brouhaha"), 
            this.tab.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;") : this.tab.appendText(name), 
            this.tab.addEvent("click", function() {
                if (this.name != BROUHAHA) {
                    var client = parentObject.clients[0];
                    for (c in client.windows) c != BROUHAHA && (client.windows[c].tab.removeClass("tab-selected"), 
                    client.windows[c].tab.addClass("tab-unselected"));
                    window.name = this.name, this.tab.removeClass("tab-hilight-activity"), this.tab.removeClass("tab-hilight-us"), 
                    this.tab.removeClass("tab-hilight-speech"), this.tab.removeClass("tab-unselected"), 
                    this.tab.addClass("tab-selected"), element = document.getElementById("channel-name-id"), 
                    element.innerHTML = this.name, ui.highlightRecent(), this.reflow();
                }
            }.bind(this)), this.tab.addEvent("dblclick", function(e) {
                new Event(e).stop(), this.closed || (parentObject.selectWindow(this), ui.highlightRecent());
            }.bind(this)), type != ui.WINDOW_STATUS && type != ui.WINDOW_CONNECT) {
                var tabclose = new Element("span");
                tabclose.set("text", "X"), tabclose.addClass("tabclose");
                var close = function(e) {
                    new Event(e).stop(), this.closed || (type == ui.WINDOW_CHANNEL && this.client.exec("/PART " + name), 
                    this.close());
                }.bind(this);
                tabclose.addEvent("click", close), this.tab.addEvent("mouseup", function(e) {
                    var button = 1;
                    Browser.Engine.trident && (button = 4), e.event.button == button && close(e);
                }.bind(this)), name != BROUHAHA && this.tab.appendChild(tabclose);
            }
            this.lines = new Element("div"), this.parentObject.qjsui.applyClasses("middle", this.lines), 
            this.lines.addClass("lines"), type != ui.WINDOW_CUSTOM && type != ui.WINDOW_CONNECT && (this.lines.addClass("ircwindow"), 
            this.lines.id = "mainircwindow"), this.lines.addEvent("scroll", function() {
                this.scrolleddown = this.scrolledDown(), this.scrollpos = this.getScrollParent().getScroll();
            }.bind(this)), type == ui.WINDOW_CHANNEL && (this.topic = new Element("div"), this.topic.addClass("topic"), 
            this.topic.addClass("tab-invisible"), this.topic.set("html", "&nbsp;"), this.topic.addEvent("dblclick", this.editTopic.bind(this)), 
            this.parentObject.qjsui.applyClasses("topic", this.topic), this.prevNick = null, 
            this.nicklist = new Element("div"), this.nicklist.addClass("nicklist"), this.nicklist.addClass("tab-invisible"), 
            this.nicklist.addEvent("click", this.removePrevMenu.bind(this)), this.parentObject.qjsui.applyClasses("nicklist", this.nicklist)), 
            type == ui.WINDOW_CHANNEL && this.updateTopic(""), this.nicksColoured = this.parentObject.uiOptions.NICK_COLOURS, 
            this.reflow();
        },
        editTopic: function() {
            if (!this.client.nickOnChanHasPrefix(this.client.nickname, this.name, "@")) return alert("Sorry, you need to be a channel operator to change the topic!"), 
            undefined;
            var newTopic = prompt("Change topic of " + this.name + " to:", this.topic.topicText);
            null !== newTopic && this.client.exec("/TOPIC " + newTopic);
        },
        reflow: function() {
            this.parentObject.reflow();
        },
        onResize: function() {
            this.scrolleddown ? Browser.Engine.trident ? this.scrollToBottom.delay(5, this) : this.scrollToBottom() : $defined(this.scrollpos) && (Browser.Engine.trident ? this.getScrollParent().scrollTo(this.scrollpos.x, this.scrollpos.y) : this.getScrollParent().scrollTo.delay(5, this, [ this.scrollpos.x, this.scrollpos.y ]));
        },
        createMenu: function(nick, parent) {
            var e = new Element("div");
            parent.appendChild(e), e.addClass("menu");
            var nickArray = [ nick ];
            return ui.MENU_ITEMS.filter(function(item) {
                var ret, pred = item.predicate;
                return ret = "function" === $type(pred) ? pred.apply(this, nickArray) : !!pred;
            }, this).each(function(item) {
                var e2 = new Element("a");
                e.appendChild(e2), e2.href = "#", e2.set("text", "- " + item.text), e2.addEvent("focus", function() {
                    this.blur();
                }.bind(e2)), e2.addEvent("click", function(ev) {
                    new Event(ev.stop()), this.menuClick(item.fn);
                }.bind(this));
            }, this), e;
        },
        menuClick: function(fn) {
            fn.bind(this)(this.prevNick.realNick), this.removePrevMenu();
        },
        moveMenuClass: function() {
            this.prevNick && (this.nicklist.firstChild == this.prevNick ? this.prevNick.removeClass("selected-middle") : this.prevNick.addClass("selected-middle"));
        },
        removePrevMenu: function() {
            this.prevNick && (this.prevNick.removeClass("selected"), this.prevNick.removeClass("selected-middle"), 
            this.prevNick.menu && this.prevNick.removeChild(this.prevNick.menu), this.prevNick = null);
        },
        nickListAdd: function(nick, position) {
            var realNick = util.stripPrefix(this.client.prefixes, nick), e = new Element("a");
            ui.insertAt(position, this.nicklist, e), e.href = "#";
            var span = new Element("span");
            if (this.parentObject.uiOptions.NICK_COLOURS) {
                var colour = util.toHSBColour(realNick, this.client);
                $defined(colour) && span.setStyle("color", colour.rgbToHex());
            }
            return span.set("text", nick), e.appendChild(span), e.realNick = realNick, e.addEvent("click", function(x) {
                return this.prevNick == e ? (this.removePrevMenu(), undefined) : (this.removePrevMenu(), 
                this.prevNick = e, e.addClass("selected"), this.moveMenuClass(), e.menu = this.createMenu(e.realNick, e), 
                new Event(x).stop(), undefined);
            }.bind(this)), e.addEvent("focus", function() {
                this.blur();
            }.bind(e)), this.moveMenuClass(), e;
        },
        nickListRemove: function(nick, stored) {
            try {
                this.nicklist.removeChild(stored), this.moveMenuClass();
            } catch (e) {
                console.log(nick), console.log(stored);
            }
        },
        updateTopic: function(topic) {
            for (var t = this.topic; t.firstChild; ) t.removeChild(t.firstChild);
            if (topic) t.topicText = topic, this.parent(topic, t); else {
                t.topicText = topic;
                var e = new Element("div");
                e.set("text", "(no topic set)"), e.addClass("emptytopic"), t.appendChild(e);
            }
            this.reflow();
        },
        select: function() {
            var inputVisible = this.type != ui.WINDOW_CONNECT && this.type != ui.WINDOW_CUSTOM;
            if (this.tab.removeClass("tab-unselected"), this.name !== BROUHAHA ? this.tab.addClass("tab-selected") : (this.tab.removeClass("brouhaha-unselected"), 
            this.tab.addClass("brouhaha")), this.parentObject.setLines(this.lines), this.parentObject.setChannelItems(this.nicklist, this.topic), 
            this.parentObject.qjsui.showInput(inputVisible), this.parentObject.qjsui.showChannel($defined(this.nicklist), this.parentObject.uiOptions.SHOW_NICKLIST), 
            this.reflow(), this.parent(), inputVisible && this.parentObject.inputbox.focus(), 
            this.type == ui.WINDOW_CHANNEL && this.nicksColoured != this.parentObject.uiOptions.NICK_COLOURS) {
                this.nicksColoured = this.parentObject.uiOptions.NICK_COLOURS;
                var nodes = this.nicklist.childNodes;
                if (this.parentObject.uiOptions.NICK_COLOURS) for (var i = 0; nodes.length > i; i++) {
                    var e = nodes[i], span = e.firstChild, colour = util.toHSBColour(e.realNick, this.client);
                    $defined(colour) && span.setStyle("color", colour.rgbToHex());
                } else for (var i = 0; nodes.length > i; i++) {
                    var span = nodes[i].firstChild;
                    span.setStyle("color", null);
                }
            }
        },
        deselect: function() {
            this.parent(), this.tab.removeClass("tab-selected"), this.name === BROUHAHA ? (this.tab.removeClass("brouhaha"), 
            this.tab.addClass("brouhaha-unselected")) : this.tab.addClass("tab-unselected");
        },
        close: function() {
            if (!isBaseWindow(this.name) && new Date().getTime() - window.lastkick.last > 100) {
                var client = this.client, channels = util.removeChannel(client.channels, this.name);
                client.storeChannels(channels);
            }
            this.parent(), this.parentObject.tabs.removeChild(this.tab), this.parentObject.tabs.removeChild(this.spaceNode), 
            this.reflow();
        },
        addLine: function(type, line, colourClass) {
            var e = new Element("div");
            colourClass ? e.addClass(colourClass) : this.lastcolour ? e.addClass("linestyle1") : e.addClass("linestyle2"), 
            this.lastcolour = !this.lastcolour, this.parent(type, line, colourClass, e), this.reflow();
        },
        setHilighted: function(state) {
            var laststate = this.hilighted;
            if (this.parent(state), state != laststate) switch (this.tab.removeClass("tab-hilight-activity"), 
            this.tab.removeClass("tab-hilight-us"), this.tab.removeClass("tab-hilight-speech"), 
            this.hilighted) {
              case ui.HILIGHT_US:
                this.tab.addClass("tab-hilight-us");
                break;

              case ui.HILIGHT_SPEECH:
                this.tab.addClass("tab-hilight-speech");
            }
        }
    }), ui.GenericLoginBox = function(parentElement, callback, initialNickname, initialChannels, autoConnect, autoNick, networkName, storage) {
        autoConnect ? ui.ConfirmBox(parentElement, callback, initialNickname, initialChannels, autoNick, networkName, storage) : ui.LoginBox(parentElement, callback, initialNickname, initialChannels, networkName, storage);
    }, ui.LoginBox = function(parentElement, callback, initialNickname, initialChannels, networkName, authCookies) {
        function toggleFull() {
            fullForm = fullForm || form.getElements('[name="full"]').getParent("div"), fullForm.each(function(e) {
                e.toggleClass("hidden");
            });
        }
        var outerbox = new Element("div");
        outerbox.addClass("tf-middle"), parentElement.appendChild(outerbox);
        var content = new Element("div");
        outerbox.appendChild(content);
        var nickname = authCookies.nick.read() || initialNickname, gamesurge = util.B64.decode(authCookies.user.read()), password = util.B64.decode(authCookies.pass.read()), eauth = auth.enabled || authCookies.auth.read(), context = {
            network: networkName,
            nickname: nickname || initialNickname,
            username: gamesurge,
            password: password,
            full: eauth
        };
        content.innerHTML = Handlebars.templates.authpage(context);
        var fullForm, nickBox = $("nickname"), usernameBox = $("username"), passwordBox = $("password"), chkAddAuth = $("authenticate"), form = $$("form#login")[0];
        chkAddAuth.addEvent("click", toggleFull), form.addEvent("submit", function(e) {
            new Event(e).stop();
            var nickname = nickBox.value;
            if (!nickname) return alert("You must supply a nickname."), nickBox.focus(), undefined;
            var stripped = qwebirc.global.nicknameValidator.validate(nickname);
            if (stripped !== nickname) return nickBox.value = stripped, alert("Your nickname was invalid and has been corrected; please check your altered nickname and press Connect again."), 
            nickBox.focus(), undefined;
            var data = {
                nickname: nickname
            };
            if (authCookies.nick.write(nickname), chkAddAuth.checked || auth.enabled) {
                if (data.gamesurge = gamesurge = usernameBox.value, data.password = password = passwordBox.value, 
                authCookies.user.write(util.B64.encode(gamesurge)), authCookies.pass.write(util.B64.encode(password)), 
                authCookies.auth.write(!0), auth.enabled = !0, auth.bouncerAuth()) {
                    if (!password) return alert("You must supply a password."), passwordBox.focus(), 
                    undefined;
                    data.serverPassword = password;
                }
                if (!gamesurge || !password) return alert("You must supply your username and password in auth mode."), 
                usernameBox.value ? passwordBox.focus() : usernameBox.focus(), undefined;
                auth.passAuth() && (data.serverPassword = gamesurge + " " + password);
            } else authCookies.auth.dispose();
            parentElement.removeChild(outerbox), auth.loggedin = !0, callback.call(this, data);
        }.bind(this)), window == window.top && nickBox.focus();
    }, ui.ConfirmBox = function(parentElement, callback, initialNickname, initialChannels, autoNick, networkName) {
        var outerbox = new Element("table");
        outerbox.addClass("qwebirc-centrebox"), parentElement.appendChild(outerbox);
        var tbody = new Element("tbody");
        outerbox.appendChild(tbody);
        var tr = new Element("tr");
        tbody.appendChild(tr);
        var td = new Element("td");
        tr.appendChild(td);
        var box = new Element("table");
        box.addClass("qwebirc-confirmbox"), td.appendChild(box);
        var tbody = new Element("tbody");
        box.appendChild(tbody);
        var tr = new Element("tr");
        tbody.appendChild(tr), tr.addClass("tr1");
        var text = new Element("td");
        tr.appendChild(text);
        var nick = new Element("b");
        nick.set("text", initialNickname);
        var c = initialChannels.split(" ")[0].split(",");
        text.appendChild(document.createTextNode("To connect to " + networkName + " IRC and join channel" + (c.length > 1 ? "s" : "") + " "));
        for (var i = 0; c.length > i; i++) c.length > 1 && i == c.length - 1 ? text.appendChild(document.createTextNode(" and ")) : i > 0 && text.appendChild(document.createTextNode(", ")), 
        text.appendChild(new Element("b").set("text", c[i]));
        autoNick || (text.appendChild(document.createTextNode(" as ")), text.appendChild(nick)), 
        text.appendChild(document.createTextNode(" click 'Connect'.")), text.appendChild(new Element("br")), 
        auth.enabled && auth.quakeNetAuth() && !auth.loggedin && text.appendChild(document.createTextNode("If you'd like to connect using your Q auth click 'Log in'."));
        var tr = new Element("tr");
        tbody.appendChild(tr), tr.addClass("tr2");
        var td = new Element("td");
        tr.appendChild(td);
        var yes = new Element("input", {
            type: "submit",
            value: "Connect"
        });
        if (td.appendChild(yes), yes.addEvent("click", function() {
            parentElement.removeChild(outerbox), callback({
                nickname: initialNickname,
                autojoin: initialChannels
            });
        }), auth.enabled && auth.quakeNetAuth() && !auth.loggedin) {
            var auth = new Element("input", {
                type: "submit",
                value: "Log in"
            });
            td.appendChild(auth), auth.addEvent("click", ui.AuthLogin);
        }
        window == window.top && yes.focus();
    }, ui.authShowHide = function(checkbox, authRow, usernameBox, usernameRow, passwordRow) {
        var visible = checkbox.checked, display = visible ? null : "none";
        usernameRow.setStyle("display", display), passwordRow.setStyle("display", display), 
        visible && usernameBox.focus();
    };
}(this);
{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"btn",
				"btnmenu"
			],
			[
				"pop",
				"popularChans"
			],
			[
				"parent",
				"parentObject"
			],
			[
				"el",
				"element"
			],
			[
				"urli",
				"urlificate"
			],
			[
				"last",
				"lastcolour"
			],
			[
				"url",
				"urlregex"
			],
			[
				"pref",
				"prefixes"
			],
			[
				"addEv",
				"addEvent"
			],
			[
				"input",
				"inputbox"
			],
			[
				"px",
				"pxFromBottom"
			],
			[
				"par",
				"parentObject"
			],
			[
				"nick",
				"nicklabel"
			],
			[
				"v-a",
				"va-m	vertical-align: middle;"
			],
			[
				"posi",
				"position"
			],
			[
				"update",
				"updatePos"
			],
			[
				"real",
				"relativePosition"
			],
			[
				"relative",
				"relativePosition"
			],
			[
				"text",
				"textfield"
			]
		]
	},
	"buffers":
	[
		{
			"file": "js/src/ui/misc.js",
			"settings":
			{
				"buffer_size": 11152,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/util/1constants.js",
			"settings":
			{
				"buffer_size": 4231,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/util/2lang.js",
			"settings":
			{
				"buffer_size": 7942,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/libs/2mootools-more-1.4.0.1 (1).js",
			"settings":
			{
				"buffer_size": 107026,
				"line_ending": "Unix"
			}
		},
		{
			"file": "js/libs/1mootools-core-1.4.5.js",
			"settings":
			{
				"buffer_size": 161160,
				"line_ending": "Unix"
			}
		},
		{
			"file": "js/src/irc/commands_utils.js",
			"settings":
			{
				"buffer_size": 14568,
				"line_ending": "Windows"
			}
		},
		{
			"file": "css/modifiablecss.mcss",
			"settings":
			{
				"buffer_size": 15216,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/ui/window/2quiwindow.js",
			"settings":
			{
				"buffer_size": 19688,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/ui/window/1window.js",
			"settings":
			{
				"buffer_size": 8161,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/irc/ircclient.js",
			"settings":
			{
				"buffer_size": 31557,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/irc/baseclient.js",
			"settings":
			{
				"buffer_size": 18014,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/irc/ircconnection.js",
			"settings":
			{
				"buffer_size": 9598,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/ui/6QUI.js",
			"settings":
			{
				"buffer_size": 14744,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/ui/helpers.js",
			"settings":
			{
				"buffer_size": 3478,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/ui/4loginui.js",
			"settings":
			{
				"buffer_size": 7303,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/ui/1BaseUI.js",
			"settings":
			{
				"buffer_size": 5522,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "function $A(iterable) {\n    if (iterable.item) {\n        for (var l = iterable.length, array = Array(l); l--; ) array[l] = iterable[l];\n        return array;\n    }\n    return Array.prototype.slice.call(iterable);\n}\n\nfunction $arguments(i) {\n    return function() {\n        return arguments[i];\n    };\n}\n\nfunction $chk(obj) {\n    return !(!obj && 0 !== obj);\n}\n\nfunction $clear(timer) {\n    return clearTimeout(timer), clearInterval(timer), null;\n}\n\nfunction $defined(obj) {\n    return void 0 != obj;\n}\n\nfunction $each(iterable, fn, bind) {\n    var type = $type(iterable);\n    (\"arguments\" == type || \"collection\" == type || \"array\" == type ? Array : Hash).each(iterable, fn, bind);\n}\n\nfunction $empty() {}\n\nfunction $extend(original, extended) {\n    for (var key in extended || {}) original[key] = extended[key];\n    return original;\n}\n\nfunction $H(object) {\n    return new Hash(object);\n}\n\nfunction $lambda(value) {\n    return \"function\" == $type(value) ? value : function() {\n        return value;\n    };\n}\n\nfunction $merge() {\n    var args = Array.slice(arguments);\n    return args.unshift({}), $mixin.apply(null, args);\n}\n\nfunction $mixin(mix) {\n    for (var i = 1, l = arguments.length; l > i; i++) {\n        var object = arguments[i];\n        if (\"object\" == $type(object)) for (var key in object) {\n            var op = object[key], mp = mix[key];\n            mix[key] = mp && \"object\" == $type(op) && \"object\" == $type(mp) ? $mixin(mp, op) : $unlink(op);\n        }\n    }\n    return mix;\n}\n\nfunction $pick() {\n    for (var i = 0, l = arguments.length; l > i; i++) if (void 0 != arguments[i]) return arguments[i];\n    return null;\n}\n\nfunction $random(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction $splat(obj) {\n    var type = $type(obj);\n    return type ? \"array\" != type && \"arguments\" != type ? [ obj ] : obj : [];\n}\n\nfunction $try() {\n    for (var i = 0, l = arguments.length; l > i; i++) try {\n        return arguments[i]();\n    } catch (e) {}\n    return null;\n}\n\nfunction $type(obj) {\n    if (void 0 == obj) return !1;\n    if (obj.$family) return \"number\" != obj.$family.name || isFinite(obj) ? obj.$family.name : !1;\n    if (obj.nodeName) switch (obj.nodeType) {\n      case 1:\n        return \"element\";\n\n      case 3:\n        return /\\S/.test(obj.nodeValue) ? \"textnode\" : \"whitespace\";\n    } else if (\"number\" == typeof obj.length) {\n        if (obj.callee) return \"arguments\";\n        if (obj.item) return \"collection\";\n    }\n    return typeof obj;\n}\n\nfunction $unlink(object) {\n    var unlinked;\n    switch ($type(object)) {\n      case \"object\":\n        unlinked = {};\n        for (var p in object) unlinked[p] = $unlink(object[p]);\n        break;\n\n      case \"hash\":\n        unlinked = new Hash(object);\n        break;\n\n      case \"array\":\n        unlinked = [];\n        for (var i = 0, l = object.length; l > i; i++) unlinked[i] = $unlink(object[i]);\n        break;\n\n      default:\n        return object;\n    }\n    return unlinked;\n}\n\nfunction $exec(text) {\n    if (!text) return text;\n    if (window.execScript) window.execScript(text); else {\n        var script = document.createElement(\"script\");\n        script.setAttribute(\"type\", \"text/javascript\"), script[Browser.Engine.webkit && 420 > Browser.Engine.version ? \"innerText\" : \"text\"] = text, \n        document.head.appendChild(script), document.head.removeChild(script);\n    }\n    return text;\n}\n\nfunction Class(params) {\n    params instanceof Function && (params = {\n        initialize: params\n    });\n    var newClass = function() {\n        if (Object.reset(this), newClass._prototyping) return this;\n        this._current = $empty;\n        var value = this.initialize ? this.initialize.apply(this, arguments) : this;\n        return delete this._current, delete this.caller, value;\n    }.extend(this);\n    return newClass.implement(params), newClass.constructor = Class, newClass.prototype.constructor = newClass, \n    newClass;\n}\n\nfunction qwebirc_ui_onbeforeunload(e) {\n    if (new Date().getTime() - document.window.steamlink > 100) {\n        var message = \"This action will close all active IRC connections.\";\n        return (e = e || window.event) && (e.returnValue = message), message;\n    }\n}\n\nvar MooTools = {\n    version: \"1.2.6\",\n    build: \"a3be7a0ef5205eb655c4ee11e8cbedcb3f2ffa95\"\n}, Native = function(options) {\n    options = options || {};\n    var name = options.name, legacy = options.legacy, protect = options.protect, methods = options.implement, generics = options.generics, initialize = options.initialize, afterImplement = options.afterImplement || function() {}, object = initialize || legacy;\n    if (generics = generics !== !1, object.constructor = Native, object.$family = {\n        name: \"native\"\n    }, legacy && initialize && (object.prototype = legacy.prototype), object.prototype.constructor = object, \n    name) {\n        var family = name.toLowerCase();\n        object.prototype.$family = {\n            name: family\n        }, Native.typize(object, family);\n    }\n    var add = function(obj, name, method, force) {\n        return protect && !force && obj.prototype[name] || (obj.prototype[name] = method), \n        generics && Native.genericize(obj, name, protect), afterImplement.call(obj, name, method), \n        obj;\n    };\n    return object.alias = function(a1, a2, a3) {\n        if (\"string\" == typeof a1) {\n            var pa1 = this.prototype[a1];\n            if (a1 = pa1) return add(this, a2, a1, a3);\n        }\n        for (var a in a1) this.alias(a, a1[a], a2);\n        return this;\n    }, object.implement = function(a1, a2, a3) {\n        if (\"string\" == typeof a1) return add(this, a1, a2, a3);\n        for (var p in a1) add(this, p, a1[p], a2);\n        return this;\n    }, methods && object.implement(methods), object;\n};\n\nNative.genericize = function(object, property, check) {\n    check && object[property] || \"function\" != typeof object.prototype[property] || (object[property] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        return object.prototype[property].apply(args.shift(), args);\n    });\n}, Native.implement = function(objects, properties) {\n    for (var i = 0, l = objects.length; l > i; i++) objects[i].implement(properties);\n}, Native.typize = function(object, family) {\n    object.type || (object.type = function(item) {\n        return $type(item) === family;\n    });\n}, function() {\n    var natives = {\n        Array: Array,\n        Date: Date,\n        Function: Function,\n        Number: Number,\n        RegExp: RegExp,\n        String: String\n    };\n    for (var n in natives) new Native({\n        name: n,\n        initialize: natives[n],\n        protect: !0\n    });\n    var types = {\n        \"boolean\": Boolean,\n        \"native\": Native,\n        object: Object\n    };\n    for (var t in types) Native.typize(types[t], t);\n    var generics = {\n        Array: [ \"concat\", \"indexOf\", \"join\", \"lastIndexOf\", \"pop\", \"push\", \"reverse\", \"shift\", \"slice\", \"sort\", \"splice\", \"toString\", \"unshift\", \"valueOf\" ],\n        String: [ \"charAt\", \"charCodeAt\", \"concat\", \"indexOf\", \"lastIndexOf\", \"match\", \"replace\", \"search\", \"slice\", \"split\", \"substr\", \"substring\", \"toLowerCase\", \"toUpperCase\", \"valueOf\" ]\n    };\n    for (var g in generics) for (var i = generics[g].length; i--; ) Native.genericize(natives[g], generics[g][i], !0);\n}();\n\nvar Hash = new Native({\n    name: \"Hash\",\n    initialize: function(object) {\n        \"hash\" == $type(object) && (object = $unlink(object.getClean()));\n        for (var key in object) this[key] = object[key];\n        return this;\n    }\n});\n\nHash.implement({\n    forEach: function(fn, bind) {\n        for (var key in this) this.hasOwnProperty(key) && fn.call(bind, this[key], key, this);\n    },\n    getClean: function() {\n        var clean = {};\n        for (var key in this) this.hasOwnProperty(key) && (clean[key] = this[key]);\n        return clean;\n    },\n    getLength: function() {\n        var length = 0;\n        for (var key in this) this.hasOwnProperty(key) && length++;\n        return length;\n    }\n}), Hash.alias(\"forEach\", \"each\"), Array.implement({\n    forEach: function(fn, bind) {\n        for (var i = 0, l = this.length; l > i; i++) fn.call(bind, this[i], i, this);\n    }\n}), Array.alias(\"forEach\", \"each\");\n\nvar $time = Date.now || function() {\n    return +new Date();\n}, Browser = $merge({\n    Engine: {\n        name: \"unknown\",\n        version: 0\n    },\n    Platform: {\n        name: void 0 != window.orientation ? \"ipod\" : (navigator.platform.match(/mac|win|linux/i) || [ \"other\" ])[0].toLowerCase()\n    },\n    Features: {\n        xpath: !!document.evaluate,\n        air: !!window.runtime,\n        query: !!document.querySelector\n    },\n    Plugins: {},\n    Engines: {\n        presto: function() {\n            return window.opera ? arguments.callee.caller ? 960 : document.getElementsByClassName ? 950 : 925 : !1;\n        },\n        trident: function() {\n            return window.ActiveXObject ? window.XMLHttpRequest ? document.querySelectorAll ? 6 : 5 : 4 : !1;\n        },\n        webkit: function() {\n            return navigator.taintEnabled ? !1 : Browser.Features.xpath ? Browser.Features.query ? 525 : 420 : 419;\n        },\n        gecko: function() {\n            return document.getBoxObjectFor || null != window.mozInnerScreenX ? document.getElementsByClassName ? 19 : 18 : !1;\n        }\n    }\n}, Browser || {});\n\nBrowser.Platform[Browser.Platform.name] = !0, Browser.detect = function() {\n    for (var engine in this.Engines) {\n        var version = this.Engines[engine]();\n        if (version) {\n            this.Engine = {\n                name: engine,\n                version: version\n            }, this.Engine[engine] = this.Engine[engine + version] = !0;\n            break;\n        }\n    }\n    return {\n        name: engine,\n        version: version\n    };\n}, Browser.detect(), Browser.Request = function() {\n    return $try(function() {\n        return new XMLHttpRequest();\n    }, function() {\n        return new ActiveXObject(\"MSXML2.XMLHTTP\");\n    }, function() {\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\n    });\n}, Browser.Features.xhr = !!Browser.Request(), Browser.Plugins.Flash = function() {\n    var version = ($try(function() {\n        return navigator.plugins[\"Shockwave Flash\"].description;\n    }, function() {\n        return new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\").GetVariable(\"$version\");\n    }) || \"0 r0\").match(/\\d+/g);\n    return {\n        version: parseInt(version[0] || \"0.\" + version[1], 10) || 0,\n        build: parseInt(version[2], 10) || 0\n    };\n}(), Native.UID = 1;\n\nvar $uid = Browser.Engine.trident ? function(item) {\n    return (item.uid || (item.uid = [ Native.UID++ ]))[0];\n} : function(item) {\n    return item.uid || (item.uid = Native.UID++);\n}, Window = new Native({\n    name: \"Window\",\n    legacy: Browser.Engine.trident ? null : window.Window,\n    initialize: function(win) {\n        return $uid(win), win.Element || (win.Element = $empty, Browser.Engine.webkit && win.document.createElement(\"iframe\"), \n        win.Element.prototype = Browser.Engine.webkit ? window[\"[[DOMElement.prototype]]\"] : {}), \n        win.document.window = win, $extend(win, Window.Prototype);\n    },\n    afterImplement: function(property, value) {\n        window[property] = Window.Prototype[property] = value;\n    }\n});\n\nWindow.Prototype = {\n    $family: {\n        name: \"window\"\n    }\n}, new Window(window);\n\nvar Document = new Native({\n    name: \"Document\",\n    legacy: Browser.Engine.trident ? null : window.Document,\n    initialize: function(doc) {\n        return $uid(doc), doc.head = doc.getElementsByTagName(\"head\")[0], doc.html = doc.getElementsByTagName(\"html\")[0], \n        Browser.Engine.trident && 4 >= Browser.Engine.version && $try(function() {\n            doc.execCommand(\"BackgroundImageCache\", !1, !0);\n        }), Browser.Engine.trident && doc.window.attachEvent(\"onunload\", function() {\n            doc.window.detachEvent(\"onunload\", arguments.callee), doc.head = doc.html = doc.window = null;\n        }), $extend(doc, Document.Prototype);\n    },\n    afterImplement: function(property, value) {\n        document[property] = Document.Prototype[property] = value;\n    }\n});\n\nDocument.Prototype = {\n    $family: {\n        name: \"document\"\n    }\n}, new Document(document), Array.implement({\n    every: function(fn, bind) {\n        for (var i = 0, l = this.length; l > i; i++) if (!fn.call(bind, this[i], i, this)) return !1;\n        return !0;\n    },\n    filter: function(fn, bind) {\n        for (var results = [], i = 0, l = this.length; l > i; i++) fn.call(bind, this[i], i, this) && results.push(this[i]);\n        return results;\n    },\n    clean: function() {\n        return this.filter($defined);\n    },\n    indexOf: function(item, from) {\n        for (var len = this.length, i = 0 > from ? Math.max(0, len + from) : from || 0; len > i; i++) if (this[i] === item) return i;\n        return -1;\n    },\n    map: function(fn, bind) {\n        for (var results = [], i = 0, l = this.length; l > i; i++) results[i] = fn.call(bind, this[i], i, this);\n        return results;\n    },\n    some: function(fn, bind) {\n        for (var i = 0, l = this.length; l > i; i++) if (fn.call(bind, this[i], i, this)) return !0;\n        return !1;\n    },\n    associate: function(keys) {\n        for (var obj = {}, length = Math.min(this.length, keys.length), i = 0; length > i; i++) obj[keys[i]] = this[i];\n        return obj;\n    },\n    link: function(object) {\n        for (var result = {}, i = 0, l = this.length; l > i; i++) for (var key in object) if (object[key](this[i])) {\n            result[key] = this[i], delete object[key];\n            break;\n        }\n        return result;\n    },\n    contains: function(item, from) {\n        return -1 != this.indexOf(item, from);\n    },\n    extend: function(array) {\n        for (var i = 0, j = array.length; j > i; i++) this.push(array[i]);\n        return this;\n    },\n    getLast: function() {\n        return this.length ? this[this.length - 1] : null;\n    },\n    getRandom: function() {\n        return this.length ? this[$random(0, this.length - 1)] : null;\n    },\n    include: function(item) {\n        return this.contains(item) || this.push(item), this;\n    },\n    combine: function(array) {\n        for (var i = 0, l = array.length; l > i; i++) this.include(array[i]);\n        return this;\n    },\n    erase: function(item) {\n        for (var i = this.length; i--; i) this[i] === item && this.splice(i, 1);\n        return this;\n    },\n    empty: function() {\n        return this.length = 0, this;\n    },\n    flatten: function() {\n        for (var array = [], i = 0, l = this.length; l > i; i++) {\n            var type = $type(this[i]);\n            type && (array = array.concat(\"array\" == type || \"collection\" == type || \"arguments\" == type ? Array.flatten(this[i]) : this[i]));\n        }\n        return array;\n    },\n    hexToRgb: function(array) {\n        if (3 != this.length) return null;\n        var rgb = this.map(function(value) {\n            return 1 == value.length && (value += value), value.toInt(16);\n        });\n        return array ? rgb : \"rgb(\" + rgb + \")\";\n    },\n    rgbToHex: function(array) {\n        if (3 > this.length) return null;\n        if (4 == this.length && 0 == this[3] && !array) return \"transparent\";\n        for (var hex = [], i = 0; 3 > i; i++) {\n            var bit = (this[i] - 0).toString(16);\n            hex.push(1 == bit.length ? \"0\" + bit : bit);\n        }\n        return array ? hex : \"#\" + hex.join(\"\");\n    }\n});\n\ntry {\n    delete Function.prototype.bind;\n} catch (e) {}\n\nFunction.implement({\n    extend: function(properties) {\n        for (var property in properties) this[property] = properties[property];\n        return this;\n    },\n    create: function(options) {\n        var self = this;\n        return options = options || {}, function(event) {\n            var args = options.arguments;\n            args = void 0 != args ? $splat(args) : Array.slice(arguments, options.event ? 1 : 0), \n            options.event && (args = [ event || window.event ].extend(args));\n            var returns = function() {\n                return self.apply(options.bind || null, args);\n            };\n            return options.delay ? setTimeout(returns, options.delay) : options.periodical ? setInterval(returns, options.periodical) : options.attempt ? $try(returns) : returns();\n        };\n    },\n    run: function(args, bind) {\n        return this.apply(bind, $splat(args));\n    },\n    pass: function(args, bind) {\n        return this.create({\n            bind: bind,\n            arguments: args\n        });\n    },\n    bind: function(bind, args) {\n        return this.create({\n            bind: bind,\n            arguments: args\n        });\n    },\n    bindWithEvent: function(bind, args) {\n        return this.create({\n            bind: bind,\n            arguments: args,\n            event: !0\n        });\n    },\n    attempt: function(args, bind) {\n        return this.create({\n            bind: bind,\n            arguments: args,\n            attempt: !0\n        })();\n    },\n    delay: function(delay, bind, args) {\n        return this.create({\n            bind: bind,\n            arguments: args,\n            delay: delay\n        })();\n    },\n    periodical: function(periodical, bind, args) {\n        return this.create({\n            bind: bind,\n            arguments: args,\n            periodical: periodical\n        })();\n    }\n}), Number.implement({\n    limit: function(min, max) {\n        return Math.min(max, Math.max(min, this));\n    },\n    round: function(precision) {\n        return precision = Math.pow(10, precision || 0), Math.round(this * precision) / precision;\n    },\n    times: function(fn, bind) {\n        for (var i = 0; this > i; i++) fn.call(bind, i, this);\n    },\n    toFloat: function() {\n        return parseFloat(this);\n    },\n    toInt: function(base) {\n        return parseInt(this, base || 10);\n    }\n}), Number.alias(\"times\", \"each\"), function(math) {\n    var methods = {};\n    math.each(function(name) {\n        Number[name] || (methods[name] = function() {\n            return Math[name].apply(null, [ this ].concat($A(arguments)));\n        });\n    }), Number.implement(methods);\n}([ \"abs\", \"acos\", \"asin\", \"atan\", \"atan2\", \"ceil\", \"cos\", \"exp\", \"floor\", \"log\", \"max\", \"min\", \"pow\", \"sin\", \"sqrt\", \"tan\" ]);\n\ntry {\n    delete String.prototype.contains;\n} catch (e) {}\n\nString.implement({\n    test: function(regex, params) {\n        return (\"string\" == typeof regex ? RegExp(regex, params) : regex).test(this);\n    },\n    contains: function(string, separator) {\n        return separator ? (separator + this + separator).indexOf(separator + string + separator) > -1 : this.indexOf(string) > -1;\n    },\n    trim: function() {\n        return this.replace(/^\\s+|\\s+$/g, \"\");\n    },\n    clean: function() {\n        return this.replace(/\\s+/g, \" \").trim();\n    },\n    camelCase: function() {\n        return this.replace(/-\\D/g, function(match) {\n            return match.charAt(1).toUpperCase();\n        });\n    },\n    hyphenate: function() {\n        return this.replace(/[A-Z]/g, function(match) {\n            return \"-\" + match.charAt(0).toLowerCase();\n        });\n    },\n    capitalize: function() {\n        return this.replace(/\\b[a-z]/g, function(match) {\n            return match.toUpperCase();\n        });\n    },\n    escapeRegExp: function() {\n        return this.replace(/([-.*+?^${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n    },\n    toInt: function(base) {\n        return parseInt(this, base || 10);\n    },\n    toFloat: function() {\n        return parseFloat(this);\n    },\n    hexToRgb: function(array) {\n        var hex = this.match(/^#?(\\w{1,2})(\\w{1,2})(\\w{1,2})$/);\n        return hex ? hex.slice(1).hexToRgb(array) : null;\n    },\n    rgbToHex: function(array) {\n        var rgb = this.match(/\\d{1,3}/g);\n        return rgb ? rgb.rgbToHex(array) : null;\n    },\n    stripScripts: function(option) {\n        var scripts = \"\", text = this.replace(/<script[^>]*>([\\s\\S]*?)<\\/script>/gi, function() {\n            return scripts += arguments[1] + \"\\n\", \"\";\n        });\n        return option === !0 ? $exec(scripts) : \"function\" == $type(option) && option(scripts, text), \n        text;\n    },\n    substitute: function(object, regexp) {\n        return this.replace(regexp || /\\\\?\\{([^{}]+)\\}/g, function(match, name) {\n            return \"\\\\\" == match.charAt(0) ? match.slice(1) : void 0 != object[name] ? object[name] : \"\";\n        });\n    }\n}), Hash.implement({\n    has: Object.prototype.hasOwnProperty,\n    keyOf: function(value) {\n        for (var key in this) if (this.hasOwnProperty(key) && this[key] === value) return key;\n        return null;\n    },\n    hasValue: function(value) {\n        return null !== Hash.keyOf(this, value);\n    },\n    extend: function(properties) {\n        return Hash.each(properties || {}, function(value, key) {\n            Hash.set(this, key, value);\n        }, this), this;\n    },\n    combine: function(properties) {\n        return Hash.each(properties || {}, function(value, key) {\n            Hash.include(this, key, value);\n        }, this), this;\n    },\n    erase: function(key) {\n        return this.hasOwnProperty(key) && delete this[key], this;\n    },\n    get: function(key) {\n        return this.hasOwnProperty(key) ? this[key] : null;\n    },\n    set: function(key, value) {\n        return (!this[key] || this.hasOwnProperty(key)) && (this[key] = value), this;\n    },\n    empty: function() {\n        return Hash.each(this, function(value, key) {\n            delete this[key];\n        }, this), this;\n    },\n    include: function(key, value) {\n        return void 0 == this[key] && (this[key] = value), this;\n    },\n    map: function(fn, bind) {\n        var results = new Hash();\n        return Hash.each(this, function(value, key) {\n            results.set(key, fn.call(bind, value, key, this));\n        }, this), results;\n    },\n    filter: function(fn, bind) {\n        var results = new Hash();\n        return Hash.each(this, function(value, key) {\n            fn.call(bind, value, key, this) && results.set(key, value);\n        }, this), results;\n    },\n    every: function(fn, bind) {\n        for (var key in this) if (this.hasOwnProperty(key) && !fn.call(bind, this[key], key)) return !1;\n        return !0;\n    },\n    some: function(fn, bind) {\n        for (var key in this) if (this.hasOwnProperty(key) && fn.call(bind, this[key], key)) return !0;\n        return !1;\n    },\n    getKeys: function() {\n        var keys = [];\n        return Hash.each(this, function(value, key) {\n            keys.push(key);\n        }), keys;\n    },\n    getValues: function() {\n        var values = [];\n        return Hash.each(this, function(value) {\n            values.push(value);\n        }), values;\n    },\n    toQueryString: function(base) {\n        var queryString = [];\n        return Hash.each(this, function(value, key) {\n            base && (key = base + \"[\" + key + \"]\");\n            var result;\n            switch ($type(value)) {\n              case \"object\":\n                result = Hash.toQueryString(value, key);\n                break;\n\n              case \"array\":\n                var qs = {};\n                value.each(function(val, i) {\n                    qs[i] = val;\n                }), result = Hash.toQueryString(qs, key);\n                break;\n\n              default:\n                result = key + \"=\" + encodeURIComponent(value);\n            }\n            void 0 != value && queryString.push(result);\n        }), queryString.join(\"&\");\n    }\n}), Hash.alias({\n    keyOf: \"indexOf\",\n    hasValue: \"contains\"\n});\n\nvar Event = new Native({\n    name: \"Event\",\n    initialize: function(event, win) {\n        win = win || window;\n        var doc = win.document;\n        if (event = event || win.event, event.$extended) return event;\n        this.$extended = !0;\n        for (var type = event.type, target = event.target || event.srcElement; target && 3 == target.nodeType; ) target = target.parentNode;\n        if (type.test(/key/)) {\n            var code = event.which || event.keyCode, key = Event.Keys.keyOf(code);\n            if (\"keydown\" == type) {\n                var fKey = code - 111;\n                fKey > 0 && 13 > fKey && (key = \"f\" + fKey);\n            }\n            key = key || String.fromCharCode(code).toLowerCase();\n        } else if (type.match(/(click|mouse|menu)/i)) {\n            doc = doc.compatMode && \"CSS1Compat\" != doc.compatMode ? doc.body : doc.html;\n            var page = {\n                x: event.pageX || event.clientX + doc.scrollLeft,\n                y: event.pageY || event.clientY + doc.scrollTop\n            }, client = {\n                x: event.pageX ? event.pageX - win.pageXOffset : event.clientX,\n                y: event.pageY ? event.pageY - win.pageYOffset : event.clientY\n            };\n            if (type.match(/DOMMouseScroll|mousewheel/)) var wheel = event.wheelDelta ? event.wheelDelta / 120 : -(event.detail || 0) / 3;\n            var rightClick = 3 == event.which || 2 == event.button, related = null;\n            if (type.match(/over|out/)) {\n                switch (type) {\n                  case \"mouseover\":\n                    related = event.relatedTarget || event.fromElement;\n                    break;\n\n                  case \"mouseout\":\n                    related = event.relatedTarget || event.toElement;\n                }\n                (function() {\n                    for (;related && 3 == related.nodeType; ) related = related.parentNode;\n                    return !0;\n                }).create({\n                    attempt: Browser.Engine.gecko\n                })() || (related = !1);\n            }\n        }\n        return $extend(this, {\n            event: event,\n            type: type,\n            page: page,\n            client: client,\n            rightClick: rightClick,\n            wheel: wheel,\n            relatedTarget: related,\n            target: target,\n            code: code,\n            key: key,\n            shift: event.shiftKey,\n            control: event.ctrlKey,\n            alt: event.altKey,\n            meta: event.metaKey\n        });\n    }\n});\n\nEvent.Keys = new Hash({\n    enter: 13,\n    up: 38,\n    down: 40,\n    left: 37,\n    right: 39,\n    esc: 27,\n    space: 32,\n    backspace: 8,\n    tab: 9,\n    \"delete\": 46\n}), Event.implement({\n    stop: function() {\n        return this.stopPropagation().preventDefault();\n    },\n    stopPropagation: function() {\n        return this.event.stopPropagation ? this.event.stopPropagation() : this.event.cancelBubble = !0, \n        this;\n    },\n    preventDefault: function() {\n        return this.event.preventDefault ? this.event.preventDefault() : this.event.returnValue = !1, \n        this;\n    }\n}), Function.prototype.protect = function() {\n    return this._protected = !0, this;\n}, Object.reset = function(object, key) {\n    if (null == key) {\n        for (var p in object) Object.reset(object, p);\n        return object;\n    }\n    switch (delete object[key], $type(object[key])) {\n      case \"object\":\n        var F = function() {};\n        F.prototype = object[key];\n        var i = new F();\n        object[key] = Object.reset(i);\n        break;\n\n      case \"array\":\n        object[key] = $unlink(object[key]);\n    }\n    return object;\n}, new Native({\n    name: \"Class\",\n    initialize: Class\n}).extend({\n    instantiate: function(F) {\n        F._prototyping = !0;\n        var proto = new F();\n        return delete F._prototyping, proto;\n    },\n    wrap: function(self, key, method) {\n        return method._origin && (method = method._origin), function() {\n            if (method._protected && null == this._current) throw Error('The method \"' + key + '\" cannot be called.');\n            var caller = this.caller, current = this._current;\n            this.caller = current, this._current = arguments.callee;\n            var result = method.apply(this, arguments);\n            return this._current = current, this.caller = caller, result;\n        }.extend({\n            _owner: self,\n            _origin: method,\n            _name: key\n        });\n    }\n}), Class.implement({\n    implement: function(key, value) {\n        if (\"object\" == $type(key)) {\n            for (var p in key) this.implement(p, key[p]);\n            return this;\n        }\n        var mutator = Class.Mutators[key];\n        if (mutator && (value = mutator.call(this, value), null == value)) return this;\n        var proto = this.prototype;\n        switch ($type(value)) {\n          case \"function\":\n            if (value._hidden) return this;\n            proto[key] = Class.wrap(this, key, value);\n            break;\n\n          case \"object\":\n            var previous = proto[key];\n            \"object\" == $type(previous) ? $mixin(previous, value) : proto[key] = $unlink(value);\n            break;\n\n          case \"array\":\n            proto[key] = $unlink(value);\n            break;\n\n          default:\n            proto[key] = value;\n        }\n        return this;\n    }\n}), Class.Mutators = {\n    Extends: function(parent) {\n        this.parent = parent, this.prototype = Class.instantiate(parent), this.implement(\"parent\", function() {\n            var name = this.caller._name, previous = this.caller._owner.parent.prototype[name];\n            if (!previous) throw Error('The method \"' + name + '\" has no parent.');\n            return previous.apply(this, arguments);\n        }.protect());\n    },\n    Implements: function(items) {\n        $splat(items).each(function(item) {\n            item instanceof Function && (item = Class.instantiate(item)), this.implement(item);\n        }, this);\n    }\n};\n\nvar Chain = new Class({\n    $chain: [],\n    chain: function() {\n        return this.$chain.extend(Array.flatten(arguments)), this;\n    },\n    callChain: function() {\n        return this.$chain.length ? this.$chain.shift().apply(this, arguments) : !1;\n    },\n    clearChain: function() {\n        return this.$chain.empty(), this;\n    }\n}), Events = new Class({\n    $events: {},\n    addEvent: function(type, fn, internal) {\n        return type = Events.removeOn(type), fn != $empty && (this.$events[type] = this.$events[type] || [], \n        this.$events[type].include(fn), internal && (fn.internal = !0)), this;\n    },\n    addEvents: function(events) {\n        for (var type in events) this.addEvent(type, events[type]);\n        return this;\n    },\n    fireEvent: function(type, args, delay) {\n        return type = Events.removeOn(type), this.$events && this.$events[type] ? (this.$events[type].each(function(fn) {\n            fn.create({\n                bind: this,\n                delay: delay,\n                arguments: args\n            })();\n        }, this), this) : this;\n    },\n    removeEvent: function(type, fn) {\n        return type = Events.removeOn(type), this.$events[type] ? (fn.internal || this.$events[type].erase(fn), \n        this) : this;\n    },\n    removeEvents: function(events) {\n        var type;\n        if (\"object\" == $type(events)) {\n            for (type in events) this.removeEvent(type, events[type]);\n            return this;\n        }\n        events && (events = Events.removeOn(events));\n        for (type in this.$events) if (!events || events == type) for (var fns = this.$events[type], i = fns.length; i--; i) this.removeEvent(type, fns[i]);\n        return this;\n    }\n});\n\nEvents.removeOn = function(string) {\n    return string.replace(/^on([A-Z])/, function(full, first) {\n        return first.toLowerCase();\n    });\n};\n\nvar Options = new Class({\n    setOptions: function() {\n        if (this.options = $merge.run([ this.options ].extend(arguments)), !this.addEvent) return this;\n        for (var option in this.options) \"function\" == $type(this.options[option]) && /^on[A-Z]/.test(option) && (this.addEvent(option, this.options[option]), \n        delete this.options[option]);\n        return this;\n    }\n}), Element = new Native({\n    name: \"Element\",\n    legacy: window.Element,\n    initialize: function(tag, props) {\n        var konstructor = Element.Constructors.get(tag);\n        return konstructor ? konstructor(props) : \"string\" == typeof tag ? document.newElement(tag, props) : document.id(tag).set(props);\n    },\n    afterImplement: function(key, value) {\n        Element.Prototype[key] = value, Array[key] || Elements.implement(key, function() {\n            for (var items = [], elements = !0, i = 0, j = this.length; j > i; i++) {\n                var returns = this[i][key].apply(this[i], arguments);\n                items.push(returns), elements && (elements = \"element\" == $type(returns));\n            }\n            return elements ? new Elements(items) : items;\n        });\n    }\n});\n\nElement.Prototype = {\n    $family: {\n        name: \"element\"\n    }\n}, Element.Constructors = new Hash();\n\nvar IFrame = new Native({\n    name: \"IFrame\",\n    generics: !1,\n    initialize: function() {\n        var params = Array.link(arguments, {\n            properties: Object.type,\n            iframe: $defined\n        }), props = params.properties || {}, iframe = document.id(params.iframe), onload = props.onload || $empty;\n        delete props.onload, props.id = props.name = $pick(props.id, props.name, iframe ? iframe.id || iframe.name : \"IFrame_\" + $time()), \n        iframe = new Element(iframe || \"iframe\", props);\n        var onFrameLoad = function() {\n            var host = $try(function() {\n                return iframe.contentWindow.location.host;\n            });\n            if (!host || host == window.location.host) {\n                var win = new Window(iframe.contentWindow);\n                new Document(iframe.contentWindow.document), $extend(win.Element.prototype, Element.Prototype);\n            }\n            onload.call(iframe.contentWindow, iframe.contentWindow.document);\n        }, contentWindow = $try(function() {\n            return iframe.contentWindow;\n        });\n        return contentWindow && contentWindow.document.body || window.frames[props.id] ? onFrameLoad() : iframe.addListener(\"load\", onFrameLoad), \n        iframe;\n    }\n}), Elements = new Native({\n    initialize: function(elements, options) {\n        if (options = $extend({\n            ddup: !0,\n            cash: !0\n        }, options), elements = elements || [], options.ddup || options.cash) {\n            for (var uniques = {}, returned = [], i = 0, l = elements.length; l > i; i++) {\n                var el = document.id(elements[i], !options.cash);\n                if (options.ddup) {\n                    if (uniques[el.uid]) continue;\n                    uniques[el.uid] = !0;\n                }\n                el && returned.push(el);\n            }\n            elements = returned;\n        }\n        return options.cash ? $extend(elements, this) : elements;\n    }\n});\n\nElements.implement({\n    filter: function(filter, bind) {\n        return filter ? new Elements(Array.filter(this, \"string\" == typeof filter ? function(item) {\n            return item.match(filter);\n        } : filter, bind)) : this;\n    }\n}), function() {\n    var createElementAcceptsHTML;\n    try {\n        var x = document.createElement(\"<input name=x>\");\n        createElementAcceptsHTML = \"x\" == x.name;\n    } catch (e) {}\n    var escapeQuotes = function(html) {\n        return (\"\" + html).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\");\n    };\n    Document.implement({\n        newElement: function(tag, props) {\n            return props && null != props.checked && (props.defaultChecked = props.checked), \n            createElementAcceptsHTML && props && (tag = \"<\" + tag, props.name && (tag += ' name=\"' + escapeQuotes(props.name) + '\"'), \n            props.type && (tag += ' type=\"' + escapeQuotes(props.type) + '\"'), tag += \">\", delete props.name, \n            delete props.type), this.id(this.createElement(tag)).set(props);\n        },\n        newTextNode: function(text) {\n            return this.createTextNode(text);\n        },\n        getDocument: function() {\n            return this;\n        },\n        getWindow: function() {\n            return this.window;\n        },\n        id: function() {\n            var types = {\n                string: function(id, nocash, doc) {\n                    return id = doc.getElementById(id), id ? types.element(id, nocash) : null;\n                },\n                element: function(el, nocash) {\n                    if ($uid(el), !nocash && !el.$family && !/^object|embed$/i.test(el.tagName)) {\n                        var proto = Element.Prototype;\n                        for (var p in proto) el[p] = proto[p];\n                    }\n                    return el;\n                },\n                object: function(obj, nocash, doc) {\n                    return obj.toElement ? types.element(obj.toElement(doc), nocash) : null;\n                }\n            };\n            return types.textnode = types.whitespace = types.window = types.document = $arguments(0), \n            function(el, nocash, doc) {\n                if (el && el.$family && el.uid) return el;\n                var type = $type(el);\n                return types[type] ? types[type](el, nocash, doc || document) : null;\n            };\n        }()\n    });\n}(), null == window.$ && Window.implement({\n    $: function(el, nc) {\n        return document.id(el, nc, this.document);\n    }\n}), Window.implement({\n    $$: function(selector) {\n        if (1 == arguments.length && \"string\" == typeof selector) return this.document.getElements(selector);\n        for (var elements = [], args = Array.flatten(arguments), i = 0, l = args.length; l > i; i++) {\n            var item = args[i];\n            switch ($type(item)) {\n              case \"element\":\n                elements.push(item);\n                break;\n\n              case \"string\":\n                elements.extend(this.document.getElements(item, !0));\n            }\n        }\n        return new Elements(elements);\n    },\n    getDocument: function() {\n        return this.document;\n    },\n    getWindow: function() {\n        return this;\n    }\n}), Native.implement([ Element, Document ], {\n    getElement: function(selector, nocash) {\n        return document.id(this.getElements(selector, !0)[0] || null, nocash);\n    },\n    getElements: function(tags, nocash) {\n        tags = tags.split(\",\");\n        var elements = [], ddup = tags.length > 1;\n        return tags.each(function(tag) {\n            var partial = this.getElementsByTagName(tag.trim());\n            ddup ? elements.extend(partial) : elements = partial;\n        }, this), new Elements(elements, {\n            ddup: ddup,\n            cash: !nocash\n        });\n    }\n}), function() {\n    var collected = {}, storage = {}, props = {\n        input: \"checked\",\n        option: \"selected\",\n        textarea: Browser.Engine.webkit && 420 > Browser.Engine.version ? \"innerHTML\" : \"value\"\n    }, get = function(uid) {\n        return storage[uid] || (storage[uid] = {});\n    }, clean = function(item, retain) {\n        if (item) {\n            var uid = item.uid;\n            if (retain !== !0 && (retain = !1), Browser.Engine.trident) {\n                if (item.clearAttributes) {\n                    var clone = retain && item.cloneNode(!1);\n                    item.clearAttributes(), clone && item.mergeAttributes(clone);\n                } else item.removeEvents && item.removeEvents();\n                if (/object/i.test(item.tagName)) {\n                    for (var p in item) \"function\" == typeof item[p] && (item[p] = $empty);\n                    Element.dispose(item);\n                }\n            }\n            uid && (collected[uid] = storage[uid] = null);\n        }\n    }, purge = function() {\n        Hash.each(collected, clean), Browser.Engine.trident && $A(document.getElementsByTagName(\"object\")).each(clean), \n        window.CollectGarbage && CollectGarbage(), collected = storage = null;\n    }, walk = function(element, walk, start, match, all, nocash) {\n        for (var el = element[start || walk], elements = []; el; ) {\n            if (1 == el.nodeType && (!match || Element.match(el, match))) {\n                if (!all) return document.id(el, nocash);\n                elements.push(el);\n            }\n            el = el[walk];\n        }\n        return all ? new Elements(elements, {\n            ddup: !1,\n            cash: !nocash\n        }) : null;\n    }, attributes = {\n        html: \"innerHTML\",\n        \"class\": \"className\",\n        \"for\": \"htmlFor\",\n        defaultValue: \"defaultValue\",\n        text: Browser.Engine.trident || Browser.Engine.webkit && 420 > Browser.Engine.version ? \"innerText\" : \"textContent\"\n    }, bools = [ \"compact\", \"nowrap\", \"ismap\", \"declare\", \"noshade\", \"checked\", \"disabled\", \"readonly\", \"multiple\", \"selected\", \"noresize\", \"defer\" ], camels = [ \"value\", \"type\", \"defaultValue\", \"accessKey\", \"cellPadding\", \"cellSpacing\", \"colSpan\", \"frameBorder\", \"maxLength\", \"readOnly\", \"rowSpan\", \"tabIndex\", \"useMap\" ];\n    bools = bools.associate(bools), Hash.extend(attributes, bools), Hash.extend(attributes, camels.associate(camels.map(String.toLowerCase)));\n    var inserters = {\n        before: function(context, element) {\n            element.parentNode && element.parentNode.insertBefore(context, element);\n        },\n        after: function(context, element) {\n            if (element.parentNode) {\n                var next = element.nextSibling;\n                next ? element.parentNode.insertBefore(context, next) : element.parentNode.appendChild(context);\n            }\n        },\n        bottom: function(context, element) {\n            element.appendChild(context);\n        },\n        top: function(context, element) {\n            var first = element.firstChild;\n            first ? element.insertBefore(context, first) : element.appendChild(context);\n        }\n    };\n    inserters.inside = inserters.bottom, Hash.each(inserters, function(inserter, where) {\n        where = where.capitalize(), Element.implement(\"inject\" + where, function(el) {\n            return inserter(this, document.id(el, !0)), this;\n        }), Element.implement(\"grab\" + where, function(el) {\n            return inserter(document.id(el, !0), this), this;\n        });\n    }), Element.implement({\n        set: function(prop, value) {\n            switch ($type(prop)) {\n              case \"object\":\n                for (var p in prop) this.set(p, prop[p]);\n                break;\n\n              case \"string\":\n                var property = Element.Properties.get(prop);\n                property && property.set ? property.set.apply(this, Array.slice(arguments, 1)) : this.setProperty(prop, value);\n            }\n            return this;\n        },\n        get: function(prop) {\n            var property = Element.Properties.get(prop);\n            return property && property.get ? property.get.apply(this, Array.slice(arguments, 1)) : this.getProperty(prop);\n        },\n        erase: function(prop) {\n            var property = Element.Properties.get(prop);\n            return property && property.erase ? property.erase.apply(this) : this.removeProperty(prop), \n            this;\n        },\n        setProperty: function(attribute, value) {\n            var key = attributes[attribute];\n            return void 0 == value ? this.removeProperty(attribute) : (key && bools[attribute] && (value = !!value), \n            key ? this[key] = value : this.setAttribute(attribute, \"\" + value), this);\n        },\n        setProperties: function(attributes) {\n            for (var attribute in attributes) this.setProperty(attribute, attributes[attribute]);\n            return this;\n        },\n        getProperty: function(attribute) {\n            var key = attributes[attribute], value = key ? this[key] : this.getAttribute(attribute, 2);\n            return bools[attribute] ? !!value : key ? value : value || null;\n        },\n        getProperties: function() {\n            var args = $A(arguments);\n            return args.map(this.getProperty, this).associate(args);\n        },\n        removeProperty: function(attribute) {\n            var key = attributes[attribute];\n            return key ? this[key] = key && bools[attribute] ? !1 : \"\" : this.removeAttribute(attribute), \n            this;\n        },\n        removeProperties: function() {\n            return Array.each(arguments, this.removeProperty, this), this;\n        },\n        hasClass: function(className) {\n            return this.className.contains(className, \" \");\n        },\n        addClass: function(className) {\n            return this.hasClass(className) || (this.className = (this.className + \" \" + className).clean()), \n            this;\n        },\n        removeClass: function(className) {\n            return this.className = this.className.replace(RegExp(\"(^|\\\\s)\" + className + \"(?:\\\\s|$)\"), \"$1\"), \n            this;\n        },\n        toggleClass: function(className) {\n            return this.hasClass(className) ? this.removeClass(className) : this.addClass(className);\n        },\n        adopt: function() {\n            return Array.flatten(arguments).each(function(element) {\n                element = document.id(element, !0), element && this.appendChild(element);\n            }, this), this;\n        },\n        appendText: function(text, where) {\n            return this.grab(this.getDocument().newTextNode(text), where);\n        },\n        grab: function(el, where) {\n            return inserters[where || \"bottom\"](document.id(el, !0), this), this;\n        },\n        inject: function(el, where) {\n            return inserters[where || \"bottom\"](this, document.id(el, !0)), this;\n        },\n        replaces: function(el) {\n            return el = document.id(el, !0), el.parentNode.replaceChild(this, el), this;\n        },\n        wraps: function(el, where) {\n            return el = document.id(el, !0), this.replaces(el).grab(el, where);\n        },\n        getPrevious: function(match, nocash) {\n            return walk(this, \"previousSibling\", null, match, !1, nocash);\n        },\n        getAllPrevious: function(match, nocash) {\n            return walk(this, \"previousSibling\", null, match, !0, nocash);\n        },\n        getNext: function(match, nocash) {\n            return walk(this, \"nextSibling\", null, match, !1, nocash);\n        },\n        getAllNext: function(match, nocash) {\n            return walk(this, \"nextSibling\", null, match, !0, nocash);\n        },\n        getFirst: function(match, nocash) {\n            return walk(this, \"nextSibling\", \"firstChild\", match, !1, nocash);\n        },\n        getLast: function(match, nocash) {\n            return walk(this, \"previousSibling\", \"lastChild\", match, !1, nocash);\n        },\n        getParent: function(match, nocash) {\n            return walk(this, \"parentNode\", null, match, !1, nocash);\n        },\n        getParents: function(match, nocash) {\n            return walk(this, \"parentNode\", null, match, !0, nocash);\n        },\n        getSiblings: function(match, nocash) {\n            return this.getParent().getChildren(match, nocash).erase(this);\n        },\n        getChildren: function(match, nocash) {\n            return walk(this, \"nextSibling\", \"firstChild\", match, !0, nocash);\n        },\n        getWindow: function() {\n            return this.ownerDocument.window;\n        },\n        getDocument: function() {\n            return this.ownerDocument;\n        },\n        getElementById: function(id, nocash) {\n            var el = this.ownerDocument.getElementById(id);\n            if (!el) return null;\n            for (var parent = el.parentNode; parent != this; parent = parent.parentNode) if (!parent) return null;\n            return document.id(el, nocash);\n        },\n        getSelected: function() {\n            return new Elements($A(this.options).filter(function(option) {\n                return option.selected;\n            }));\n        },\n        getComputedStyle: function(property) {\n            if (this.currentStyle) return this.currentStyle[property.camelCase()];\n            var computed = this.getDocument().defaultView.getComputedStyle(this, null);\n            return computed ? computed.getPropertyValue([ property.hyphenate() ]) : null;\n        },\n        toQueryString: function() {\n            var queryString = [];\n            return this.getElements(\"input, select, textarea\", !0).each(function(el) {\n                if (el.name && !el.disabled && \"submit\" != el.type && \"reset\" != el.type && \"file\" != el.type) {\n                    var value = \"select\" == el.tagName.toLowerCase() ? Element.getSelected(el).map(function(opt) {\n                        return opt.value;\n                    }) : \"radio\" != el.type && \"checkbox\" != el.type || el.checked ? el.value : null;\n                    $splat(value).each(function(val) {\n                        val !== void 0 && queryString.push(el.name + \"=\" + encodeURIComponent(val));\n                    });\n                }\n            }), queryString.join(\"&\");\n        },\n        clone: function(contents, keepid) {\n            contents = contents !== !1;\n            var clone = this.cloneNode(contents), clean = function(node, element) {\n                if (keepid || node.removeAttribute(\"id\"), Browser.Engine.trident && (node.clearAttributes(), \n                node.mergeAttributes(element), node.removeAttribute(\"uid\"), node.options)) for (var no = node.options, eo = element.options, j = no.length; j--; ) no[j].selected = eo[j].selected;\n                var prop = props[element.tagName.toLowerCase()];\n                prop && element[prop] && (node[prop] = element[prop]);\n            };\n            if (contents) for (var ce = clone.getElementsByTagName(\"*\"), te = this.getElementsByTagName(\"*\"), i = ce.length; i--; ) clean(ce[i], te[i]);\n            return clean(clone, this), document.id(clone);\n        },\n        destroy: function() {\n            return Element.empty(this), Element.dispose(this), clean(this, !0), null;\n        },\n        empty: function() {\n            return $A(this.childNodes).each(function(node) {\n                Element.destroy(node);\n            }), this;\n        },\n        dispose: function() {\n            return this.parentNode ? this.parentNode.removeChild(this) : this;\n        },\n        hasChild: function(el) {\n            return el = document.id(el, !0), el ? Browser.Engine.webkit && 420 > Browser.Engine.version ? $A(this.getElementsByTagName(el.tagName)).contains(el) : this.contains ? this != el && this.contains(el) : !!(16 & this.compareDocumentPosition(el)) : !1;\n        },\n        match: function(tag) {\n            return !tag || tag == this || Element.get(this, \"tag\") == tag;\n        }\n    }), Native.implement([ Element, Window, Document ], {\n        addListener: function(type, fn) {\n            if (\"unload\" == type) {\n                var old = fn, self = this;\n                fn = function() {\n                    self.removeListener(\"unload\", fn), old();\n                };\n            } else collected[this.uid] = this;\n            return this.addEventListener ? this.addEventListener(type, fn, !1) : this.attachEvent(\"on\" + type, fn), \n            this;\n        },\n        removeListener: function(type, fn) {\n            return this.removeEventListener ? this.removeEventListener(type, fn, !1) : this.detachEvent(\"on\" + type, fn), \n            this;\n        },\n        retrieve: function(property, dflt) {\n            var storage = get(this.uid), prop = storage[property];\n            return void 0 != dflt && void 0 == prop && (prop = storage[property] = dflt), $pick(prop);\n        },\n        store: function(property, value) {\n            var storage = get(this.uid);\n            return storage[property] = value, this;\n        },\n        eliminate: function(property) {\n            var storage = get(this.uid);\n            return delete storage[property], this;\n        }\n    }), window.addListener(\"unload\", purge);\n}(), Element.Properties = new Hash(), Element.Properties.style = {\n    set: function(style) {\n        this.style.cssText = style;\n    },\n    get: function() {\n        return this.style.cssText;\n    },\n    erase: function() {\n        this.style.cssText = \"\";\n    }\n}, Element.Properties.tag = {\n    get: function() {\n        return this.tagName.toLowerCase();\n    }\n}, Element.Properties.html = function() {\n    var BUGGY_INNERHTML = !0;\n    try {\n        var tester = document.createElement(\"tr\");\n        tester.innerHTML = \"<td>x\", tester = tester.firstChild, BUGGY_INNERHTML = !(\"TD\" == tester.nodeName && \"x\" == tester.innerHTML);\n    } catch (e) {}\n    if (!BUGGY_INNERHTML) return {\n        set: function() {\n            this.innerHTML = Array.flatten(arguments).join(\"\");\n        }\n    };\n    var wrapper = document.createElement(\"div\"), translations = {\n        table: [ 1, \"<table>\", \"</table>\" ],\n        select: [ 1, \"<select>\", \"</select>\" ],\n        tbody: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n        tr: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ]\n    };\n    translations.thead = translations.tfoot = translations.tbody;\n    var html = {\n        set: function() {\n            var html = Array.flatten(arguments).join(\"\"), wrap = translations[this.get(\"tag\")];\n            if (wrap) {\n                var first = wrapper;\n                first.innerHTML = wrap[1] + html + wrap[2];\n                for (var i = wrap[0]; i--; ) first = first.firstChild;\n                this.empty().adopt(first.childNodes);\n            } else this.innerHTML = html;\n        }\n    };\n    return html.erase = html.set, html;\n}(), Browser.Engine.webkit && 420 > Browser.Engine.version && (Element.Properties.text = {\n    get: function() {\n        if (this.innerText) return this.innerText;\n        var temp = this.ownerDocument.newElement(\"div\", {\n            html: this.innerHTML\n        }).inject(this.ownerDocument.body), text = temp.innerText;\n        return temp.destroy(), text;\n    }\n}), Element.Properties.events = {\n    set: function(events) {\n        this.addEvents(events);\n    }\n}, Native.implement([ Element, Window, Document ], {\n    addEvent: function(type, fn) {\n        var events = this.retrieve(\"events\", {});\n        if (events[type] = events[type] || {\n            keys: [],\n            values: []\n        }, events[type].keys.contains(fn)) return this;\n        events[type].keys.push(fn);\n        var realType = type, custom = Element.Events.get(type), condition = fn, self = this;\n        custom && (custom.onAdd && custom.onAdd.call(this, fn), custom.condition && (condition = function(event) {\n            return custom.condition.call(this, event) ? fn.call(this, event) : !0;\n        }), realType = custom.base || realType);\n        var defn = function() {\n            return fn.call(self);\n        }, nativeEvent = Element.NativeEvents[realType];\n        return nativeEvent && (2 == nativeEvent && (defn = function(event) {\n            event = new Event(event, self.getWindow()), condition.call(self, event) === !1 && event.stop();\n        }), this.addListener(realType, defn)), events[type].values.push(defn), this;\n    },\n    removeEvent: function(type, fn) {\n        var events = this.retrieve(\"events\");\n        if (!events || !events[type]) return this;\n        var pos = events[type].keys.indexOf(fn);\n        if (-1 == pos) return this;\n        events[type].keys.splice(pos, 1);\n        var value = events[type].values.splice(pos, 1)[0], custom = Element.Events.get(type);\n        return custom && (custom.onRemove && custom.onRemove.call(this, fn), type = custom.base || type), \n        Element.NativeEvents[type] ? this.removeListener(type, value) : this;\n    },\n    addEvents: function(events) {\n        for (var event in events) this.addEvent(event, events[event]);\n        return this;\n    },\n    removeEvents: function(events) {\n        var type;\n        if (\"object\" == $type(events)) {\n            for (type in events) this.removeEvent(type, events[type]);\n            return this;\n        }\n        var attached = this.retrieve(\"events\");\n        if (!attached) return this;\n        if (events) {\n            if (attached[events]) {\n                for (;attached[events].keys[0]; ) this.removeEvent(events, attached[events].keys[0]);\n                attached[events] = null;\n            }\n        } else {\n            for (type in attached) this.removeEvents(type);\n            this.eliminate(\"events\");\n        }\n        return this;\n    },\n    fireEvent: function(type, args, delay) {\n        var events = this.retrieve(\"events\");\n        return events && events[type] ? (events[type].keys.each(function(fn) {\n            fn.create({\n                bind: this,\n                delay: delay,\n                arguments: args\n            })();\n        }, this), this) : this;\n    },\n    cloneEvents: function(from, type) {\n        from = document.id(from);\n        var fevents = from.retrieve(\"events\");\n        if (!fevents) return this;\n        if (type) fevents[type] && fevents[type].keys.each(function(fn) {\n            this.addEvent(type, fn);\n        }, this); else for (var evType in fevents) this.cloneEvents(from, evType);\n        return this;\n    }\n});\n\ntry {\n    \"undefined\" != typeof HTMLElement && (HTMLElement.prototype.fireEvent = Element.prototype.fireEvent);\n} catch (e) {}\n\nElement.NativeEvents = {\n    click: 2,\n    dblclick: 2,\n    mouseup: 2,\n    mousedown: 2,\n    contextmenu: 2,\n    mousewheel: 2,\n    DOMMouseScroll: 2,\n    mouseover: 2,\n    mouseout: 2,\n    mousemove: 2,\n    selectstart: 2,\n    selectend: 2,\n    keydown: 2,\n    keypress: 2,\n    keyup: 2,\n    focus: 2,\n    blur: 2,\n    change: 2,\n    reset: 2,\n    select: 2,\n    submit: 2,\n    load: 1,\n    unload: 1,\n    beforeunload: 2,\n    resize: 1,\n    move: 1,\n    DOMContentLoaded: 1,\n    readystatechange: 1,\n    error: 1,\n    abort: 1,\n    scroll: 1\n}, function() {\n    var $check = function(event) {\n        var related = event.relatedTarget;\n        return void 0 == related ? !0 : related === !1 ? !1 : \"document\" != $type(this) && related != this && \"xul\" != related.prefix && !this.hasChild(related);\n    };\n    Element.Events = new Hash({\n        mouseenter: {\n            base: \"mouseover\",\n            condition: $check\n        },\n        mouseleave: {\n            base: \"mouseout\",\n            condition: $check\n        },\n        mousewheel: {\n            base: Browser.Engine.gecko ? \"DOMMouseScroll\" : \"mousewheel\"\n        }\n    });\n}(), Element.Properties.styles = {\n    set: function(styles) {\n        this.setStyles(styles);\n    }\n}, Element.Properties.opacity = {\n    set: function(opacity, novisibility) {\n        novisibility || (0 == opacity ? \"hidden\" != this.style.visibility && (this.style.visibility = \"hidden\") : \"visible\" != this.style.visibility && (this.style.visibility = \"visible\")), \n        this.currentStyle && this.currentStyle.hasLayout || (this.style.zoom = 1), Browser.Engine.trident && (this.style.filter = 1 == opacity ? \"\" : \"alpha(opacity=\" + 100 * opacity + \")\"), \n        this.style.opacity = opacity, this.store(\"opacity\", opacity);\n    },\n    get: function() {\n        return this.retrieve(\"opacity\", 1);\n    }\n}, Element.implement({\n    setOpacity: function(value) {\n        return this.set(\"opacity\", value, !0);\n    },\n    getOpacity: function() {\n        return this.get(\"opacity\");\n    },\n    setStyle: function(property, value) {\n        switch (property) {\n          case \"opacity\":\n            return this.set(\"opacity\", parseFloat(value));\n\n          case \"float\":\n            property = Browser.Engine.trident ? \"styleFloat\" : \"cssFloat\";\n        }\n        if (property = property.camelCase(), \"string\" != $type(value)) {\n            var map = (Element.Styles.get(property) || \"@\").split(\" \");\n            value = $splat(value).map(function(val, i) {\n                return map[i] ? \"number\" == $type(val) ? map[i].replace(\"@\", Math.round(val)) : val : \"\";\n            }).join(\" \");\n        } else value == Number(value) + \"\" && (value = Math.round(value));\n        return this.style[property] = value, this;\n    },\n    getStyle: function(property) {\n        switch (property) {\n          case \"opacity\":\n            return this.get(\"opacity\");\n\n          case \"float\":\n            property = Browser.Engine.trident ? \"styleFloat\" : \"cssFloat\";\n        }\n        property = property.camelCase();\n        var result = this.style[property];\n        if (!$chk(result)) {\n            result = [];\n            for (var style in Element.ShortStyles) if (property == style) {\n                for (var s in Element.ShortStyles[style]) result.push(this.getStyle(s));\n                return result.join(\" \");\n            }\n            result = this.getComputedStyle(property);\n        }\n        if (result) {\n            result += \"\";\n            var color = result.match(/rgba?\\([\\d\\s,]+\\)/);\n            color && (result = result.replace(color[0], color[0].rgbToHex()));\n        }\n        if (Browser.Engine.presto || Browser.Engine.trident && !$chk(parseInt(result, 10))) {\n            if (property.test(/^(height|width)$/)) {\n                var values = \"width\" == property ? [ \"left\", \"right\" ] : [ \"top\", \"bottom\" ], size = 0;\n                return values.each(function(value) {\n                    size += this.getStyle(\"border-\" + value + \"-width\").toInt() + this.getStyle(\"padding-\" + value).toInt();\n                }, this), this[\"offset\" + property.capitalize()] - size + \"px\";\n            }\n            if (Browser.Engine.presto && (result + \"\").test(\"px\")) return result;\n            if (property.test(/(border(.+)Width|margin|padding)/)) return \"0px\";\n        }\n        return result;\n    },\n    setStyles: function(styles) {\n        for (var style in styles) this.setStyle(style, styles[style]);\n        return this;\n    },\n    getStyles: function() {\n        var result = {};\n        return Array.flatten(arguments).each(function(key) {\n            result[key] = this.getStyle(key);\n        }, this), result;\n    }\n}), Element.Styles = new Hash({\n    left: \"@px\",\n    top: \"@px\",\n    bottom: \"@px\",\n    right: \"@px\",\n    width: \"@px\",\n    height: \"@px\",\n    maxWidth: \"@px\",\n    maxHeight: \"@px\",\n    minWidth: \"@px\",\n    minHeight: \"@px\",\n    backgroundColor: \"rgb(@, @, @)\",\n    backgroundPosition: \"@px @px\",\n    color: \"rgb(@, @, @)\",\n    fontSize: \"@px\",\n    letterSpacing: \"@px\",\n    lineHeight: \"@px\",\n    clip: \"rect(@px @px @px @px)\",\n    margin: \"@px @px @px @px\",\n    padding: \"@px @px @px @px\",\n    border: \"@px @ rgb(@, @, @) @px @ rgb(@, @, @) @px @ rgb(@, @, @)\",\n    borderWidth: \"@px @px @px @px\",\n    borderStyle: \"@ @ @ @\",\n    borderColor: \"rgb(@, @, @) rgb(@, @, @) rgb(@, @, @) rgb(@, @, @)\",\n    zIndex: \"@\",\n    zoom: \"@\",\n    fontWeight: \"@\",\n    textIndent: \"@px\",\n    opacity: \"@\"\n}), Element.ShortStyles = {\n    margin: {},\n    padding: {},\n    border: {},\n    borderWidth: {},\n    borderStyle: {},\n    borderColor: {}\n}, [ \"Top\", \"Right\", \"Bottom\", \"Left\" ].each(function(direction) {\n    var Short = Element.ShortStyles, All = Element.Styles;\n    [ \"margin\", \"padding\" ].each(function(style) {\n        var sd = style + direction;\n        Short[style][sd] = All[sd] = \"@px\";\n    });\n    var bd = \"border\" + direction;\n    Short.border[bd] = All[bd] = \"@px @ rgb(@, @, @)\";\n    var bdw = bd + \"Width\", bds = bd + \"Style\", bdc = bd + \"Color\";\n    Short[bd] = {}, Short.borderWidth[bdw] = Short[bd][bdw] = All[bdw] = \"@px\", Short.borderStyle[bds] = Short[bd][bds] = All[bds] = \"@\", \n    Short.borderColor[bdc] = Short[bd][bdc] = All[bdc] = \"rgb(@, @, @)\";\n}), function() {\n    function styleNumber(element, style) {\n        return styleString(element, style).toInt() || 0;\n    }\n    function borderBox(element) {\n        return \"border-box\" == styleString(element, \"-moz-box-sizing\");\n    }\n    function topBorder(element) {\n        return styleNumber(element, \"border-top-width\");\n    }\n    function leftBorder(element) {\n        return styleNumber(element, \"border-left-width\");\n    }\n    function isBody(element) {\n        return /^(?:body|html)$/i.test(element.tagName);\n    }\n    function getCompatElement(element) {\n        var doc = element.getDocument();\n        return doc.compatMode && \"CSS1Compat\" != doc.compatMode ? doc.body : doc.html;\n    }\n    Element.implement({\n        scrollTo: function(x, y) {\n            return isBody(this) ? this.getWindow().scrollTo(x, y) : (this.scrollLeft = x, this.scrollTop = y), \n            this;\n        },\n        getSize: function() {\n            return isBody(this) ? this.getWindow().getSize() : {\n                x: this.offsetWidth,\n                y: this.offsetHeight\n            };\n        },\n        getScrollSize: function() {\n            return isBody(this) ? this.getWindow().getScrollSize() : {\n                x: this.scrollWidth,\n                y: this.scrollHeight\n            };\n        },\n        getScroll: function() {\n            return isBody(this) ? this.getWindow().getScroll() : {\n                x: this.scrollLeft,\n                y: this.scrollTop\n            };\n        },\n        getScrolls: function() {\n            for (var element = this, position = {\n                x: 0,\n                y: 0\n            }; element && !isBody(element); ) position.x += element.scrollLeft, position.y += element.scrollTop, \n            element = element.parentNode;\n            return position;\n        },\n        getOffsetParent: function() {\n            var element = this;\n            if (isBody(element)) return null;\n            if (!Browser.Engine.trident) return element.offsetParent;\n            for (;(element = element.parentNode) && !isBody(element); ) if (\"static\" != styleString(element, \"position\")) return element;\n            return null;\n        },\n        getOffsets: function() {\n            if (this.getBoundingClientRect) {\n                var bound = this.getBoundingClientRect(), html = document.id(this.getDocument().documentElement), htmlScroll = html.getScroll(), elemScrolls = this.getScrolls(), elemScroll = this.getScroll(), isFixed = \"fixed\" == styleString(this, \"position\");\n                return {\n                    x: bound.left.toInt() + elemScrolls.x - elemScroll.x + (isFixed ? 0 : htmlScroll.x) - html.clientLeft,\n                    y: bound.top.toInt() + elemScrolls.y - elemScroll.y + (isFixed ? 0 : htmlScroll.y) - html.clientTop\n                };\n            }\n            var element = this, position = {\n                x: 0,\n                y: 0\n            };\n            if (isBody(this)) return position;\n            for (;element && !isBody(element); ) {\n                if (position.x += element.offsetLeft, position.y += element.offsetTop, Browser.Engine.gecko) {\n                    borderBox(element) || (position.x += leftBorder(element), position.y += topBorder(element));\n                    var parent = element.parentNode;\n                    parent && \"visible\" != styleString(parent, \"overflow\") && (position.x += leftBorder(parent), \n                    position.y += topBorder(parent));\n                } else element != this && Browser.Engine.webkit && (position.x += leftBorder(element), \n                position.y += topBorder(element));\n                element = element.offsetParent;\n            }\n            return Browser.Engine.gecko && !borderBox(this) && (position.x -= leftBorder(this), \n            position.y -= topBorder(this)), position;\n        },\n        getPosition: function(relative) {\n            if (isBody(this)) return {\n                x: 0,\n                y: 0\n            };\n            var offset = this.getOffsets(), scroll = this.getScrolls(), position = {\n                x: offset.x - scroll.x,\n                y: offset.y - scroll.y\n            }, relativePosition = relative && (relative = document.id(relative)) ? relative.getPosition() : {\n                x: 0,\n                y: 0\n            };\n            return {\n                x: position.x - relativePosition.x,\n                y: position.y - relativePosition.y\n            };\n        },\n        getCoordinates: function(element) {\n            if (isBody(this)) return this.getWindow().getCoordinates();\n            var position = this.getPosition(element), size = this.getSize(), obj = {\n                left: position.x,\n                top: position.y,\n                width: size.x,\n                height: size.y\n            };\n            return obj.right = obj.left + obj.width, obj.bottom = obj.top + obj.height, obj;\n        },\n        computePosition: function(obj) {\n            return {\n                left: obj.x - styleNumber(this, \"margin-left\"),\n                top: obj.y - styleNumber(this, \"margin-top\")\n            };\n        },\n        setPosition: function(obj) {\n            return this.setStyles(this.computePosition(obj));\n        }\n    }), Native.implement([ Document, Window ], {\n        getSize: function() {\n            if (Browser.Engine.presto || Browser.Engine.webkit) {\n                var win = this.getWindow();\n                return {\n                    x: win.innerWidth,\n                    y: win.innerHeight\n                };\n            }\n            var doc = getCompatElement(this);\n            return {\n                x: doc.clientWidth,\n                y: doc.clientHeight\n            };\n        },\n        getScroll: function() {\n            var win = this.getWindow(), doc = getCompatElement(this);\n            return {\n                x: win.pageXOffset || doc.scrollLeft,\n                y: win.pageYOffset || doc.scrollTop\n            };\n        },\n        getScrollSize: function() {\n            var doc = getCompatElement(this), min = this.getSize();\n            return {\n                x: Math.max(doc.scrollWidth, min.x),\n                y: Math.max(doc.scrollHeight, min.y)\n            };\n        },\n        getPosition: function() {\n            return {\n                x: 0,\n                y: 0\n            };\n        },\n        getCoordinates: function() {\n            var size = this.getSize();\n            return {\n                top: 0,\n                left: 0,\n                bottom: size.y,\n                right: size.x,\n                height: size.y,\n                width: size.x\n            };\n        }\n    });\n    var styleString = Element.getComputedStyle;\n}(), Element.alias(\"setPosition\", \"position\"), Native.implement([ Window, Document, Element ], {\n    getHeight: function() {\n        return this.getSize().y;\n    },\n    getWidth: function() {\n        return this.getSize().x;\n    },\n    getScrollTop: function() {\n        return this.getScroll().y;\n    },\n    getScrollLeft: function() {\n        return this.getScroll().x;\n    },\n    getScrollHeight: function() {\n        return this.getScrollSize().y;\n    },\n    getScrollWidth: function() {\n        return this.getScrollSize().x;\n    },\n    getTop: function() {\n        return this.getPosition().y;\n    },\n    getLeft: function() {\n        return this.getPosition().x;\n    }\n}), Native.implement([ Document, Element ], {\n    getElements: function(expression, nocash) {\n        expression = expression.split(\",\");\n        for (var items, local = {}, i = 0, l = expression.length; l > i; i++) {\n            var selector = expression[i], elements = Selectors.Utils.search(this, selector, local);\n            0 != i && elements.item && (elements = $A(elements)), items = 0 == i ? elements : items.item ? $A(items).concat(elements) : items.concat(elements);\n        }\n        return new Elements(items, {\n            ddup: expression.length > 1,\n            cash: !nocash\n        });\n    }\n}), Element.implement({\n    match: function(selector) {\n        if (!selector || selector == this) return !0;\n        var tagid = Selectors.Utils.parseTagAndID(selector), tag = tagid[0], id = tagid[1];\n        if (!Selectors.Filters.byID(this, id) || !Selectors.Filters.byTag(this, tag)) return !1;\n        var parsed = Selectors.Utils.parseSelector(selector);\n        return parsed ? Selectors.Utils.filter(this, parsed, {}) : !0;\n    }\n});\n\nvar Selectors = {\n    Cache: {\n        nth: {},\n        parsed: {}\n    }\n};\n\nSelectors.RegExps = {\n    id: /#([\\w-]+)/,\n    tag: /^(\\w+|\\*)/,\n    quick: /^(\\w+|\\*)$/,\n    splitter: /\\s*([+>~\\s])\\s*([a-zA-Z#.*:\\[])/g,\n    combined: /\\.([\\w-]+)|\\[(\\w+)(?:([!*^$~|]?=)([\"']?)([^\\4]*?)\\4)?\\]|:([\\w-]+)(?:\\([\"']?(.*?)?[\"']?\\)|$)/g\n}, Selectors.Utils = {\n    chk: function(item, uniques) {\n        if (!uniques) return !0;\n        var uid = $uid(item);\n        return uniques[uid] ? !1 : uniques[uid] = !0;\n    },\n    parseNthArgument: function(argument) {\n        if (Selectors.Cache.nth[argument]) return Selectors.Cache.nth[argument];\n        var parsed = argument.match(/^([+-]?\\d*)?([a-z]+)?([+-]?\\d*)?$/);\n        if (!parsed) return !1;\n        var inta = parseInt(parsed[1], 10), a = inta || 0 === inta ? inta : 1, special = parsed[2] || !1, b = parseInt(parsed[3], 10) || 0;\n        if (0 != a) {\n            for (b--; 1 > b; ) b += a;\n            for (;b >= a; ) b -= a;\n        } else a = b, special = \"index\";\n        switch (special) {\n          case \"n\":\n            parsed = {\n                a: a,\n                b: b,\n                special: \"n\"\n            };\n            break;\n\n          case \"odd\":\n            parsed = {\n                a: 2,\n                b: 0,\n                special: \"n\"\n            };\n            break;\n\n          case \"even\":\n            parsed = {\n                a: 2,\n                b: 1,\n                special: \"n\"\n            };\n            break;\n\n          case \"first\":\n            parsed = {\n                a: 0,\n                special: \"index\"\n            };\n            break;\n\n          case \"last\":\n            parsed = {\n                special: \"last-child\"\n            };\n            break;\n\n          case \"only\":\n            parsed = {\n                special: \"only-child\"\n            };\n            break;\n\n          default:\n            parsed = {\n                a: a - 1,\n                special: \"index\"\n            };\n        }\n        return Selectors.Cache.nth[argument] = parsed;\n    },\n    parseSelector: function(selector) {\n        if (Selectors.Cache.parsed[selector]) return Selectors.Cache.parsed[selector];\n        for (var m, parsed = {\n            classes: [],\n            pseudos: [],\n            attributes: []\n        }; m = Selectors.RegExps.combined.exec(selector); ) {\n            var cn = m[1], an = m[2], ao = m[3], av = m[5], pn = m[6], pa = m[7];\n            if (cn) parsed.classes.push(cn); else if (pn) {\n                var parser = Selectors.Pseudo.get(pn);\n                parser ? parsed.pseudos.push({\n                    parser: parser,\n                    argument: pa\n                }) : parsed.attributes.push({\n                    name: pn,\n                    operator: \"=\",\n                    value: pa\n                });\n            } else an && parsed.attributes.push({\n                name: an,\n                operator: ao,\n                value: av\n            });\n        }\n        return parsed.classes.length || delete parsed.classes, parsed.attributes.length || delete parsed.attributes, \n        parsed.pseudos.length || delete parsed.pseudos, parsed.classes || parsed.attributes || parsed.pseudos || (parsed = null), \n        Selectors.Cache.parsed[selector] = parsed;\n    },\n    parseTagAndID: function(selector) {\n        var tag = selector.match(Selectors.RegExps.tag), id = selector.match(Selectors.RegExps.id);\n        return [ tag ? tag[1] : \"*\", id ? id[1] : !1 ];\n    },\n    filter: function(item, parsed, local) {\n        var i;\n        if (parsed.classes) for (i = parsed.classes.length; i--; i) {\n            var cn = parsed.classes[i];\n            if (!Selectors.Filters.byClass(item, cn)) return !1;\n        }\n        if (parsed.attributes) for (i = parsed.attributes.length; i--; i) {\n            var att = parsed.attributes[i];\n            if (!Selectors.Filters.byAttribute(item, att.name, att.operator, att.value)) return !1;\n        }\n        if (parsed.pseudos) for (i = parsed.pseudos.length; i--; i) {\n            var psd = parsed.pseudos[i];\n            if (!Selectors.Filters.byPseudo(item, psd.parser, psd.argument, local)) return !1;\n        }\n        return !0;\n    },\n    getByTagAndID: function(ctx, tag, id) {\n        if (id) {\n            var item = ctx.getElementById ? ctx.getElementById(id, !0) : Element.getElementById(ctx, id, !0);\n            return item && Selectors.Filters.byTag(item, tag) ? [ item ] : [];\n        }\n        return ctx.getElementsByTagName(tag);\n    },\n    search: function(self, expression, local) {\n        for (var items, filtered, item, splitters = [], selectors = expression.trim().replace(Selectors.RegExps.splitter, function(m0, m1, m2) {\n            return splitters.push(m1), \":)\" + m2;\n        }).split(\":)\"), i = 0, l = selectors.length; l > i; i++) {\n            var selector = selectors[i];\n            if (0 == i && Selectors.RegExps.quick.test(selector)) items = self.getElementsByTagName(selector); else {\n                var splitter = splitters[i - 1], tagid = Selectors.Utils.parseTagAndID(selector), tag = tagid[0], id = tagid[1];\n                if (0 == i) items = Selectors.Utils.getByTagAndID(self, tag, id); else {\n                    for (var uniques = {}, found = [], j = 0, k = items.length; k > j; j++) found = Selectors.Getters[splitter](found, items[j], tag, id, uniques);\n                    items = found;\n                }\n                var parsed = Selectors.Utils.parseSelector(selector);\n                if (parsed) {\n                    filtered = [];\n                    for (var m = 0, n = items.length; n > m; m++) item = items[m], Selectors.Utils.filter(item, parsed, local) && filtered.push(item);\n                    items = filtered;\n                }\n            }\n        }\n        return items;\n    }\n}, Selectors.Getters = {\n    \" \": function(found, self, tag, id, uniques) {\n        for (var items = Selectors.Utils.getByTagAndID(self, tag, id), i = 0, l = items.length; l > i; i++) {\n            var item = items[i];\n            Selectors.Utils.chk(item, uniques) && found.push(item);\n        }\n        return found;\n    },\n    \">\": function(found, self, tag, id, uniques) {\n        for (var children = Selectors.Utils.getByTagAndID(self, tag, id), i = 0, l = children.length; l > i; i++) {\n            var child = children[i];\n            child.parentNode == self && Selectors.Utils.chk(child, uniques) && found.push(child);\n        }\n        return found;\n    },\n    \"+\": function(found, self, tag, id, uniques) {\n        for (;self = self.nextSibling; ) if (1 == self.nodeType) {\n            Selectors.Utils.chk(self, uniques) && Selectors.Filters.byTag(self, tag) && Selectors.Filters.byID(self, id) && found.push(self);\n            break;\n        }\n        return found;\n    },\n    \"~\": function(found, self, tag, id, uniques) {\n        for (;self = self.nextSibling; ) if (1 == self.nodeType) {\n            if (!Selectors.Utils.chk(self, uniques)) break;\n            Selectors.Filters.byTag(self, tag) && Selectors.Filters.byID(self, id) && found.push(self);\n        }\n        return found;\n    }\n}, Selectors.Filters = {\n    byTag: function(self, tag) {\n        return \"*\" == tag || self.tagName && self.tagName.toLowerCase() == tag;\n    },\n    byID: function(self, id) {\n        return !id || self.id && self.id == id;\n    },\n    byClass: function(self, klass) {\n        return self.className && self.className.contains && self.className.contains(klass, \" \");\n    },\n    byPseudo: function(self, parser, argument, local) {\n        return parser.call(self, argument, local);\n    },\n    byAttribute: function(self, name, operator, value) {\n        var result = Element.prototype.getProperty.call(self, name);\n        if (!result) return \"!=\" == operator;\n        if (!operator || void 0 == value) return !0;\n        switch (operator) {\n          case \"=\":\n            return result == value;\n\n          case \"*=\":\n            return result.contains(value);\n\n          case \"^=\":\n            return result.substr(0, value.length) == value;\n\n          case \"$=\":\n            return result.substr(result.length - value.length) == value;\n\n          case \"!=\":\n            return result != value;\n\n          case \"~=\":\n            return result.contains(value, \" \");\n\n          case \"|=\":\n            return result.contains(value, \"-\");\n        }\n        return !1;\n    }\n}, Selectors.Pseudo = new Hash({\n    checked: function() {\n        return this.checked;\n    },\n    empty: function() {\n        return !(this.innerText || this.textContent || \"\").length;\n    },\n    not: function(selector) {\n        return !Element.match(this, selector);\n    },\n    contains: function(text) {\n        return (this.innerText || this.textContent || \"\").contains(text);\n    },\n    \"first-child\": function() {\n        return Selectors.Pseudo.index.call(this, 0);\n    },\n    \"last-child\": function() {\n        for (var element = this; element = element.nextSibling; ) if (1 == element.nodeType) return !1;\n        return !0;\n    },\n    \"only-child\": function() {\n        for (var prev = this; prev = prev.previousSibling; ) if (1 == prev.nodeType) return !1;\n        for (var next = this; next = next.nextSibling; ) if (1 == next.nodeType) return !1;\n        return !0;\n    },\n    \"nth-child\": function(argument, local) {\n        argument = void 0 == argument ? \"n\" : argument;\n        var parsed = Selectors.Utils.parseNthArgument(argument);\n        if (\"n\" != parsed.special) return Selectors.Pseudo[parsed.special].call(this, parsed.a, local);\n        var count = 0;\n        local.positions = local.positions || {};\n        var uid = $uid(this);\n        if (!local.positions[uid]) {\n            for (var self = this; self = self.previousSibling; ) if (1 == self.nodeType) {\n                count++;\n                var position = local.positions[$uid(self)];\n                if (void 0 != position) {\n                    count = position + count;\n                    break;\n                }\n            }\n            local.positions[uid] = count;\n        }\n        return local.positions[uid] % parsed.a == parsed.b;\n    },\n    index: function(index) {\n        for (var element = this, count = 0; element = element.previousSibling; ) if (1 == element.nodeType && ++count > index) return !1;\n        return count == index;\n    },\n    even: function(argument, local) {\n        return Selectors.Pseudo[\"nth-child\"].call(this, \"2n+1\", local);\n    },\n    odd: function(argument, local) {\n        return Selectors.Pseudo[\"nth-child\"].call(this, \"2n\", local);\n    },\n    selected: function() {\n        return this.selected;\n    },\n    enabled: function() {\n        return this.disabled === !1;\n    }\n}), Element.Events.domready = {\n    onAdd: function(fn) {\n        Browser.loaded && fn.call(this);\n    }\n}, function() {\n    var domready = function() {\n        Browser.loaded || (Browser.loaded = !0, window.fireEvent(\"domready\"), document.fireEvent(\"domready\"));\n    };\n    if (window.addEvent(\"load\", domready), Browser.Engine.trident) {\n        var temp = document.createElement(\"div\");\n        (function() {\n            $try(function() {\n                return temp.doScroll(), document.id(temp).inject(document.body).set(\"html\", \"temp\").dispose();\n            }) ? domready() : arguments.callee.delay(50);\n        })();\n    } else Browser.Engine.webkit && 525 > Browser.Engine.version ? function() {\n        [ \"loaded\", \"complete\" ].contains(document.readyState) ? domready() : arguments.callee.delay(50);\n    }() : document.addEvent(\"DOMContentLoaded\", domready);\n}();\n\nvar JSON = new Hash(this.JSON && {\n    stringify: JSON.stringify,\n    parse: JSON.parse\n}).extend({\n    $specialChars: {\n        \"\\b\": \"\\\\b\",\n        \"	\": \"\\\\t\",\n        \"\\n\": \"\\\\n\",\n        \"\\f\": \"\\\\f\",\n        \"\\r\": \"\\\\r\",\n        '\"': '\\\\\"',\n        \"\\\\\": \"\\\\\\\\\"\n    },\n    $replaceChars: function(chr) {\n        return JSON.$specialChars[chr] || \"\\\\u00\" + Math.floor(chr.charCodeAt() / 16).toString(16) + (chr.charCodeAt() % 16).toString(16);\n    },\n    encode: function(obj) {\n        switch ($type(obj)) {\n          case \"string\":\n            return '\"' + obj.replace(/[\\x00-\\x1f\\\\\"]/g, JSON.$replaceChars) + '\"';\n\n          case \"array\":\n            return \"[\" + (obj.map(JSON.encode).clean() + \"\") + \"]\";\n\n          case \"object\":\n          case \"hash\":\n            var string = [];\n            return Hash.each(obj, function(value, key) {\n                var json = JSON.encode(value);\n                json && string.push(JSON.encode(key) + \":\" + json);\n            }), \"{\" + string + \"}\";\n\n          case \"number\":\n          case \"boolean\":\n            return obj + \"\";\n\n          case !1:\n            return \"null\";\n        }\n        return null;\n    },\n    decode: function(string, secure) {\n        return \"string\" == $type(string) && string.length ? secure && !/^[,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]*$/.test(string.replace(/\\\\./g, \"@\").replace(/\"[^\"\\\\\\n\\r]*\"/g, \"\")) ? null : eval(\"(\" + string + \")\") : null;\n    }\n}), Cookie = new Class({\n    Implements: Options,\n    options: {\n        path: !1,\n        domain: !1,\n        duration: !1,\n        secure: !1,\n        document: document\n    },\n    initialize: function(key, options) {\n        this.key = key, this.setOptions(options);\n    },\n    write: function(value) {\n        if (value = encodeURIComponent(value), this.options.domain && (value += \"; domain=\" + this.options.domain), \n        this.options.path && (value += \"; path=\" + this.options.path), this.options.duration) {\n            var date = new Date();\n            date.setTime(date.getTime() + 1e3 * 60 * 60 * 24 * this.options.duration), value += \"; expires=\" + date.toGMTString();\n        }\n        return this.options.secure && (value += \"; secure\"), this.options.document.cookie = this.key + \"=\" + value, \n        this;\n    },\n    read: function() {\n        var value = this.options.document.cookie.match(\"(?:^|;)\\\\s*\" + this.key.escapeRegExp() + \"=([^;]*)\");\n        return value ? decodeURIComponent(value[1]) : null;\n    },\n    dispose: function() {\n        return new Cookie(this.key, $merge(this.options, {\n            duration: -1\n        })).write(\"\"), this;\n    }\n});\n\nCookie.write = function(key, value, options) {\n    return new Cookie(key, options).write(value);\n}, Cookie.read = function(key) {\n    return new Cookie(key).read();\n}, Cookie.dispose = function(key, options) {\n    return new Cookie(key, options).dispose();\n};\n\nvar Swiff = new Class({\n    Implements: [ Options ],\n    options: {\n        id: null,\n        height: 1,\n        width: 1,\n        container: null,\n        properties: {},\n        params: {\n            quality: \"high\",\n            allowScriptAccess: \"always\",\n            wMode: \"transparent\",\n            swLiveConnect: !0\n        },\n        callBacks: {},\n        vars: {}\n    },\n    toElement: function() {\n        return this.object;\n    },\n    initialize: function(path, options) {\n        this.instance = \"Swiff_\" + $time(), this.setOptions(options), options = this.options;\n        var id = this.id = options.id || this.instance, container = document.id(options.container);\n        Swiff.CallBacks[this.instance] = {};\n        var params = options.params, vars = options.vars, callBacks = options.callBacks, properties = $extend({\n            height: options.height,\n            width: options.width\n        }, options.properties), self = this;\n        for (var callBack in callBacks) Swiff.CallBacks[this.instance][callBack] = function(option) {\n            return function() {\n                return option.apply(self.object, arguments);\n            };\n        }(callBacks[callBack]), vars[callBack] = \"Swiff.CallBacks.\" + this.instance + \".\" + callBack;\n        params.flashVars = Hash.toQueryString(vars), Browser.Engine.trident ? (properties.classid = \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\", \n        params.movie = path) : (properties.type = \"application/x-shockwave-flash\", properties.data = path);\n        var build = '<object id=\"' + id + '\"';\n        for (var property in properties) build += \" \" + property + '=\"' + properties[property] + '\"';\n        build += \">\";\n        for (var param in params) params[param] && (build += '<param name=\"' + param + '\" value=\"' + params[param] + '\" />');\n        build += \"</object>\", this.object = (container ? container.empty() : new Element(\"div\")).set(\"html\", build).firstChild;\n    },\n    replaces: function(element) {\n        return element = document.id(element, !0), element.parentNode.replaceChild(this.toElement(), element), \n        this;\n    },\n    inject: function(element) {\n        return document.id(element, !0).appendChild(this.toElement()), this;\n    },\n    remote: function() {\n        return Swiff.remote.apply(Swiff, [ this.toElement() ].extend(arguments));\n    }\n});\n\nSwiff.CallBacks = {}, Swiff.remote = function(obj, fn) {\n    var rs = obj.CallFunction('<invoke name=\"' + fn + '\" returntype=\"javascript\">' + __flash__argumentsToXML(arguments, 2) + \"</invoke>\");\n    return eval(rs);\n};\n\nvar Fx = new Class({\n    Implements: [ Chain, Events, Options ],\n    options: {\n        fps: 50,\n        unit: !1,\n        duration: 500,\n        link: \"ignore\"\n    },\n    initialize: function(options) {\n        this.subject = this.subject || this, this.setOptions(options), this.options.duration = Fx.Durations[this.options.duration] || this.options.duration.toInt();\n        var wait = this.options.wait;\n        wait === !1 && (this.options.link = \"cancel\");\n    },\n    getTransition: function() {\n        return function(p) {\n            return -(Math.cos(Math.PI * p) - 1) / 2;\n        };\n    },\n    step: function() {\n        var time = $time();\n        if (this.time + this.options.duration > time) {\n            var delta = this.transition((time - this.time) / this.options.duration);\n            this.set(this.compute(this.from, this.to, delta));\n        } else this.set(this.compute(this.from, this.to, 1)), this.complete();\n    },\n    set: function(now) {\n        return now;\n    },\n    compute: function(from, to, delta) {\n        return Fx.compute(from, to, delta);\n    },\n    check: function() {\n        if (!this.timer) return !0;\n        switch (this.options.link) {\n          case \"cancel\":\n            return this.cancel(), !0;\n\n          case \"chain\":\n            return this.chain(this.caller.bind(this, arguments)), !1;\n        }\n        return !1;\n    },\n    start: function(from, to) {\n        return this.check(from, to) ? (this.from = from, this.to = to, this.time = 0, this.transition = this.getTransition(), \n        this.startTimer(), this.onStart(), this) : this;\n    },\n    complete: function() {\n        return this.stopTimer() && this.onComplete(), this;\n    },\n    cancel: function() {\n        return this.stopTimer() && this.onCancel(), this;\n    },\n    onStart: function() {\n        this.fireEvent(\"start\", this.subject);\n    },\n    onComplete: function() {\n        this.fireEvent(\"complete\", this.subject), this.callChain() || this.fireEvent(\"chainComplete\", this.subject);\n    },\n    onCancel: function() {\n        this.fireEvent(\"cancel\", this.subject).clearChain();\n    },\n    pause: function() {\n        return this.stopTimer(), this;\n    },\n    resume: function() {\n        return this.startTimer(), this;\n    },\n    stopTimer: function() {\n        return this.timer ? (this.time = $time() - this.time, this.timer = $clear(this.timer), \n        !0) : !1;\n    },\n    startTimer: function() {\n        return this.timer ? !1 : (this.time = $time() - this.time, this.timer = this.step.periodical(Math.round(1e3 / this.options.fps), this), \n        !0);\n    }\n});\n\nFx.compute = function(from, to, delta) {\n    return (to - from) * delta + from;\n}, Fx.Durations = {\n    \"short\": 250,\n    normal: 500,\n    \"long\": 1e3\n}, Fx.CSS = new Class({\n    Extends: Fx,\n    prepare: function(element, property, values) {\n        values = $splat(values);\n        var values1 = values[1];\n        $chk(values1) || (values[1] = values[0], values[0] = element.getStyle(property));\n        var parsed = values.map(this.parse);\n        return {\n            from: parsed[0],\n            to: parsed[1]\n        };\n    },\n    parse: function(value) {\n        return value = $lambda(value)(), value = \"string\" == typeof value ? value.split(\" \") : $splat(value), \n        value.map(function(val) {\n            val += \"\";\n            var found = !1;\n            return Fx.CSS.Parsers.each(function(parser) {\n                if (!found) {\n                    var parsed = parser.parse(val);\n                    $chk(parsed) && (found = {\n                        value: parsed,\n                        parser: parser\n                    });\n                }\n            }), found = found || {\n                value: val,\n                parser: Fx.CSS.Parsers.String\n            };\n        });\n    },\n    compute: function(from, to, delta) {\n        var computed = [];\n        return Math.min(from.length, to.length).times(function(i) {\n            computed.push({\n                value: from[i].parser.compute(from[i].value, to[i].value, delta),\n                parser: from[i].parser\n            });\n        }), computed.$family = {\n            name: \"fx:css:value\"\n        }, computed;\n    },\n    serve: function(value, unit) {\n        \"fx:css:value\" != $type(value) && (value = this.parse(value));\n        var returned = [];\n        return value.each(function(bit) {\n            returned = returned.concat(bit.parser.serve(bit.value, unit));\n        }), returned;\n    },\n    render: function(element, property, value, unit) {\n        element.setStyle(property, this.serve(value, unit));\n    },\n    search: function(selector) {\n        if (Fx.CSS.Cache[selector]) return Fx.CSS.Cache[selector];\n        var to = {};\n        return Array.each(document.styleSheets, function(sheet) {\n            var href = sheet.href;\n            if (!href || !href.contains(\"://\") || href.contains(document.domain)) {\n                var rules = sheet.rules || sheet.cssRules;\n                Array.each(rules, function(rule) {\n                    if (rule.style) {\n                        var selectorText = rule.selectorText ? rule.selectorText.replace(/^\\w+/, function(m) {\n                            return m.toLowerCase();\n                        }) : null;\n                        selectorText && selectorText.test(\"^\" + selector + \"$\") && Element.Styles.each(function(value, style) {\n                            rule.style[style] && !Element.ShortStyles[style] && (value = rule.style[style] + \"\", \n                            to[style] = value.test(/^rgb/) ? value.rgbToHex() : value);\n                        });\n                    }\n                });\n            }\n        }), Fx.CSS.Cache[selector] = to;\n    }\n}), Fx.CSS.Cache = {}, Fx.CSS.Parsers = new Hash({\n    Color: {\n        parse: function(value) {\n            return value.match(/^#[0-9a-f]{3,6}$/i) ? value.hexToRgb(!0) : (value = value.match(/(\\d+),\\s*(\\d+),\\s*(\\d+)/)) ? [ value[1], value[2], value[3] ] : !1;\n        },\n        compute: function(from, to, delta) {\n            return from.map(function(value, i) {\n                return Math.round(Fx.compute(from[i], to[i], delta));\n            });\n        },\n        serve: function(value) {\n            return value.map(Number);\n        }\n    },\n    Number: {\n        parse: parseFloat,\n        compute: Fx.compute,\n        serve: function(value, unit) {\n            return unit ? value + unit : value;\n        }\n    },\n    String: {\n        parse: $lambda(!1),\n        compute: $arguments(1),\n        serve: $arguments(0)\n    }\n}), Fx.Tween = new Class({\n    Extends: Fx.CSS,\n    initialize: function(element, options) {\n        this.element = this.subject = document.id(element), this.parent(options);\n    },\n    set: function(property, now) {\n        return 1 == arguments.length && (now = property, property = this.property || this.options.property), \n        this.render(this.element, property, now, this.options.unit), this;\n    },\n    start: function(property, from, to) {\n        if (!this.check(property, from, to)) return this;\n        var args = Array.flatten(arguments);\n        this.property = this.options.property || args.shift();\n        var parsed = this.prepare(this.element, this.property, args);\n        return this.parent(parsed.from, parsed.to);\n    }\n}), Element.Properties.tween = {\n    set: function(options) {\n        var tween = this.retrieve(\"tween\");\n        return tween && tween.cancel(), this.eliminate(\"tween\").store(\"tween:options\", $extend({\n            link: \"cancel\"\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"tween\")) && ((options || !this.retrieve(\"tween:options\")) && this.set(\"tween\", options), \n        this.store(\"tween\", new Fx.Tween(this, this.retrieve(\"tween:options\")))), this.retrieve(\"tween\");\n    }\n}, Element.implement({\n    tween: function() {\n        return this.get(\"tween\").start(arguments), this;\n    },\n    fade: function(how) {\n        var toggle, fade = this.get(\"tween\"), o = \"opacity\";\n        switch (how = $pick(how, \"toggle\")) {\n          case \"in\":\n            fade.start(o, 1);\n            break;\n\n          case \"out\":\n            fade.start(o, 0);\n            break;\n\n          case \"show\":\n            fade.set(o, 1);\n            break;\n\n          case \"hide\":\n            fade.set(o, 0);\n            break;\n\n          case \"toggle\":\n            var flag = this.retrieve(\"fade:flag\", 1 == this.get(\"opacity\"));\n            fade.start(o, flag ? 0 : 1), this.store(\"fade:flag\", !flag), toggle = !0;\n            break;\n\n          default:\n            fade.start(o, arguments);\n        }\n        return toggle || this.eliminate(\"fade:flag\"), this;\n    },\n    highlight: function(start, end) {\n        end || (end = this.retrieve(\"highlight:original\", this.getStyle(\"background-color\")), \n        end = \"transparent\" == end ? \"#fff\" : end);\n        var tween = this.get(\"tween\");\n        return tween.start(\"background-color\", start || \"#ffff88\", end).chain(function() {\n            this.setStyle(\"background-color\", this.retrieve(\"highlight:original\")), tween.callChain();\n        }.bind(this)), this;\n    }\n}), Fx.Morph = new Class({\n    Extends: Fx.CSS,\n    initialize: function(element, options) {\n        this.element = this.subject = document.id(element), this.parent(options);\n    },\n    set: function(now) {\n        \"string\" == typeof now && (now = this.search(now));\n        for (var p in now) this.render(this.element, p, now[p], this.options.unit);\n        return this;\n    },\n    compute: function(from, to, delta) {\n        var now = {};\n        for (var p in from) now[p] = this.parent(from[p], to[p], delta);\n        return now;\n    },\n    start: function(properties) {\n        if (!this.check(properties)) return this;\n        \"string\" == typeof properties && (properties = this.search(properties));\n        var from = {}, to = {};\n        for (var p in properties) {\n            var parsed = this.prepare(this.element, p, properties[p]);\n            from[p] = parsed.from, to[p] = parsed.to;\n        }\n        return this.parent(from, to);\n    }\n}), Element.Properties.morph = {\n    set: function(options) {\n        var morph = this.retrieve(\"morph\");\n        return morph && morph.cancel(), this.eliminate(\"morph\").store(\"morph:options\", $extend({\n            link: \"cancel\"\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"morph\")) && ((options || !this.retrieve(\"morph:options\")) && this.set(\"morph\", options), \n        this.store(\"morph\", new Fx.Morph(this, this.retrieve(\"morph:options\")))), this.retrieve(\"morph\");\n    }\n}, Element.implement({\n    morph: function(props) {\n        return this.get(\"morph\").start(props), this;\n    }\n}), Fx.implement({\n    getTransition: function() {\n        var trans = this.options.transition || Fx.Transitions.Sine.easeInOut;\n        if (\"string\" == typeof trans) {\n            var data = trans.split(\":\");\n            trans = Fx.Transitions, trans = trans[data[0]] || trans[data[0].capitalize()], data[1] && (trans = trans[\"ease\" + data[1].capitalize() + (data[2] ? data[2].capitalize() : \"\")]);\n        }\n        return trans;\n    }\n}), Fx.Transition = function(transition, params) {\n    return params = $splat(params), $extend(transition, {\n        easeIn: function(pos) {\n            return transition(pos, params);\n        },\n        easeOut: function(pos) {\n            return 1 - transition(1 - pos, params);\n        },\n        easeInOut: function(pos) {\n            return .5 >= pos ? transition(2 * pos, params) / 2 : (2 - transition(2 * (1 - pos), params)) / 2;\n        }\n    });\n}, Fx.Transitions = new Hash({\n    linear: $arguments(0)\n}), Fx.Transitions.extend = function(transitions) {\n    for (var transition in transitions) Fx.Transitions[transition] = new Fx.Transition(transitions[transition]);\n}, Fx.Transitions.extend({\n    Pow: function(p, x) {\n        return Math.pow(p, x[0] || 6);\n    },\n    Expo: function(p) {\n        return Math.pow(2, 8 * (p - 1));\n    },\n    Circ: function(p) {\n        return 1 - Math.sin(Math.acos(p));\n    },\n    Sine: function(p) {\n        return 1 - Math.sin((1 - p) * Math.PI / 2);\n    },\n    Back: function(p, x) {\n        return x = x[0] || 1.618, Math.pow(p, 2) * ((x + 1) * p - x);\n    },\n    Bounce: function(p) {\n        for (var value, a = 0, b = 1; 1; a += b, b /= 2) if (p >= (7 - 4 * a) / 11) {\n            value = b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);\n            break;\n        }\n        return value;\n    },\n    Elastic: function(p, x) {\n        return Math.pow(2, 10 * --p) * Math.cos(20 * p * Math.PI * (x[0] || 1) / 3);\n    }\n}), [ \"Quad\", \"Cubic\", \"Quart\", \"Quint\" ].each(function(transition, i) {\n    Fx.Transitions[transition] = new Fx.Transition(function(p) {\n        return Math.pow(p, [ i + 2 ]);\n    });\n});\n\nvar Request = new Class({\n    Implements: [ Chain, Events, Options ],\n    options: {\n        url: \"\",\n        data: \"\",\n        headers: {\n            \"X-Requested-With\": \"XMLHttpRequest\",\n            Accept: \"text/javascript, text/html, application/xml, text/xml, */*\"\n        },\n        async: !0,\n        format: !1,\n        method: \"post\",\n        link: \"ignore\",\n        isSuccess: null,\n        emulation: !0,\n        urlEncoded: !0,\n        encoding: \"utf-8\",\n        evalScripts: !1,\n        evalResponse: !1,\n        noCache: !1\n    },\n    initialize: function(options) {\n        this.xhr = new Browser.Request(), this.setOptions(options), this.options.isSuccess = this.options.isSuccess || this.isSuccess, \n        this.headers = new Hash(this.options.headers);\n    },\n    onStateChange: function() {\n        4 == this.xhr.readyState && this.running && (this.running = !1, this.status = 0, \n        $try(function() {\n            this.status = this.xhr.status;\n        }.bind(this)), this.xhr.onreadystatechange = $empty, this.options.isSuccess.call(this, this.status) ? (this.response = {\n            text: this.xhr.responseText,\n            xml: this.xhr.responseXML\n        }, this.success(this.response.text, this.response.xml)) : (this.response = {\n            text: null,\n            xml: null\n        }, this.failure()));\n    },\n    isSuccess: function() {\n        return this.status >= 200 && 300 > this.status;\n    },\n    processScripts: function(text) {\n        return this.options.evalResponse || /(ecma|java)script/.test(this.getHeader(\"Content-type\")) ? $exec(text) : text.stripScripts(this.options.evalScripts);\n    },\n    success: function(text, xml) {\n        this.onSuccess(this.processScripts(text), xml);\n    },\n    onSuccess: function() {\n        this.fireEvent(\"complete\", arguments).fireEvent(\"success\", arguments).callChain();\n    },\n    failure: function() {\n        this.onFailure();\n    },\n    onFailure: function() {\n        this.fireEvent(\"complete\").fireEvent(\"failure\", this.xhr);\n    },\n    setHeader: function(name, value) {\n        return this.headers.set(name, value), this;\n    },\n    getHeader: function(name) {\n        return $try(function() {\n            return this.xhr.getResponseHeader(name);\n        }.bind(this));\n    },\n    check: function() {\n        if (!this.running) return !0;\n        switch (this.options.link) {\n          case \"cancel\":\n            return this.cancel(), !0;\n\n          case \"chain\":\n            return this.chain(this.caller.bind(this, arguments)), !1;\n        }\n        return !1;\n    },\n    send: function(options) {\n        if (!this.check(options)) return this;\n        this.running = !0;\n        var type = $type(options);\n        (\"string\" == type || \"element\" == type) && (options = {\n            data: options\n        });\n        var old = this.options;\n        options = $extend({\n            data: old.data,\n            url: old.url,\n            method: old.method\n        }, options);\n        var data = options.data, url = options.url + \"\", method = options.method.toLowerCase();\n        switch ($type(data)) {\n          case \"element\":\n            data = document.id(data).toQueryString();\n            break;\n\n          case \"object\":\n          case \"hash\":\n            data = Hash.toQueryString(data);\n        }\n        if (this.options.format) {\n            var format = \"format=\" + this.options.format;\n            data = data ? format + \"&\" + data : format;\n        }\n        if (this.options.emulation && ![ \"get\", \"post\" ].contains(method)) {\n            var _method = \"_method=\" + method;\n            data = data ? _method + \"&\" + data : _method, method = \"post\";\n        }\n        if (this.options.urlEncoded && \"post\" == method) {\n            var encoding = this.options.encoding ? \"; charset=\" + this.options.encoding : \"\";\n            this.headers.set(\"Content-type\", \"application/x-www-form-urlencoded\" + encoding);\n        }\n        if (this.options.noCache) {\n            var noCache = \"noCache=\" + new Date().getTime();\n            data = data ? noCache + \"&\" + data : noCache;\n        }\n        var trimPosition = url.lastIndexOf(\"/\");\n        return trimPosition > -1 && (trimPosition = url.indexOf(\"#\")) > -1 && (url = url.substr(0, trimPosition)), \n        data && \"get\" == method && (url = url + (url.contains(\"?\") ? \"&\" : \"?\") + data, \n        data = null), this.xhr.open(method.toUpperCase(), url, this.options.async), this.xhr.onreadystatechange = this.onStateChange.bind(this), \n        this.headers.each(function(value, key) {\n            try {\n                this.xhr.setRequestHeader(key, value);\n            } catch (e) {\n                this.fireEvent(\"exception\", [ key, value ]);\n            }\n        }, this), this.fireEvent(\"request\"), this.xhr.send(data), this.options.async || this.onStateChange(), \n        this;\n    },\n    cancel: function() {\n        return this.running ? (this.running = !1, this.xhr.abort(), this.xhr.onreadystatechange = $empty, \n        this.xhr = new Browser.Request(), this.fireEvent(\"cancel\"), this) : this;\n    }\n});\n\n(function() {\n    var methods = {};\n    [ \"get\", \"post\", \"put\", \"delete\", \"GET\", \"POST\", \"PUT\", \"DELETE\" ].each(function(method) {\n        methods[method] = function() {\n            var params = Array.link(arguments, {\n                url: String.type,\n                data: $defined\n            });\n            return this.send($extend(params, {\n                method: method\n            }));\n        };\n    }), Request.implement(methods);\n})(), Element.Properties.send = {\n    set: function(options) {\n        var send = this.retrieve(\"send\");\n        return send && send.cancel(), this.eliminate(\"send\").store(\"send:options\", $extend({\n            data: this,\n            link: \"cancel\",\n            method: this.get(\"method\") || \"post\",\n            url: this.get(\"action\")\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"send\")) && ((options || !this.retrieve(\"send:options\")) && this.set(\"send\", options), \n        this.store(\"send\", new Request(this.retrieve(\"send:options\")))), this.retrieve(\"send\");\n    }\n}, Element.implement({\n    send: function(url) {\n        var sender = this.get(\"send\");\n        return sender.send({\n            data: this,\n            url: url || sender.options.url\n        }), this;\n    }\n}), Request.HTML = new Class({\n    Extends: Request,\n    options: {\n        update: !1,\n        append: !1,\n        evalScripts: !0,\n        filter: !1\n    },\n    processHTML: function(text) {\n        var match = text.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\n        text = match ? match[1] : text;\n        var container = new Element(\"div\");\n        return $try(function() {\n            var doc, root = \"<root>\" + text + \"</root>\";\n            if (Browser.Engine.trident ? (doc = new ActiveXObject(\"Microsoft.XMLDOM\"), doc.async = !1, \n            doc.loadXML(root)) : doc = new DOMParser().parseFromString(root, \"text/xml\"), root = doc.getElementsByTagName(\"root\")[0], \n            !root) return null;\n            for (var i = 0, k = root.childNodes.length; k > i; i++) {\n                var child = Element.clone(root.childNodes[i], !0, !0);\n                child && container.grab(child);\n            }\n            return container;\n        }) || container.set(\"html\", text);\n    },\n    success: function(text) {\n        var options = this.options, response = this.response;\n        response.html = text.stripScripts(function(script) {\n            response.javascript = script;\n        });\n        var temp = this.processHTML(response.html);\n        response.tree = temp.childNodes, response.elements = temp.getElements(\"*\"), options.filter && (response.tree = response.elements.filter(options.filter)), \n        options.update ? document.id(options.update).empty().set(\"html\", response.html) : options.append && document.id(options.append).adopt(temp.getChildren()), \n        options.evalScripts && $exec(response.javascript), this.onSuccess(response.tree, response.elements, response.html, response.javascript);\n    }\n}), Element.Properties.load = {\n    set: function(options) {\n        var load = this.retrieve(\"load\");\n        return load && load.cancel(), this.eliminate(\"load\").store(\"load:options\", $extend({\n            data: this,\n            link: \"cancel\",\n            update: this,\n            method: \"get\"\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"load\")) && ((options || !this.retrieve(\"load:options\")) && this.set(\"load\", options), \n        this.store(\"load\", new Request.HTML(this.retrieve(\"load:options\")))), this.retrieve(\"load\");\n    }\n}, Element.implement({\n    load: function() {\n        return this.get(\"load\").send(Array.link(arguments, {\n            data: Object.type,\n            url: String.type\n        })), this;\n    }\n}), Request.JSON = new Class({\n    Extends: Request,\n    options: {\n        secure: !0\n    },\n    initialize: function(options) {\n        this.parent(options), this.headers.extend({\n            Accept: \"application/json\",\n            \"X-Request\": \"JSON\"\n        });\n    },\n    success: function(text) {\n        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);\n    }\n}), MooTools.More = {\n    version: \"1.2.5.1\",\n    build: \"254884f2b83651bf95260eed5c6cceb838e22d8e\"\n}, Class.Mutators.Binds = function(binds) {\n    return binds;\n}, Class.Mutators.initialize = function(initialize) {\n    return function() {\n        return $splat(this.Binds).each(function(name) {\n            var original = this[name];\n            original && (this[name] = original.bind(this));\n        }, this), initialize.apply(this, arguments);\n    };\n}, Element.implement({\n    measure: function(fn) {\n        var vis = function(el) {\n            return !(el && !el.offsetHeight && !el.offsetWidth);\n        };\n        if (vis(this)) return fn.apply(this);\n        for (var parent = this.getParent(), toMeasure = []; !vis(parent) && parent != document.body; ) toMeasure.push(parent.expose()), \n        parent = parent.getParent();\n        var restore = this.expose(), result = fn.apply(this);\n        return restore(), toMeasure.each(function(restore) {\n            restore();\n        }), result;\n    },\n    expose: function() {\n        if (\"none\" != this.getStyle(\"display\")) return $empty;\n        var before = this.style.cssText;\n        return this.setStyles({\n            display: \"block\",\n            position: \"absolute\",\n            visibility: \"hidden\"\n        }), function() {\n            this.style.cssText = before;\n        }.bind(this);\n    },\n    getDimensions: function(options) {\n        options = $merge({\n            computeSize: !1\n        }, options);\n        var dim = {}, getSize = function(el, options) {\n            return options.computeSize ? el.getComputedSize(options) : el.getSize();\n        }, parent = this.getParent(\"body\");\n        if (parent && \"none\" == this.getStyle(\"display\")) dim = this.measure(function() {\n            return getSize(this, options);\n        }); else if (parent) try {\n            dim = getSize(this, options);\n        } catch (e) {} else dim = {\n            x: 0,\n            y: 0\n        };\n        return $chk(dim.x) ? $extend(dim, {\n            width: dim.x,\n            height: dim.y\n        }) : $extend(dim, {\n            x: dim.width,\n            y: dim.height\n        });\n    },\n    getComputedSize: function(options) {\n        options && options.plains && (options.planes = options.plains), options = $merge({\n            styles: [ \"padding\", \"border\" ],\n            planes: {\n                height: [ \"top\", \"bottom\" ],\n                width: [ \"left\", \"right\" ]\n            },\n            mode: \"both\"\n        }, options);\n        var size = {\n            width: 0,\n            height: 0\n        };\n        switch (options.mode) {\n          case \"vertical\":\n            delete size.width, delete options.planes.width;\n            break;\n\n          case \"horizontal\":\n            delete size.height, delete options.planes.height;\n        }\n        var getStyles = [];\n        $each(options.planes, function(plane) {\n            plane.each(function(edge) {\n                options.styles.each(function(style) {\n                    getStyles.push(\"border\" == style ? style + \"-\" + edge + \"-\" + \"width\" : style + \"-\" + edge);\n                });\n            });\n        });\n        var styles = {};\n        getStyles.each(function(style) {\n            styles[style] = this.getComputedStyle(style);\n        }, this);\n        var subtracted = [];\n        return $each(options.planes, function(plane, key) {\n            var capitalized = key.capitalize();\n            size[\"total\" + capitalized] = size[\"computed\" + capitalized] = 0, plane.each(function(edge) {\n                size[\"computed\" + edge.capitalize()] = 0, getStyles.each(function(style) {\n                    style.test(edge) && (styles[style] = styles[style].toInt() || 0, size[\"total\" + capitalized] = size[\"total\" + capitalized] + styles[style], \n                    size[\"computed\" + edge.capitalize()] = size[\"computed\" + edge.capitalize()] + styles[style]), \n                    style.test(edge) && key != style && (style.test(\"border\") || style.test(\"padding\")) && !subtracted.contains(style) && (subtracted.push(style), \n                    size[\"computed\" + capitalized] = size[\"computed\" + capitalized] - styles[style]);\n                });\n            });\n        }), [ \"Width\", \"Height\" ].each(function(value) {\n            var lower = value.toLowerCase();\n            $chk(size[lower]) && (size[lower] = size[lower] + this[\"offset\" + value] + size[\"computed\" + value], \n            size[\"total\" + value] = size[lower] + size[\"total\" + value], delete size[\"computed\" + value]);\n        }, this), $extend(styles, size);\n    }\n});\n\nvar Drag = new Class({\n    Implements: [ Events, Options ],\n    options: {\n        snap: 6,\n        unit: \"px\",\n        grid: !1,\n        style: !0,\n        limit: !1,\n        handle: !1,\n        invert: !1,\n        preventDefault: !1,\n        stopPropagation: !1,\n        modifiers: {\n            x: \"left\",\n            y: \"top\"\n        }\n    },\n    initialize: function() {\n        var params = Array.link(arguments, {\n            options: Object.type,\n            element: $defined\n        });\n        this.element = document.id(params.element), this.document = this.element.getDocument(), \n        this.setOptions(params.options || {});\n        var htype = $type(this.options.handle);\n        this.handles = (\"array\" == htype || \"collection\" == htype ? $$(this.options.handle) : document.id(this.options.handle)) || this.element, \n        this.mouse = {\n            now: {},\n            pos: {}\n        }, this.value = {\n            start: {},\n            now: {}\n        }, this.selection = Browser.Engine.trident ? \"selectstart\" : \"mousedown\", this.bound = {\n            start: this.start.bind(this),\n            check: this.check.bind(this),\n            drag: this.drag.bind(this),\n            stop: this.stop.bind(this),\n            cancel: this.cancel.bind(this),\n            eventStop: $lambda(!1)\n        }, this.attach();\n    },\n    attach: function() {\n        return this.handles.addEvent(\"mousedown\", this.bound.start), this;\n    },\n    detach: function() {\n        return this.handles.removeEvent(\"mousedown\", this.bound.start), this;\n    },\n    start: function(event) {\n        if (!event.rightClick) {\n            this.options.preventDefault && event.preventDefault(), this.options.stopPropagation && event.stopPropagation(), \n            this.mouse.start = event.page, this.fireEvent(\"beforeStart\", this.element);\n            var limit = this.options.limit;\n            this.limit = {\n                x: [],\n                y: []\n            };\n            var styles = this.element.getStyles(\"left\", \"right\", \"top\", \"bottom\");\n            this._invert = {\n                x: \"left\" == this.options.modifiers.x && \"auto\" == styles.left && !isNaN(styles.right.toInt()) && (this.options.modifiers.x = \"right\"),\n                y: \"top\" == this.options.modifiers.y && \"auto\" == styles.top && !isNaN(styles.bottom.toInt()) && (this.options.modifiers.y = \"bottom\")\n            };\n            var z, coordinates;\n            for (z in this.options.modifiers) if (this.options.modifiers[z]) {\n                var style = this.element.getStyle(this.options.modifiers[z]);\n                if (style && !style.match(/px$/) && (coordinates || (coordinates = this.element.getCoordinates(this.element.getOffsetParent())), \n                style = coordinates[this.options.modifiers[z]]), this.value.now[z] = this.options.style ? (style || 0).toInt() : this.element[this.options.modifiers[z]], \n                this.options.invert && (this.value.now[z] *= -1), this._invert[z] && (this.value.now[z] *= -1), \n                this.mouse.pos[z] = event.page[z] - this.value.now[z], limit && limit[z]) for (var i = 2; i--; i) $chk(limit[z][i]) && (this.limit[z][i] = $lambda(limit[z][i])());\n            }\n            \"number\" == $type(this.options.grid) && (this.options.grid = {\n                x: this.options.grid,\n                y: this.options.grid\n            }), this.document.addEvents({\n                mousemove: this.bound.check,\n                mouseup: this.bound.cancel\n            }), this.document.addEvent(this.selection, this.bound.eventStop);\n        }\n    },\n    check: function(event) {\n        this.options.preventDefault && event.preventDefault();\n        var distance = Math.round(Math.sqrt(Math.pow(event.page.x - this.mouse.start.x, 2) + Math.pow(event.page.y - this.mouse.start.y, 2)));\n        distance > this.options.snap && (this.cancel(), this.document.addEvents({\n            mousemove: this.bound.drag,\n            mouseup: this.bound.stop\n        }), this.fireEvent(\"start\", [ this.element, event ]).fireEvent(\"snap\", this.element));\n    },\n    drag: function(event) {\n        this.options.preventDefault && event.preventDefault(), this.mouse.now = event.page;\n        for (var z in this.options.modifiers) this.options.modifiers[z] && (this.value.now[z] = this.mouse.now[z] - this.mouse.pos[z], \n        this.options.invert && (this.value.now[z] *= -1), this._invert[z] && (this.value.now[z] *= -1), \n        this.options.limit && this.limit[z] && ($chk(this.limit[z][1]) && this.value.now[z] > this.limit[z][1] ? this.value.now[z] = this.limit[z][1] : $chk(this.limit[z][0]) && this.value.now[z] < this.limit[z][0] && (this.value.now[z] = this.limit[z][0])), \n        this.options.grid[z] && (this.value.now[z] -= (this.value.now[z] - (this.limit[z][0] || 0)) % this.options.grid[z]), \n        this.options.style ? this.element.setStyle(this.options.modifiers[z], this.value.now[z] + this.options.unit) : this.element[this.options.modifiers[z]] = this.value.now[z]);\n        this.fireEvent(\"drag\", [ this.element, event ]);\n    },\n    cancel: function(event) {\n        this.document.removeEvent(\"mousemove\", this.bound.check), this.document.removeEvent(\"mouseup\", this.bound.cancel), \n        event && (this.document.removeEvent(this.selection, this.bound.eventStop), this.fireEvent(\"cancel\", this.element));\n    },\n    stop: function(event) {\n        this.document.removeEvent(this.selection, this.bound.eventStop), this.document.removeEvent(\"mousemove\", this.bound.drag), \n        this.document.removeEvent(\"mouseup\", this.bound.stop), event && this.fireEvent(\"complete\", [ this.element, event ]);\n    }\n});\n\nElement.implement({\n    makeResizable: function(options) {\n        var drag = new Drag(this, $merge({\n            modifiers: {\n                x: \"width\",\n                y: \"height\"\n            }\n        }, options));\n        return this.store(\"resizer\", drag), drag.addEvent(\"drag\", function() {\n            this.fireEvent(\"resize\", drag);\n        }.bind(this));\n    }\n});\n\nvar Slider = new Class({\n    Implements: [ Events, Options ],\n    Binds: [ \"clickedElement\", \"draggedKnob\", \"scrolledElement\" ],\n    options: {\n        onTick: function(position) {\n            this.options.snap && (position = this.toPosition(this.step)), this.knob.setStyle(this.property, position);\n        },\n        initialStep: 0,\n        snap: !1,\n        offset: 0,\n        range: !1,\n        wheel: !1,\n        steps: 100,\n        mode: \"horizontal\"\n    },\n    initialize: function(element, knob, options) {\n        this.setOptions(options), this.element = document.id(element), this.knob = document.id(knob), \n        this.previousChange = this.previousEnd = this.step = -1;\n        var offset, limit = {}, modifiers = {\n            x: !1,\n            y: !1\n        };\n        switch (this.options.mode) {\n          case \"vertical\":\n            this.axis = \"y\", this.property = \"top\", offset = \"offsetHeight\";\n            break;\n\n          case \"horizontal\":\n            this.axis = \"x\", this.property = \"left\", offset = \"offsetWidth\";\n        }\n        this.full = this.element.measure(function() {\n            return this.half = this.knob[offset] / 2, this.element[offset] - this.knob[offset] + 2 * this.options.offset;\n        }.bind(this)), this.setRange(this.options.range), this.knob.setStyle(\"position\", \"relative\").setStyle(this.property, -this.options.offset), \n        modifiers[this.axis] = this.property, limit[this.axis] = [ -this.options.offset, this.full - this.options.offset ];\n        var dragOptions = {\n            snap: 0,\n            limit: limit,\n            modifiers: modifiers,\n            onDrag: this.draggedKnob,\n            onStart: this.draggedKnob,\n            onBeforeStart: function() {\n                this.isDragging = !0;\n            }.bind(this),\n            onCancel: function() {\n                this.isDragging = !1;\n            }.bind(this),\n            onComplete: function() {\n                this.isDragging = !1, this.draggedKnob(), this.end();\n            }.bind(this)\n        };\n        this.options.snap && (dragOptions.grid = Math.ceil(this.stepWidth), dragOptions.limit[this.axis][1] = this.full), \n        this.drag = new Drag(this.knob, dragOptions), this.attach(), null != this.options.initialStep && this.set(this.options.initialStep);\n    },\n    attach: function() {\n        return this.element.addEvent(\"mousedown\", this.clickedElement), this.options.wheel && this.element.addEvent(\"mousewheel\", this.scrolledElement), \n        this.drag.attach(), this;\n    },\n    detach: function() {\n        return this.element.removeEvent(\"mousedown\", this.clickedElement), this.element.removeEvent(\"mousewheel\", this.scrolledElement), \n        this.drag.detach(), this;\n    },\n    set: function(step) {\n        return this.range > 0 ^ this.min > step || (step = this.min), this.range > 0 ^ step > this.max || (step = this.max), \n        this.step = Math.round(step), this.checkStep(), this.fireEvent(\"tick\", this.toPosition(this.step)), \n        this.end(), this;\n    },\n    setRange: function(range, pos) {\n        return this.min = $pick(range[0], 0), this.max = $pick(range[1], this.options.steps), \n        this.range = this.max - this.min, this.steps = this.options.steps || this.full, \n        this.stepSize = Math.abs(this.range) / this.steps, this.stepWidth = this.stepSize * this.full / Math.abs(this.range), \n        this.set($pick(pos, this.step).floor(this.min).max(this.max)), this;\n    },\n    clickedElement: function(event) {\n        if (!this.isDragging && event.target != this.knob) {\n            var dir = 0 > this.range ? -1 : 1, position = event.page[this.axis] - this.element.getPosition()[this.axis] - this.half;\n            position = position.limit(-this.options.offset, this.full - this.options.offset), \n            this.step = Math.round(this.min + dir * this.toStep(position)), this.checkStep(), \n            this.fireEvent(\"tick\", position), this.end();\n        }\n    },\n    scrolledElement: function(event) {\n        var mode = \"horizontal\" == this.options.mode ? 0 > event.wheel : event.wheel > 0;\n        this.set(mode ? this.step - this.stepSize : this.step + this.stepSize), event.stop();\n    },\n    draggedKnob: function() {\n        var dir = 0 > this.range ? -1 : 1, position = this.drag.value.now[this.axis];\n        position = position.limit(-this.options.offset, this.full - this.options.offset), \n        this.step = Math.round(this.min + dir * this.toStep(position)), this.checkStep();\n    },\n    checkStep: function() {\n        this.previousChange != this.step && (this.previousChange = this.step, this.fireEvent(\"change\", this.step));\n    },\n    end: function() {\n        this.previousEnd !== this.step && (this.previousEnd = this.step, this.fireEvent(\"complete\", this.step + \"\"));\n    },\n    toStep: function(position) {\n        var step = (position + this.options.offset) * this.stepSize / this.full * this.steps;\n        return this.options.steps ? Math.round(step -= step % this.stepSize) : step;\n    },\n    toPosition: function(step) {\n        return this.full * Math.abs(this.min - step) / (this.steps * this.stepSize) - this.options.offset;\n    }\n}), Color = new Native({\n    initialize: function(color, type) {\n        switch (arguments.length >= 3 ? (type = \"rgb\", color = Array.slice(arguments, 0, 3)) : \"string\" == typeof color && (color = color.match(/rgb/) ? color.rgbToHex().hexToRgb(!0) : color.match(/hsb/) ? color.hsbToRgb() : color.hexToRgb(!0)), \n        type = type || \"rgb\") {\n          case \"hsb\":\n            var old = color;\n            color = color.hsbToRgb(), color.hsb = old;\n            break;\n\n          case \"hex\":\n            color = color.hexToRgb(!0);\n        }\n        return color.rgb = color.slice(0, 3), color.hsb = color.hsb || color.rgbToHsb(), \n        color.hex = color.rgbToHex(), $extend(color, this);\n    }\n});\n\nColor.implement({\n    mix: function() {\n        var colors = Array.slice(arguments), alpha = \"number\" == $type(colors.getLast()) ? colors.pop() : 50, rgb = this.slice();\n        return colors.each(function(color) {\n            color = new Color(color);\n            for (var i = 0; 3 > i; i++) rgb[i] = Math.round(rgb[i] / 100 * (100 - alpha) + color[i] / 100 * alpha);\n        }), new Color(rgb, \"rgb\");\n    },\n    invert: function() {\n        return new Color(this.map(function(value) {\n            return 255 - value;\n        }));\n    },\n    setHue: function(value) {\n        return new Color([ value, this.hsb[1], this.hsb[2] ], \"hsb\");\n    },\n    setSaturation: function(percent) {\n        return new Color([ this.hsb[0], percent, this.hsb[2] ], \"hsb\");\n    },\n    setBrightness: function(percent) {\n        return new Color([ this.hsb[0], this.hsb[1], percent ], \"hsb\");\n    }\n});\n\nvar $RGB = function(r, g, b) {\n    return new Color([ r, g, b ], \"rgb\");\n}, $HSB = function(h, s, b) {\n    return new Color([ h, s, b ], \"hsb\");\n}, $HEX = function(hex) {\n    return new Color(hex, \"hex\");\n};\n\nArray.implement({\n    rgbToHsb: function() {\n        var red = this[0], green = this[1], blue = this[2], hue = 0, max = Math.max(red, green, blue), min = Math.min(red, green, blue), delta = max - min, brightness = max / 255, saturation = 0 != max ? delta / max : 0;\n        if (0 != saturation) {\n            var rr = (max - red) / delta, gr = (max - green) / delta, br = (max - blue) / delta;\n            hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr, hue /= 6, \n            0 > hue && hue++;\n        }\n        return [ Math.round(360 * hue), Math.round(100 * saturation), Math.round(100 * brightness) ];\n    },\n    hsbToRgb: function() {\n        var br = Math.round(255 * (this[2] / 100));\n        if (0 == this[1]) return [ br, br, br ];\n        var hue = this[0] % 360, f = hue % 60, p = Math.round(255 * (this[2] * (100 - this[1]) / 1e4)), q = Math.round(255 * (this[2] * (6e3 - this[1] * f) / 6e5)), t = Math.round(255 * (this[2] * (6e3 - this[1] * (60 - f)) / 6e5));\n        switch (Math.floor(hue / 60)) {\n          case 0:\n            return [ br, t, p ];\n\n          case 1:\n            return [ q, br, p ];\n\n          case 2:\n            return [ p, br, t ];\n\n          case 3:\n            return [ p, q, br ];\n\n          case 4:\n            return [ t, p, br ];\n\n          case 5:\n            return [ br, p, q ];\n        }\n        return !1;\n    }\n}), String.implement({\n    rgbToHsb: function() {\n        var rgb = this.match(/\\d{1,3}/g);\n        return rgb ? rgb.rgbToHsb() : null;\n    },\n    hsbToRgb: function() {\n        var hsb = this.match(/\\d{1,3}/g);\n        return hsb ? hsb.hsbToRgb() : null;\n    }\n}), Request.JSON = new Class({\n    Extends: Request,\n    options: {\n        secure: !0\n    },\n    initialize: function(options) {\n        this.parent(options), this.headers.extend({\n            Accept: \"application/json\",\n            \"X-Request\": \"JSON\"\n        });\n    },\n    success: function(text) {\n        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);\n    }\n}), MooTools.More = {\n    version: \"1.2.5.1\",\n    build: \"254884f2b83651bf95260eed5c6cceb838e22d8e\"\n}, Class.Mutators.Binds = function(binds) {\n    return binds;\n}, Class.Mutators.initialize = function(initialize) {\n    return function() {\n        return $splat(this.Binds).each(function(name) {\n            var original = this[name];\n            original && (this[name] = original.bind(this));\n        }, this), initialize.apply(this, arguments);\n    };\n}, Fx.Elements = new Class({\n    Extends: Fx.CSS,\n    initialize: function(elements, options) {\n        this.elements = this.subject = $$(elements), this.parent(options);\n    },\n    compute: function(from, to, delta) {\n        var now = {};\n        for (var i in from) {\n            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};\n            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);\n        }\n        return now;\n    },\n    set: function(now) {\n        for (var i in now) if (this.elements[i]) {\n            var iNow = now[i];\n            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);\n        }\n        return this;\n    },\n    start: function(obj) {\n        if (!this.check(obj)) return this;\n        var from = {}, to = {};\n        for (var i in obj) if (this.elements[i]) {\n            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};\n            for (var p in iProps) {\n                var parsed = this.prepare(this.elements[i], p, iProps[p]);\n                iFrom[p] = parsed.from, iTo[p] = parsed.to;\n            }\n        }\n        return this.parent(from, to);\n    }\n}), Fx.Slide = new Class({\n    Extends: Fx,\n    options: {\n        mode: \"vertical\",\n        wrapper: !1,\n        hideOverflow: !0,\n        resetHeight: !1\n    },\n    initialize: function(element, options) {\n        this.addEvent(\"complete\", function() {\n            this.open = 0 != this.wrapper[\"offset\" + this.layout.capitalize()], this.open && this.options.resetHeight && this.wrapper.setStyle(\"height\", \"\"), \n            this.open && Browser.Engine.webkit419 && this.element.dispose().inject(this.wrapper);\n        }, !0), this.element = this.subject = document.id(element), this.parent(options);\n        var wrapper = this.element.retrieve(\"wrapper\"), styles = this.element.getStyles(\"margin\", \"position\", \"overflow\");\n        this.options.hideOverflow && (styles = $extend(styles, {\n            overflow: \"hidden\"\n        })), this.options.wrapper && (wrapper = document.id(this.options.wrapper).setStyles(styles)), \n        this.wrapper = wrapper || new Element(\"div\", {\n            styles: styles\n        }).wraps(this.element), this.element.store(\"wrapper\", this.wrapper).setStyle(\"margin\", 0), \n        this.now = [], this.open = !0;\n    },\n    vertical: function() {\n        this.margin = \"margin-top\", this.layout = \"height\", this.offset = this.element.offsetHeight;\n    },\n    horizontal: function() {\n        this.margin = \"margin-left\", this.layout = \"width\", this.offset = this.element.offsetWidth;\n    },\n    set: function(now) {\n        return this.element.setStyle(this.margin, now[0]), this.wrapper.setStyle(this.layout, now[1]), \n        this;\n    },\n    compute: function(from, to, delta) {\n        return [ 0, 1 ].map(function(i) {\n            return Fx.compute(from[i], to[i], delta);\n        });\n    },\n    start: function(how, mode) {\n        if (!this.check(how, mode)) return this;\n        this[mode || this.options.mode]();\n        var start, margin = this.element.getStyle(this.margin).toInt(), layout = this.wrapper.getStyle(this.layout).toInt(), caseIn = [ [ margin, layout ], [ 0, this.offset ] ], caseOut = [ [ margin, layout ], [ -this.offset, 0 ] ];\n        switch (how) {\n          case \"in\":\n            start = caseIn;\n            break;\n\n          case \"out\":\n            start = caseOut;\n            break;\n\n          case \"toggle\":\n            start = 0 == layout ? caseIn : caseOut;\n        }\n        return this.parent(start[0], start[1]);\n    },\n    slideIn: function(mode) {\n        return this.start(\"in\", mode);\n    },\n    slideOut: function(mode) {\n        return this.start(\"out\", mode);\n    },\n    hide: function(mode) {\n        return this[mode || this.options.mode](), this.open = !1, this.set([ -this.offset, 0 ]);\n    },\n    show: function(mode) {\n        return this[mode || this.options.mode](), this.open = !0, this.set([ 0, this.offset ]);\n    },\n    toggle: function(mode) {\n        return this.start(\"toggle\", mode);\n    }\n}), Element.Properties.slide = {\n    set: function(options) {\n        var slide = this.retrieve(\"slide\");\n        return slide && slide.cancel(), this.eliminate(\"slide\").store(\"slide:options\", $extend({\n            link: \"cancel\"\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"slide\")) && ((options || !this.retrieve(\"slide:options\")) && this.set(\"slide\", options), \n        this.store(\"slide\", new Fx.Slide(this, this.retrieve(\"slide:options\")))), this.retrieve(\"slide\");\n    }\n}, Element.implement({\n    slide: function(how, mode) {\n        how = how || \"toggle\";\n        var toggle, slide = this.get(\"slide\");\n        switch (how) {\n          case \"hide\":\n            slide.hide(mode);\n            break;\n\n          case \"show\":\n            slide.show(mode);\n            break;\n\n          case \"toggle\":\n            var flag = this.retrieve(\"slide:flag\", slide.open);\n            slide[flag ? \"slideOut\" : \"slideIn\"](mode), this.store(\"slide:flag\", !flag), toggle = !0;\n            break;\n\n          default:\n            slide.start(how, mode);\n        }\n        return toggle || this.eliminate(\"slide:flag\"), this;\n    }\n}), Hash.Cookie = new Class({\n    Extends: Cookie,\n    options: {\n        autoSave: !0\n    },\n    initialize: function(name, options) {\n        this.parent(name, options), this.load();\n    },\n    save: function() {\n        var value = JSON.encode(this.hash);\n        return !value || value.length > 4096 ? !1 : (\"{}\" == value ? this.dispose() : this.write(value), \n        !0);\n    },\n    load: function() {\n        return this.hash = new Hash(JSON.decode(this.read(), !0)), this;\n    }\n}), Hash.each(Hash.prototype, function(method, name) {\n    \"function\" == typeof method && Hash.Cookie.implement(name, function() {\n        var value = method.apply(this.hash, arguments);\n        return this.options.autoSave && this.save(), value;\n    });\n}), function() {\n    var read = function(option, element) {\n        return option ? \"function\" == $type(option) ? option(element) : element.get(option) : \"\";\n    };\n    this.Tips = new Class({\n        Implements: [ Events, Options ],\n        options: {\n            onShow: function() {\n                this.tip.setStyle(\"display\", \"block\");\n            },\n            onHide: function() {\n                this.tip.setStyle(\"display\", \"none\");\n            },\n            title: \"title\",\n            text: function(element) {\n                return element.get(\"rel\") || element.get(\"href\");\n            },\n            showDelay: 100,\n            hideDelay: 100,\n            className: \"tip-wrap\",\n            offset: {\n                x: 16,\n                y: 16\n            },\n            windowPadding: {\n                x: 0,\n                y: 0\n            },\n            fixed: !1\n        },\n        initialize: function() {\n            var params = Array.link(arguments, {\n                options: Object.type,\n                elements: $defined\n            });\n            this.setOptions(params.options), params.elements && this.attach(params.elements), \n            this.container = new Element(\"div\", {\n                \"class\": \"tip\"\n            });\n        },\n        toElement: function() {\n            return this.tip ? this.tip : this.tip = new Element(\"div\", {\n                \"class\": this.options.className,\n                styles: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0\n                }\n            }).adopt(new Element(\"div\", {\n                \"class\": \"tip-top\"\n            }), this.container, new Element(\"div\", {\n                \"class\": \"tip-bottom\"\n            }));\n        },\n        attach: function(elements) {\n            return $$(elements).each(function(element) {\n                var title = read(this.options.title, element), text = read(this.options.text, element);\n                element.erase(\"title\").store(\"tip:native\", title).retrieve(\"tip:title\", title), \n                element.retrieve(\"tip:text\", text), this.fireEvent(\"attach\", [ element ]);\n                var events = [ \"enter\", \"leave\" ];\n                this.options.fixed || events.push(\"move\"), events.each(function(value) {\n                    var event = element.retrieve(\"tip:\" + value);\n                    event || (event = this[\"element\" + value.capitalize()].bindWithEvent(this, element)), \n                    element.store(\"tip:\" + value, event).addEvent(\"mouse\" + value, event);\n                }, this);\n            }, this), this;\n        },\n        detach: function(elements) {\n            return $$(elements).each(function(element) {\n                if ([ \"enter\", \"leave\", \"move\" ].each(function(value) {\n                    element.removeEvent(\"mouse\" + value, element.retrieve(\"tip:\" + value)).eliminate(\"tip:\" + value);\n                }), this.fireEvent(\"detach\", [ element ]), \"title\" == this.options.title) {\n                    var original = element.retrieve(\"tip:native\");\n                    original && element.set(\"title\", original);\n                }\n            }, this), this;\n        },\n        elementEnter: function(event, element) {\n            this.container.empty(), [ \"title\", \"text\" ].each(function(value) {\n                var content = element.retrieve(\"tip:\" + value);\n                content && this.fill(new Element(\"div\", {\n                    \"class\": \"tip-\" + value\n                }).inject(this.container), content);\n            }, this), $clear(this.timer), this.timer = function() {\n                this.show(element), this.position(this.options.fixed ? {\n                    page: element.getPosition()\n                } : event);\n            }.delay(this.options.showDelay, this);\n        },\n        elementLeave: function(event, element) {\n            $clear(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, element), \n            this.fireForParent(event, element);\n        },\n        fireForParent: function(event, element) {\n            element = element.getParent(), element && element != document.body && (element.retrieve(\"tip:enter\") ? element.fireEvent(\"mouseenter\", event) : this.fireForParent(event, element));\n        },\n        elementMove: function(event) {\n            this.position(event);\n        },\n        position: function(event) {\n            this.tip || document.id(this);\n            var size = window.getSize(), scroll = window.getScroll(), tip = {\n                x: this.tip.offsetWidth,\n                y: this.tip.offsetHeight\n            }, props = {\n                x: \"left\",\n                y: \"top\"\n            }, obj = {};\n            for (var z in props) obj[props[z]] = event.page[z] + this.options.offset[z], obj[props[z]] + tip[z] - scroll[z] > size[z] - this.options.windowPadding[z] && (obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z]);\n            this.tip.setStyles(obj);\n        },\n        fill: function(element, contents) {\n            \"string\" == typeof contents ? element.set(\"html\", contents) : element.adopt(contents);\n        },\n        show: function(element) {\n            this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), \n            this.fireEvent(\"show\", [ this.tip, element ]);\n        },\n        hide: function(element) {\n            this.tip || document.id(this), this.fireEvent(\"hide\", [ this.tip, element ]);\n        }\n    });\n}();\n\nvar Color = new Native({\n    initialize: function(color, type) {\n        switch (arguments.length >= 3 ? (type = \"rgb\", color = Array.slice(arguments, 0, 3)) : \"string\" == typeof color && (color = color.match(/rgb/) ? color.rgbToHex().hexToRgb(!0) : color.match(/hsb/) ? color.hsbToRgb() : color.hexToRgb(!0)), \n        type = type || \"rgb\") {\n          case \"hsb\":\n            var old = color;\n            color = color.hsbToRgb(), color.hsb = old;\n            break;\n\n          case \"hex\":\n            color = color.hexToRgb(!0);\n        }\n        return color.rgb = color.slice(0, 3), color.hsb = color.hsb || color.rgbToHsb(), \n        color.hex = color.rgbToHex(), $extend(color, this);\n    }\n});\n\nColor.implement({\n    mix: function() {\n        var colors = Array.slice(arguments), alpha = \"number\" == $type(colors.getLast()) ? colors.pop() : 50, rgb = this.slice();\n        return colors.each(function(color) {\n            color = new Color(color);\n            for (var i = 0; 3 > i; i++) rgb[i] = Math.round(rgb[i] / 100 * (100 - alpha) + color[i] / 100 * alpha);\n        }), new Color(rgb, \"rgb\");\n    },\n    invert: function() {\n        return new Color(this.map(function(value) {\n            return 255 - value;\n        }));\n    },\n    setHue: function(value) {\n        return new Color([ value, this.hsb[1], this.hsb[2] ], \"hsb\");\n    },\n    setSaturation: function(percent) {\n        return new Color([ this.hsb[0], percent, this.hsb[2] ], \"hsb\");\n    },\n    setBrightness: function(percent) {\n        return new Color([ this.hsb[0], this.hsb[1], percent ], \"hsb\");\n    }\n});\n\nvar $RGB = function(r, g, b) {\n    return new Color([ r, g, b ], \"rgb\");\n}, $HSB = function(h, s, b) {\n    return new Color([ h, s, b ], \"hsb\");\n}, $HEX = function(hex) {\n    return new Color(hex, \"hex\");\n};\n\nArray.implement({\n    rgbToHsb: function() {\n        var red = this[0], green = this[1], blue = this[2], hue = 0, max = Math.max(red, green, blue), min = Math.min(red, green, blue), delta = max - min, brightness = max / 255, saturation = 0 != max ? delta / max : 0;\n        if (0 != saturation) {\n            var rr = (max - red) / delta, gr = (max - green) / delta, br = (max - blue) / delta;\n            hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr, hue /= 6, \n            0 > hue && hue++;\n        }\n        return [ Math.round(360 * hue), Math.round(100 * saturation), Math.round(100 * brightness) ];\n    },\n    hsbToRgb: function() {\n        var br = Math.round(255 * (this[2] / 100));\n        if (0 == this[1]) return [ br, br, br ];\n        var hue = this[0] % 360, f = hue % 60, p = Math.round(255 * (this[2] * (100 - this[1]) / 1e4)), q = Math.round(255 * (this[2] * (6e3 - this[1] * f) / 6e5)), t = Math.round(255 * (this[2] * (6e3 - this[1] * (60 - f)) / 6e5));\n        switch (Math.floor(hue / 60)) {\n          case 0:\n            return [ br, t, p ];\n\n          case 1:\n            return [ q, br, p ];\n\n          case 2:\n            return [ p, br, t ];\n\n          case 3:\n            return [ p, q, br ];\n\n          case 4:\n            return [ t, p, br ];\n\n          case 5:\n            return [ br, p, q ];\n        }\n        return !1;\n    }\n}), String.implement({\n    rgbToHsb: function() {\n        var rgb = this.match(/\\d{1,3}/g);\n        return rgb ? rgb.rgbToHsb() : null;\n    },\n    hsbToRgb: function() {\n        var hsb = this.match(/\\d{1,3}/g);\n        return hsb ? hsb.hsbToRgb() : null;\n    }\n}), Request.JSON = new Class({\n    Extends: Request,\n    options: {\n        secure: !0\n    },\n    initialize: function(options) {\n        this.parent(options), this.headers.extend({\n            Accept: \"application/json\",\n            \"X-Request\": \"JSON\"\n        });\n    },\n    success: function(text) {\n        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);\n    }\n}), MooTools.More = {\n    version: \"1.2.5.1\",\n    build: \"254884f2b83651bf95260eed5c6cceb838e22d8e\"\n}, Class.Mutators.Binds = function(binds) {\n    return binds;\n}, Class.Mutators.initialize = function(initialize) {\n    return function() {\n        return $splat(this.Binds).each(function(name) {\n            var original = this[name];\n            original && (this[name] = original.bind(this));\n        }, this), initialize.apply(this, arguments);\n    };\n}, Fx.Elements = new Class({\n    Extends: Fx.CSS,\n    initialize: function(elements, options) {\n        this.elements = this.subject = $$(elements), this.parent(options);\n    },\n    compute: function(from, to, delta) {\n        var now = {};\n        for (var i in from) {\n            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};\n            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);\n        }\n        return now;\n    },\n    set: function(now) {\n        for (var i in now) if (this.elements[i]) {\n            var iNow = now[i];\n            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);\n        }\n        return this;\n    },\n    start: function(obj) {\n        if (!this.check(obj)) return this;\n        var from = {}, to = {};\n        for (var i in obj) if (this.elements[i]) {\n            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};\n            for (var p in iProps) {\n                var parsed = this.prepare(this.elements[i], p, iProps[p]);\n                iFrom[p] = parsed.from, iTo[p] = parsed.to;\n            }\n        }\n        return this.parent(from, to);\n    }\n}), Fx.Slide = new Class({\n    Extends: Fx,\n    options: {\n        mode: \"vertical\",\n        wrapper: !1,\n        hideOverflow: !0,\n        resetHeight: !1\n    },\n    initialize: function(element, options) {\n        this.addEvent(\"complete\", function() {\n            this.open = 0 != this.wrapper[\"offset\" + this.layout.capitalize()], this.open && this.options.resetHeight && this.wrapper.setStyle(\"height\", \"\"), \n            this.open && Browser.Engine.webkit419 && this.element.dispose().inject(this.wrapper);\n        }, !0), this.element = this.subject = document.id(element), this.parent(options);\n        var wrapper = this.element.retrieve(\"wrapper\"), styles = this.element.getStyles(\"margin\", \"position\", \"overflow\");\n        this.options.hideOverflow && (styles = $extend(styles, {\n            overflow: \"hidden\"\n        })), this.options.wrapper && (wrapper = document.id(this.options.wrapper).setStyles(styles)), \n        this.wrapper = wrapper || new Element(\"div\", {\n            styles: styles\n        }).wraps(this.element), this.element.store(\"wrapper\", this.wrapper).setStyle(\"margin\", 0), \n        this.now = [], this.open = !0;\n    },\n    vertical: function() {\n        this.margin = \"margin-top\", this.layout = \"height\", this.offset = this.element.offsetHeight;\n    },\n    horizontal: function() {\n        this.margin = \"margin-left\", this.layout = \"width\", this.offset = this.element.offsetWidth;\n    },\n    set: function(now) {\n        return this.element.setStyle(this.margin, now[0]), this.wrapper.setStyle(this.layout, now[1]), \n        this;\n    },\n    compute: function(from, to, delta) {\n        return [ 0, 1 ].map(function(i) {\n            return Fx.compute(from[i], to[i], delta);\n        });\n    },\n    start: function(how, mode) {\n        if (!this.check(how, mode)) return this;\n        this[mode || this.options.mode]();\n        var start, margin = this.element.getStyle(this.margin).toInt(), layout = this.wrapper.getStyle(this.layout).toInt(), caseIn = [ [ margin, layout ], [ 0, this.offset ] ], caseOut = [ [ margin, layout ], [ -this.offset, 0 ] ];\n        switch (how) {\n          case \"in\":\n            start = caseIn;\n            break;\n\n          case \"out\":\n            start = caseOut;\n            break;\n\n          case \"toggle\":\n            start = 0 == layout ? caseIn : caseOut;\n        }\n        return this.parent(start[0], start[1]);\n    },\n    slideIn: function(mode) {\n        return this.start(\"in\", mode);\n    },\n    slideOut: function(mode) {\n        return this.start(\"out\", mode);\n    },\n    hide: function(mode) {\n        return this[mode || this.options.mode](), this.open = !1, this.set([ -this.offset, 0 ]);\n    },\n    show: function(mode) {\n        return this[mode || this.options.mode](), this.open = !0, this.set([ 0, this.offset ]);\n    },\n    toggle: function(mode) {\n        return this.start(\"toggle\", mode);\n    }\n}), Element.Properties.slide = {\n    set: function(options) {\n        var slide = this.retrieve(\"slide\");\n        return slide && slide.cancel(), this.eliminate(\"slide\").store(\"slide:options\", $extend({\n            link: \"cancel\"\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"slide\")) && ((options || !this.retrieve(\"slide:options\")) && this.set(\"slide\", options), \n        this.store(\"slide\", new Fx.Slide(this, this.retrieve(\"slide:options\")))), this.retrieve(\"slide\");\n    }\n}, Element.implement({\n    slide: function(how, mode) {\n        how = how || \"toggle\";\n        var toggle, slide = this.get(\"slide\");\n        switch (how) {\n          case \"hide\":\n            slide.hide(mode);\n            break;\n\n          case \"show\":\n            slide.show(mode);\n            break;\n\n          case \"toggle\":\n            var flag = this.retrieve(\"slide:flag\", slide.open);\n            slide[flag ? \"slideOut\" : \"slideIn\"](mode), this.store(\"slide:flag\", !flag), toggle = !0;\n            break;\n\n          default:\n            slide.start(how, mode);\n        }\n        return toggle || this.eliminate(\"slide:flag\"), this;\n    }\n}), Hash.Cookie = new Class({\n    Extends: Cookie,\n    options: {\n        autoSave: !0\n    },\n    initialize: function(name, options) {\n        this.parent(name, options), this.load();\n    },\n    save: function() {\n        var value = JSON.encode(this.hash);\n        return !value || value.length > 4096 ? !1 : (\"{}\" == value ? this.dispose() : this.write(value), \n        !0);\n    },\n    load: function() {\n        return this.hash = new Hash(JSON.decode(this.read(), !0)), this;\n    }\n}), Hash.each(Hash.prototype, function(method, name) {\n    \"function\" == typeof method && Hash.Cookie.implement(name, function() {\n        var value = method.apply(this.hash, arguments);\n        return this.options.autoSave && this.save(), value;\n    });\n}), function() {\n    var read = function(option, element) {\n        return option ? \"function\" == $type(option) ? option(element) : element.get(option) : \"\";\n    };\n    this.Tips = new Class({\n        Implements: [ Events, Options ],\n        options: {\n            onShow: function() {\n                this.tip.setStyle(\"display\", \"block\");\n            },\n            onHide: function() {\n                this.tip.setStyle(\"display\", \"none\");\n            },\n            title: \"title\",\n            text: function(element) {\n                return element.get(\"rel\") || element.get(\"href\");\n            },\n            showDelay: 100,\n            hideDelay: 100,\n            className: \"tip-wrap\",\n            offset: {\n                x: 16,\n                y: 16\n            },\n            windowPadding: {\n                x: 0,\n                y: 0\n            },\n            fixed: !1\n        },\n        initialize: function() {\n            var params = Array.link(arguments, {\n                options: Object.type,\n                elements: $defined\n            });\n            this.setOptions(params.options), params.elements && this.attach(params.elements), \n            this.container = new Element(\"div\", {\n                \"class\": \"tip\"\n            });\n        },\n        toElement: function() {\n            return this.tip ? this.tip : this.tip = new Element(\"div\", {\n                \"class\": this.options.className,\n                styles: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0\n                }\n            }).adopt(new Element(\"div\", {\n                \"class\": \"tip-top\"\n            }), this.container, new Element(\"div\", {\n                \"class\": \"tip-bottom\"\n            }));\n        },\n        attach: function(elements) {\n            return $$(elements).each(function(element) {\n                var title = read(this.options.title, element), text = read(this.options.text, element);\n                element.erase(\"title\").store(\"tip:native\", title).retrieve(\"tip:title\", title), \n                element.retrieve(\"tip:text\", text), this.fireEvent(\"attach\", [ element ]);\n                var events = [ \"enter\", \"leave\" ];\n                this.options.fixed || events.push(\"move\"), events.each(function(value) {\n                    var event = element.retrieve(\"tip:\" + value);\n                    event || (event = this[\"element\" + value.capitalize()].bindWithEvent(this, element)), \n                    element.store(\"tip:\" + value, event).addEvent(\"mouse\" + value, event);\n                }, this);\n            }, this), this;\n        },\n        detach: function(elements) {\n            return $$(elements).each(function(element) {\n                if ([ \"enter\", \"leave\", \"move\" ].each(function(value) {\n                    element.removeEvent(\"mouse\" + value, element.retrieve(\"tip:\" + value)).eliminate(\"tip:\" + value);\n                }), this.fireEvent(\"detach\", [ element ]), \"title\" == this.options.title) {\n                    var original = element.retrieve(\"tip:native\");\n                    original && element.set(\"title\", original);\n                }\n            }, this), this;\n        },\n        elementEnter: function(event, element) {\n            this.container.empty(), [ \"title\", \"text\" ].each(function(value) {\n                var content = element.retrieve(\"tip:\" + value);\n                content && this.fill(new Element(\"div\", {\n                    \"class\": \"tip-\" + value\n                }).inject(this.container), content);\n            }, this), $clear(this.timer), this.timer = function() {\n                this.show(element), this.position(this.options.fixed ? {\n                    page: element.getPosition()\n                } : event);\n            }.delay(this.options.showDelay, this);\n        },\n        elementLeave: function(event, element) {\n            $clear(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, element), \n            this.fireForParent(event, element);\n        },\n        fireForParent: function(event, element) {\n            element = element.getParent(), element && element != document.body && (element.retrieve(\"tip:enter\") ? element.fireEvent(\"mouseenter\", event) : this.fireForParent(event, element));\n        },\n        elementMove: function(event) {\n            this.position(event);\n        },\n        position: function(event) {\n            this.tip || document.id(this);\n            var size = window.getSize(), scroll = window.getScroll(), tip = {\n                x: this.tip.offsetWidth,\n                y: this.tip.offsetHeight\n            }, props = {\n                x: \"left\",\n                y: \"top\"\n            }, obj = {};\n            for (var z in props) obj[props[z]] = event.page[z] + this.options.offset[z], obj[props[z]] + tip[z] - scroll[z] > size[z] - this.options.windowPadding[z] && (obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z]);\n            this.tip.setStyles(obj);\n        },\n        fill: function(element, contents) {\n            \"string\" == typeof contents ? element.set(\"html\", contents) : element.adopt(contents);\n        },\n        show: function(element) {\n            this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), \n            this.fireEvent(\"show\", [ this.tip, element ]);\n        },\n        hide: function(element) {\n            this.tip || document.id(this), this.fireEvent(\"hide\", [ this.tip, element ]);\n        }\n    });\n}();\n\nvar Color = new Native({\n    initialize: function(color, type) {\n        switch (arguments.length >= 3 ? (type = \"rgb\", color = Array.slice(arguments, 0, 3)) : \"string\" == typeof color && (color = color.match(/rgb/) ? color.rgbToHex().hexToRgb(!0) : color.match(/hsb/) ? color.hsbToRgb() : color.hexToRgb(!0)), \n        type = type || \"rgb\") {\n          case \"hsb\":\n            var old = color;\n            color = color.hsbToRgb(), color.hsb = old;\n            break;\n\n          case \"hex\":\n            color = color.hexToRgb(!0);\n        }\n        return color.rgb = color.slice(0, 3), color.hsb = color.hsb || color.rgbToHsb(), \n        color.hex = color.rgbToHex(), $extend(color, this);\n    }\n});\n\nColor.implement({\n    mix: function() {\n        var colors = Array.slice(arguments), alpha = \"number\" == $type(colors.getLast()) ? colors.pop() : 50, rgb = this.slice();\n        return colors.each(function(color) {\n            color = new Color(color);\n            for (var i = 0; 3 > i; i++) rgb[i] = Math.round(rgb[i] / 100 * (100 - alpha) + color[i] / 100 * alpha);\n        }), new Color(rgb, \"rgb\");\n    },\n    invert: function() {\n        return new Color(this.map(function(value) {\n            return 255 - value;\n        }));\n    },\n    setHue: function(value) {\n        return new Color([ value, this.hsb[1], this.hsb[2] ], \"hsb\");\n    },\n    setSaturation: function(percent) {\n        return new Color([ this.hsb[0], percent, this.hsb[2] ], \"hsb\");\n    },\n    setBrightness: function(percent) {\n        return new Color([ this.hsb[0], this.hsb[1], percent ], \"hsb\");\n    }\n});\n\nvar $RGB = function(r, g, b) {\n    return new Color([ r, g, b ], \"rgb\");\n}, $HSB = function(h, s, b) {\n    return new Color([ h, s, b ], \"hsb\");\n}, $HEX = function(hex) {\n    return new Color(hex, \"hex\");\n};\n\nArray.implement({\n    rgbToHsb: function() {\n        var red = this[0], green = this[1], blue = this[2], hue = 0, max = Math.max(red, green, blue), min = Math.min(red, green, blue), delta = max - min, brightness = max / 255, saturation = 0 != max ? delta / max : 0;\n        if (0 != saturation) {\n            var rr = (max - red) / delta, gr = (max - green) / delta, br = (max - blue) / delta;\n            hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr, hue /= 6, \n            0 > hue && hue++;\n        }\n        return [ Math.round(360 * hue), Math.round(100 * saturation), Math.round(100 * brightness) ];\n    },\n    hsbToRgb: function() {\n        var br = Math.round(255 * (this[2] / 100));\n        if (0 == this[1]) return [ br, br, br ];\n        var hue = this[0] % 360, f = hue % 60, p = Math.round(255 * (this[2] * (100 - this[1]) / 1e4)), q = Math.round(255 * (this[2] * (6e3 - this[1] * f) / 6e5)), t = Math.round(255 * (this[2] * (6e3 - this[1] * (60 - f)) / 6e5));\n        switch (Math.floor(hue / 60)) {\n          case 0:\n            return [ br, t, p ];\n\n          case 1:\n            return [ q, br, p ];\n\n          case 2:\n            return [ p, br, t ];\n\n          case 3:\n            return [ p, q, br ];\n\n          case 4:\n            return [ t, p, br ];\n\n          case 5:\n            return [ br, p, q ];\n        }\n        return !1;\n    }\n}), String.implement({\n    rgbToHsb: function() {\n        var rgb = this.match(/\\d{1,3}/g);\n        return rgb ? rgb.rgbToHsb() : null;\n    },\n    hsbToRgb: function() {\n        var hsb = this.match(/\\d{1,3}/g);\n        return hsb ? hsb.hsbToRgb() : null;\n    }\n}), Request.JSON = new Class({\n    Extends: Request,\n    options: {\n        secure: !0\n    },\n    initialize: function(options) {\n        this.parent(options), this.headers.extend({\n            Accept: \"application/json\",\n            \"X-Request\": \"JSON\"\n        });\n    },\n    success: function(text) {\n        this.response.json = JSON.decode(text, this.options.secure), this.onSuccess(this.response.json, text);\n    }\n}), MooTools.More = {\n    version: \"1.2.5.1\",\n    build: \"254884f2b83651bf95260eed5c6cceb838e22d8e\"\n}, Class.Mutators.Binds = function(binds) {\n    return binds;\n}, Class.Mutators.initialize = function(initialize) {\n    return function() {\n        return $splat(this.Binds).each(function(name) {\n            var original = this[name];\n            original && (this[name] = original.bind(this));\n        }, this), initialize.apply(this, arguments);\n    };\n}, Fx.Elements = new Class({\n    Extends: Fx.CSS,\n    initialize: function(elements, options) {\n        this.elements = this.subject = $$(elements), this.parent(options);\n    },\n    compute: function(from, to, delta) {\n        var now = {};\n        for (var i in from) {\n            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};\n            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);\n        }\n        return now;\n    },\n    set: function(now) {\n        for (var i in now) if (this.elements[i]) {\n            var iNow = now[i];\n            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);\n        }\n        return this;\n    },\n    start: function(obj) {\n        if (!this.check(obj)) return this;\n        var from = {}, to = {};\n        for (var i in obj) if (this.elements[i]) {\n            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};\n            for (var p in iProps) {\n                var parsed = this.prepare(this.elements[i], p, iProps[p]);\n                iFrom[p] = parsed.from, iTo[p] = parsed.to;\n            }\n        }\n        return this.parent(from, to);\n    }\n}), Fx.Slide = new Class({\n    Extends: Fx,\n    options: {\n        mode: \"vertical\",\n        wrapper: !1,\n        hideOverflow: !0,\n        resetHeight: !1\n    },\n    initialize: function(element, options) {\n        this.addEvent(\"complete\", function() {\n            this.open = 0 != this.wrapper[\"offset\" + this.layout.capitalize()], this.open && this.options.resetHeight && this.wrapper.setStyle(\"height\", \"\"), \n            this.open && Browser.Engine.webkit419 && this.element.dispose().inject(this.wrapper);\n        }, !0), this.element = this.subject = document.id(element), this.parent(options);\n        var wrapper = this.element.retrieve(\"wrapper\"), styles = this.element.getStyles(\"margin\", \"position\", \"overflow\");\n        this.options.hideOverflow && (styles = $extend(styles, {\n            overflow: \"hidden\"\n        })), this.options.wrapper && (wrapper = document.id(this.options.wrapper).setStyles(styles)), \n        this.wrapper = wrapper || new Element(\"div\", {\n            styles: styles\n        }).wraps(this.element), this.element.store(\"wrapper\", this.wrapper).setStyle(\"margin\", 0), \n        this.now = [], this.open = !0;\n    },\n    vertical: function() {\n        this.margin = \"margin-top\", this.layout = \"height\", this.offset = this.element.offsetHeight;\n    },\n    horizontal: function() {\n        this.margin = \"margin-left\", this.layout = \"width\", this.offset = this.element.offsetWidth;\n    },\n    set: function(now) {\n        return this.element.setStyle(this.margin, now[0]), this.wrapper.setStyle(this.layout, now[1]), \n        this;\n    },\n    compute: function(from, to, delta) {\n        return [ 0, 1 ].map(function(i) {\n            return Fx.compute(from[i], to[i], delta);\n        });\n    },\n    start: function(how, mode) {\n        if (!this.check(how, mode)) return this;\n        this[mode || this.options.mode]();\n        var start, margin = this.element.getStyle(this.margin).toInt(), layout = this.wrapper.getStyle(this.layout).toInt(), caseIn = [ [ margin, layout ], [ 0, this.offset ] ], caseOut = [ [ margin, layout ], [ -this.offset, 0 ] ];\n        switch (how) {\n          case \"in\":\n            start = caseIn;\n            break;\n\n          case \"out\":\n            start = caseOut;\n            break;\n\n          case \"toggle\":\n            start = 0 == layout ? caseIn : caseOut;\n        }\n        return this.parent(start[0], start[1]);\n    },\n    slideIn: function(mode) {\n        return this.start(\"in\", mode);\n    },\n    slideOut: function(mode) {\n        return this.start(\"out\", mode);\n    },\n    hide: function(mode) {\n        return this[mode || this.options.mode](), this.open = !1, this.set([ -this.offset, 0 ]);\n    },\n    show: function(mode) {\n        return this[mode || this.options.mode](), this.open = !0, this.set([ 0, this.offset ]);\n    },\n    toggle: function(mode) {\n        return this.start(\"toggle\", mode);\n    }\n}), Element.Properties.slide = {\n    set: function(options) {\n        var slide = this.retrieve(\"slide\");\n        return slide && slide.cancel(), this.eliminate(\"slide\").store(\"slide:options\", $extend({\n            link: \"cancel\"\n        }, options));\n    },\n    get: function(options) {\n        return (options || !this.retrieve(\"slide\")) && ((options || !this.retrieve(\"slide:options\")) && this.set(\"slide\", options), \n        this.store(\"slide\", new Fx.Slide(this, this.retrieve(\"slide:options\")))), this.retrieve(\"slide\");\n    }\n}, Element.implement({\n    slide: function(how, mode) {\n        how = how || \"toggle\";\n        var toggle, slide = this.get(\"slide\");\n        switch (how) {\n          case \"hide\":\n            slide.hide(mode);\n            break;\n\n          case \"show\":\n            slide.show(mode);\n            break;\n\n          case \"toggle\":\n            var flag = this.retrieve(\"slide:flag\", slide.open);\n            slide[flag ? \"slideOut\" : \"slideIn\"](mode), this.store(\"slide:flag\", !flag), toggle = !0;\n            break;\n\n          default:\n            slide.start(how, mode);\n        }\n        return toggle || this.eliminate(\"slide:flag\"), this;\n    }\n}), Hash.Cookie = new Class({\n    Extends: Cookie,\n    options: {\n        autoSave: !0\n    },\n    initialize: function(name, options) {\n        this.parent(name, options), this.load();\n    },\n    save: function() {\n        var value = JSON.encode(this.hash);\n        return !value || value.length > 4096 ? !1 : (\"{}\" == value ? this.dispose() : this.write(value), \n        !0);\n    },\n    load: function() {\n        return this.hash = new Hash(JSON.decode(this.read(), !0)), this;\n    }\n}), Hash.each(Hash.prototype, function(method, name) {\n    \"function\" == typeof method && Hash.Cookie.implement(name, function() {\n        var value = method.apply(this.hash, arguments);\n        return this.options.autoSave && this.save(), value;\n    });\n}), function() {\n    var read = function(option, element) {\n        return option ? \"function\" == $type(option) ? option(element) : element.get(option) : \"\";\n    };\n    this.Tips = new Class({\n        Implements: [ Events, Options ],\n        options: {\n            onShow: function() {\n                this.tip.setStyle(\"display\", \"block\");\n            },\n            onHide: function() {\n                this.tip.setStyle(\"display\", \"none\");\n            },\n            title: \"title\",\n            text: function(element) {\n                return element.get(\"rel\") || element.get(\"href\");\n            },\n            showDelay: 100,\n            hideDelay: 100,\n            className: \"tip-wrap\",\n            offset: {\n                x: 16,\n                y: 16\n            },\n            windowPadding: {\n                x: 0,\n                y: 0\n            },\n            fixed: !1\n        },\n        initialize: function() {\n            var params = Array.link(arguments, {\n                options: Object.type,\n                elements: $defined\n            });\n            this.setOptions(params.options), params.elements && this.attach(params.elements), \n            this.container = new Element(\"div\", {\n                \"class\": \"tip\"\n            });\n        },\n        toElement: function() {\n            return this.tip ? this.tip : this.tip = new Element(\"div\", {\n                \"class\": this.options.className,\n                styles: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0\n                }\n            }).adopt(new Element(\"div\", {\n                \"class\": \"tip-top\"\n            }), this.container, new Element(\"div\", {\n                \"class\": \"tip-bottom\"\n            }));\n        },\n        attach: function(elements) {\n            return $$(elements).each(function(element) {\n                var title = read(this.options.title, element), text = read(this.options.text, element);\n                element.erase(\"title\").store(\"tip:native\", title).retrieve(\"tip:title\", title), \n                element.retrieve(\"tip:text\", text), this.fireEvent(\"attach\", [ element ]);\n                var events = [ \"enter\", \"leave\" ];\n                this.options.fixed || events.push(\"move\"), events.each(function(value) {\n                    var event = element.retrieve(\"tip:\" + value);\n                    event || (event = this[\"element\" + value.capitalize()].bindWithEvent(this, element)), \n                    element.store(\"tip:\" + value, event).addEvent(\"mouse\" + value, event);\n                }, this);\n            }, this), this;\n        },\n        detach: function(elements) {\n            return $$(elements).each(function(element) {\n                if ([ \"enter\", \"leave\", \"move\" ].each(function(value) {\n                    element.removeEvent(\"mouse\" + value, element.retrieve(\"tip:\" + value)).eliminate(\"tip:\" + value);\n                }), this.fireEvent(\"detach\", [ element ]), \"title\" == this.options.title) {\n                    var original = element.retrieve(\"tip:native\");\n                    original && element.set(\"title\", original);\n                }\n            }, this), this;\n        },\n        elementEnter: function(event, element) {\n            this.container.empty(), [ \"title\", \"text\" ].each(function(value) {\n                var content = element.retrieve(\"tip:\" + value);\n                content && this.fill(new Element(\"div\", {\n                    \"class\": \"tip-\" + value\n                }).inject(this.container), content);\n            }, this), $clear(this.timer), this.timer = function() {\n                this.show(element), this.position(this.options.fixed ? {\n                    page: element.getPosition()\n                } : event);\n            }.delay(this.options.showDelay, this);\n        },\n        elementLeave: function(event, element) {\n            $clear(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, element), \n            this.fireForParent(event, element);\n        },\n        fireForParent: function(event, element) {\n            element = element.getParent(), element && element != document.body && (element.retrieve(\"tip:enter\") ? element.fireEvent(\"mouseenter\", event) : this.fireForParent(event, element));\n        },\n        elementMove: function(event) {\n            this.position(event);\n        },\n        position: function(event) {\n            this.tip || document.id(this);\n            var size = window.getSize(), scroll = window.getScroll(), tip = {\n                x: this.tip.offsetWidth,\n                y: this.tip.offsetHeight\n            }, props = {\n                x: \"left\",\n                y: \"top\"\n            }, obj = {};\n            for (var z in props) obj[props[z]] = event.page[z] + this.options.offset[z], obj[props[z]] + tip[z] - scroll[z] > size[z] - this.options.windowPadding[z] && (obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z]);\n            this.tip.setStyles(obj);\n        },\n        fill: function(element, contents) {\n            \"string\" == typeof contents ? element.set(\"html\", contents) : element.adopt(contents);\n        },\n        show: function(element) {\n            this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), \n            this.fireEvent(\"show\", [ this.tip, element ]);\n        },\n        hide: function(element) {\n            this.tip || document.id(this), this.fireEvent(\"hide\", [ this.tip, element ]);\n        }\n    });\n}(), this.Handlebars = {}, function(Handlebars) {\n    Handlebars.VERSION = \"1.0.0-rc.3\", Handlebars.COMPILER_REVISION = 2, Handlebars.REVISION_CHANGES = {\n        1: \"<= 1.0.rc.2\",\n        2: \">= 1.0.0-rc.3\"\n    }, Handlebars.helpers = {}, Handlebars.partials = {}, Handlebars.registerHelper = function(name, fn, inverse) {\n        inverse && (fn.not = inverse), this.helpers[name] = fn;\n    }, Handlebars.registerPartial = function(name, str) {\n        this.partials[name] = str;\n    }, Handlebars.registerHelper(\"helperMissing\", function(arg) {\n        if (2 === arguments.length) return void 0;\n        throw Error(\"Could not find property '\" + arg + \"'\");\n    });\n    var toString = Object.prototype.toString, functionType = \"[object Function]\";\n    Handlebars.registerHelper(\"blockHelperMissing\", function(context, options) {\n        var inverse = options.inverse || function() {}, fn = options.fn, type = toString.call(context);\n        return type === functionType && (context = context.call(this)), context === !0 ? fn(this) : context === !1 || null == context ? inverse(this) : \"[object Array]\" === type ? context.length > 0 ? Handlebars.helpers.each(context, options) : inverse(this) : fn(context);\n    }), Handlebars.K = function() {}, Handlebars.createFrame = Object.create || function(object) {\n        Handlebars.K.prototype = object;\n        var obj = new Handlebars.K();\n        return Handlebars.K.prototype = null, obj;\n    }, Handlebars.logger = {\n        DEBUG: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        level: 3,\n        methodMap: {\n            0: \"debug\",\n            1: \"info\",\n            2: \"warn\",\n            3: \"error\"\n        },\n        log: function(level, obj) {\n            if (level >= Handlebars.logger.level) {\n                var method = Handlebars.logger.methodMap[level];\n                \"undefined\" != typeof console && console[method] && console[method].call(console, obj);\n            }\n        }\n    }, Handlebars.log = function(level, obj) {\n        Handlebars.logger.log(level, obj);\n    }, Handlebars.registerHelper(\"each\", function(context, options) {\n        var data, fn = options.fn, inverse = options.inverse, i = 0, ret = \"\";\n        if (options.data && (data = Handlebars.createFrame(options.data)), context && \"object\" == typeof context) if (context instanceof Array) for (var j = context.length; j > i; i++) data && (data.index = i), \n        ret += fn(context[i], {\n            data: data\n        }); else for (var key in context) context.hasOwnProperty(key) && (data && (data.key = key), \n        ret += fn(context[key], {\n            data: data\n        }), i++);\n        return 0 === i && (ret = inverse(this)), ret;\n    }), Handlebars.registerHelper(\"if\", function(context, options) {\n        var type = toString.call(context);\n        return type === functionType && (context = context.call(this)), !context || Handlebars.Utils.isEmpty(context) ? options.inverse(this) : options.fn(this);\n    }), Handlebars.registerHelper(\"unless\", function(context, options) {\n        var fn = options.fn, inverse = options.inverse;\n        return options.fn = inverse, options.inverse = fn, Handlebars.helpers[\"if\"].call(this, context, options);\n    }), Handlebars.registerHelper(\"with\", function(context, options) {\n        return options.fn(context);\n    }), Handlebars.registerHelper(\"log\", function(context, options) {\n        var level = options.data && null != options.data.level ? parseInt(options.data.level, 10) : 1;\n        Handlebars.log(level, context);\n    });\n}(this.Handlebars);\n\nvar handlebars = function() {\n    function Parser() {\n        this.yy = {};\n    }\n    var parser = {\n        trace: function() {},\n        yy: {},\n        symbols_: {\n            error: 2,\n            root: 3,\n            program: 4,\n            EOF: 5,\n            simpleInverse: 6,\n            statements: 7,\n            statement: 8,\n            openInverse: 9,\n            closeBlock: 10,\n            openBlock: 11,\n            mustache: 12,\n            partial: 13,\n            CONTENT: 14,\n            COMMENT: 15,\n            OPEN_BLOCK: 16,\n            inMustache: 17,\n            CLOSE: 18,\n            OPEN_INVERSE: 19,\n            OPEN_ENDBLOCK: 20,\n            path: 21,\n            OPEN: 22,\n            OPEN_UNESCAPED: 23,\n            OPEN_PARTIAL: 24,\n            partialName: 25,\n            params: 26,\n            hash: 27,\n            DATA: 28,\n            param: 29,\n            STRING: 30,\n            INTEGER: 31,\n            BOOLEAN: 32,\n            hashSegments: 33,\n            hashSegment: 34,\n            ID: 35,\n            EQUALS: 36,\n            PARTIAL_NAME: 37,\n            pathSegments: 38,\n            SEP: 39,\n            $accept: 0,\n            $end: 1\n        },\n        terminals_: {\n            2: \"error\",\n            5: \"EOF\",\n            14: \"CONTENT\",\n            15: \"COMMENT\",\n            16: \"OPEN_BLOCK\",\n            18: \"CLOSE\",\n            19: \"OPEN_INVERSE\",\n            20: \"OPEN_ENDBLOCK\",\n            22: \"OPEN\",\n            23: \"OPEN_UNESCAPED\",\n            24: \"OPEN_PARTIAL\",\n            28: \"DATA\",\n            30: \"STRING\",\n            31: \"INTEGER\",\n            32: \"BOOLEAN\",\n            35: \"ID\",\n            36: \"EQUALS\",\n            37: \"PARTIAL_NAME\",\n            39: \"SEP\"\n        },\n        productions_: [ 0, [ 3, 2 ], [ 4, 2 ], [ 4, 3 ], [ 4, 2 ], [ 4, 1 ], [ 4, 1 ], [ 4, 0 ], [ 7, 1 ], [ 7, 2 ], [ 8, 3 ], [ 8, 3 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 11, 3 ], [ 9, 3 ], [ 10, 3 ], [ 12, 3 ], [ 12, 3 ], [ 13, 3 ], [ 13, 4 ], [ 6, 2 ], [ 17, 3 ], [ 17, 2 ], [ 17, 2 ], [ 17, 1 ], [ 17, 1 ], [ 26, 2 ], [ 26, 1 ], [ 29, 1 ], [ 29, 1 ], [ 29, 1 ], [ 29, 1 ], [ 29, 1 ], [ 27, 1 ], [ 33, 2 ], [ 33, 1 ], [ 34, 3 ], [ 34, 3 ], [ 34, 3 ], [ 34, 3 ], [ 34, 3 ], [ 25, 1 ], [ 21, 1 ], [ 38, 3 ], [ 38, 1 ] ],\n        performAction: function(yytext, yyleng, yylineno, yy, yystate, $$) {\n            var $0 = $$.length - 1;\n            switch (yystate) {\n              case 1:\n                return $$[$0 - 1];\n\n              case 2:\n                this.$ = new yy.ProgramNode([], $$[$0]);\n                break;\n\n              case 3:\n                this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0]);\n                break;\n\n              case 4:\n                this.$ = new yy.ProgramNode($$[$0 - 1], []);\n                break;\n\n              case 5:\n                this.$ = new yy.ProgramNode($$[$0]);\n                break;\n\n              case 6:\n                this.$ = new yy.ProgramNode([], []);\n                break;\n\n              case 7:\n                this.$ = new yy.ProgramNode([]);\n                break;\n\n              case 8:\n                this.$ = [ $$[$0] ];\n                break;\n\n              case 9:\n                $$[$0 - 1].push($$[$0]), this.$ = $$[$0 - 1];\n                break;\n\n              case 10:\n                this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1].inverse, $$[$0 - 1], $$[$0]);\n                break;\n\n              case 11:\n                this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0 - 1].inverse, $$[$0]);\n                break;\n\n              case 12:\n                this.$ = $$[$0];\n                break;\n\n              case 13:\n                this.$ = $$[$0];\n                break;\n\n              case 14:\n                this.$ = new yy.ContentNode($$[$0]);\n                break;\n\n              case 15:\n                this.$ = new yy.CommentNode($$[$0]);\n                break;\n\n              case 16:\n                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);\n                break;\n\n              case 17:\n                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);\n                break;\n\n              case 18:\n                this.$ = $$[$0 - 1];\n                break;\n\n              case 19:\n                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1]);\n                break;\n\n              case 20:\n                this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1], !0);\n                break;\n\n              case 21:\n                this.$ = new yy.PartialNode($$[$0 - 1]);\n                break;\n\n              case 22:\n                this.$ = new yy.PartialNode($$[$0 - 2], $$[$0 - 1]);\n                break;\n\n              case 23:\n                break;\n\n              case 24:\n                this.$ = [ [ $$[$0 - 2] ].concat($$[$0 - 1]), $$[$0] ];\n                break;\n\n              case 25:\n                this.$ = [ [ $$[$0 - 1] ].concat($$[$0]), null ];\n                break;\n\n              case 26:\n                this.$ = [ [ $$[$0 - 1] ], $$[$0] ];\n                break;\n\n              case 27:\n                this.$ = [ [ $$[$0] ], null ];\n                break;\n\n              case 28:\n                this.$ = [ [ new yy.DataNode($$[$0]) ], null ];\n                break;\n\n              case 29:\n                $$[$0 - 1].push($$[$0]), this.$ = $$[$0 - 1];\n                break;\n\n              case 30:\n                this.$ = [ $$[$0] ];\n                break;\n\n              case 31:\n                this.$ = $$[$0];\n                break;\n\n              case 32:\n                this.$ = new yy.StringNode($$[$0]);\n                break;\n\n              case 33:\n                this.$ = new yy.IntegerNode($$[$0]);\n                break;\n\n              case 34:\n                this.$ = new yy.BooleanNode($$[$0]);\n                break;\n\n              case 35:\n                this.$ = new yy.DataNode($$[$0]);\n                break;\n\n              case 36:\n                this.$ = new yy.HashNode($$[$0]);\n                break;\n\n              case 37:\n                $$[$0 - 1].push($$[$0]), this.$ = $$[$0 - 1];\n                break;\n\n              case 38:\n                this.$ = [ $$[$0] ];\n                break;\n\n              case 39:\n                this.$ = [ $$[$0 - 2], $$[$0] ];\n                break;\n\n              case 40:\n                this.$ = [ $$[$0 - 2], new yy.StringNode($$[$0]) ];\n                break;\n\n              case 41:\n                this.$ = [ $$[$0 - 2], new yy.IntegerNode($$[$0]) ];\n                break;\n\n              case 42:\n                this.$ = [ $$[$0 - 2], new yy.BooleanNode($$[$0]) ];\n                break;\n\n              case 43:\n                this.$ = [ $$[$0 - 2], new yy.DataNode($$[$0]) ];\n                break;\n\n              case 44:\n                this.$ = new yy.PartialNameNode($$[$0]);\n                break;\n\n              case 45:\n                this.$ = new yy.IdNode($$[$0]);\n                break;\n\n              case 46:\n                $$[$0 - 2].push($$[$0]), this.$ = $$[$0 - 2];\n                break;\n\n              case 47:\n                this.$ = [ $$[$0] ];\n            }\n        },\n        table: [ {\n            3: 1,\n            4: 2,\n            5: [ 2, 7 ],\n            6: 3,\n            7: 4,\n            8: 6,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 5 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            1: [ 3 ]\n        }, {\n            5: [ 1, 17 ]\n        }, {\n            5: [ 2, 6 ],\n            7: 18,\n            8: 6,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 19 ],\n            20: [ 2, 6 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            5: [ 2, 5 ],\n            6: 20,\n            8: 21,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 5 ],\n            20: [ 2, 5 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            17: 23,\n            18: [ 1, 22 ],\n            21: 24,\n            28: [ 1, 25 ],\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            5: [ 2, 8 ],\n            14: [ 2, 8 ],\n            15: [ 2, 8 ],\n            16: [ 2, 8 ],\n            19: [ 2, 8 ],\n            20: [ 2, 8 ],\n            22: [ 2, 8 ],\n            23: [ 2, 8 ],\n            24: [ 2, 8 ]\n        }, {\n            4: 28,\n            6: 3,\n            7: 4,\n            8: 6,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 5 ],\n            20: [ 2, 7 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            4: 29,\n            6: 3,\n            7: 4,\n            8: 6,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 5 ],\n            20: [ 2, 7 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            5: [ 2, 12 ],\n            14: [ 2, 12 ],\n            15: [ 2, 12 ],\n            16: [ 2, 12 ],\n            19: [ 2, 12 ],\n            20: [ 2, 12 ],\n            22: [ 2, 12 ],\n            23: [ 2, 12 ],\n            24: [ 2, 12 ]\n        }, {\n            5: [ 2, 13 ],\n            14: [ 2, 13 ],\n            15: [ 2, 13 ],\n            16: [ 2, 13 ],\n            19: [ 2, 13 ],\n            20: [ 2, 13 ],\n            22: [ 2, 13 ],\n            23: [ 2, 13 ],\n            24: [ 2, 13 ]\n        }, {\n            5: [ 2, 14 ],\n            14: [ 2, 14 ],\n            15: [ 2, 14 ],\n            16: [ 2, 14 ],\n            19: [ 2, 14 ],\n            20: [ 2, 14 ],\n            22: [ 2, 14 ],\n            23: [ 2, 14 ],\n            24: [ 2, 14 ]\n        }, {\n            5: [ 2, 15 ],\n            14: [ 2, 15 ],\n            15: [ 2, 15 ],\n            16: [ 2, 15 ],\n            19: [ 2, 15 ],\n            20: [ 2, 15 ],\n            22: [ 2, 15 ],\n            23: [ 2, 15 ],\n            24: [ 2, 15 ]\n        }, {\n            17: 30,\n            21: 24,\n            28: [ 1, 25 ],\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            17: 31,\n            21: 24,\n            28: [ 1, 25 ],\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            17: 32,\n            21: 24,\n            28: [ 1, 25 ],\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            25: 33,\n            37: [ 1, 34 ]\n        }, {\n            1: [ 2, 1 ]\n        }, {\n            5: [ 2, 2 ],\n            8: 21,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 19 ],\n            20: [ 2, 2 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            17: 23,\n            21: 24,\n            28: [ 1, 25 ],\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            5: [ 2, 4 ],\n            7: 35,\n            8: 6,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 19 ],\n            20: [ 2, 4 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            5: [ 2, 9 ],\n            14: [ 2, 9 ],\n            15: [ 2, 9 ],\n            16: [ 2, 9 ],\n            19: [ 2, 9 ],\n            20: [ 2, 9 ],\n            22: [ 2, 9 ],\n            23: [ 2, 9 ],\n            24: [ 2, 9 ]\n        }, {\n            5: [ 2, 23 ],\n            14: [ 2, 23 ],\n            15: [ 2, 23 ],\n            16: [ 2, 23 ],\n            19: [ 2, 23 ],\n            20: [ 2, 23 ],\n            22: [ 2, 23 ],\n            23: [ 2, 23 ],\n            24: [ 2, 23 ]\n        }, {\n            18: [ 1, 36 ]\n        }, {\n            18: [ 2, 27 ],\n            21: 41,\n            26: 37,\n            27: 38,\n            28: [ 1, 45 ],\n            29: 39,\n            30: [ 1, 42 ],\n            31: [ 1, 43 ],\n            32: [ 1, 44 ],\n            33: 40,\n            34: 46,\n            35: [ 1, 47 ],\n            38: 26\n        }, {\n            18: [ 2, 28 ]\n        }, {\n            18: [ 2, 45 ],\n            28: [ 2, 45 ],\n            30: [ 2, 45 ],\n            31: [ 2, 45 ],\n            32: [ 2, 45 ],\n            35: [ 2, 45 ],\n            39: [ 1, 48 ]\n        }, {\n            18: [ 2, 47 ],\n            28: [ 2, 47 ],\n            30: [ 2, 47 ],\n            31: [ 2, 47 ],\n            32: [ 2, 47 ],\n            35: [ 2, 47 ],\n            39: [ 2, 47 ]\n        }, {\n            10: 49,\n            20: [ 1, 50 ]\n        }, {\n            10: 51,\n            20: [ 1, 50 ]\n        }, {\n            18: [ 1, 52 ]\n        }, {\n            18: [ 1, 53 ]\n        }, {\n            18: [ 1, 54 ]\n        }, {\n            18: [ 1, 55 ],\n            21: 56,\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            18: [ 2, 44 ],\n            35: [ 2, 44 ]\n        }, {\n            5: [ 2, 3 ],\n            8: 21,\n            9: 7,\n            11: 8,\n            12: 9,\n            13: 10,\n            14: [ 1, 11 ],\n            15: [ 1, 12 ],\n            16: [ 1, 13 ],\n            19: [ 1, 19 ],\n            20: [ 2, 3 ],\n            22: [ 1, 14 ],\n            23: [ 1, 15 ],\n            24: [ 1, 16 ]\n        }, {\n            14: [ 2, 17 ],\n            15: [ 2, 17 ],\n            16: [ 2, 17 ],\n            19: [ 2, 17 ],\n            20: [ 2, 17 ],\n            22: [ 2, 17 ],\n            23: [ 2, 17 ],\n            24: [ 2, 17 ]\n        }, {\n            18: [ 2, 25 ],\n            21: 41,\n            27: 57,\n            28: [ 1, 45 ],\n            29: 58,\n            30: [ 1, 42 ],\n            31: [ 1, 43 ],\n            32: [ 1, 44 ],\n            33: 40,\n            34: 46,\n            35: [ 1, 47 ],\n            38: 26\n        }, {\n            18: [ 2, 26 ]\n        }, {\n            18: [ 2, 30 ],\n            28: [ 2, 30 ],\n            30: [ 2, 30 ],\n            31: [ 2, 30 ],\n            32: [ 2, 30 ],\n            35: [ 2, 30 ]\n        }, {\n            18: [ 2, 36 ],\n            34: 59,\n            35: [ 1, 60 ]\n        }, {\n            18: [ 2, 31 ],\n            28: [ 2, 31 ],\n            30: [ 2, 31 ],\n            31: [ 2, 31 ],\n            32: [ 2, 31 ],\n            35: [ 2, 31 ]\n        }, {\n            18: [ 2, 32 ],\n            28: [ 2, 32 ],\n            30: [ 2, 32 ],\n            31: [ 2, 32 ],\n            32: [ 2, 32 ],\n            35: [ 2, 32 ]\n        }, {\n            18: [ 2, 33 ],\n            28: [ 2, 33 ],\n            30: [ 2, 33 ],\n            31: [ 2, 33 ],\n            32: [ 2, 33 ],\n            35: [ 2, 33 ]\n        }, {\n            18: [ 2, 34 ],\n            28: [ 2, 34 ],\n            30: [ 2, 34 ],\n            31: [ 2, 34 ],\n            32: [ 2, 34 ],\n            35: [ 2, 34 ]\n        }, {\n            18: [ 2, 35 ],\n            28: [ 2, 35 ],\n            30: [ 2, 35 ],\n            31: [ 2, 35 ],\n            32: [ 2, 35 ],\n            35: [ 2, 35 ]\n        }, {\n            18: [ 2, 38 ],\n            35: [ 2, 38 ]\n        }, {\n            18: [ 2, 47 ],\n            28: [ 2, 47 ],\n            30: [ 2, 47 ],\n            31: [ 2, 47 ],\n            32: [ 2, 47 ],\n            35: [ 2, 47 ],\n            36: [ 1, 61 ],\n            39: [ 2, 47 ]\n        }, {\n            35: [ 1, 62 ]\n        }, {\n            5: [ 2, 10 ],\n            14: [ 2, 10 ],\n            15: [ 2, 10 ],\n            16: [ 2, 10 ],\n            19: [ 2, 10 ],\n            20: [ 2, 10 ],\n            22: [ 2, 10 ],\n            23: [ 2, 10 ],\n            24: [ 2, 10 ]\n        }, {\n            21: 63,\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            5: [ 2, 11 ],\n            14: [ 2, 11 ],\n            15: [ 2, 11 ],\n            16: [ 2, 11 ],\n            19: [ 2, 11 ],\n            20: [ 2, 11 ],\n            22: [ 2, 11 ],\n            23: [ 2, 11 ],\n            24: [ 2, 11 ]\n        }, {\n            14: [ 2, 16 ],\n            15: [ 2, 16 ],\n            16: [ 2, 16 ],\n            19: [ 2, 16 ],\n            20: [ 2, 16 ],\n            22: [ 2, 16 ],\n            23: [ 2, 16 ],\n            24: [ 2, 16 ]\n        }, {\n            5: [ 2, 19 ],\n            14: [ 2, 19 ],\n            15: [ 2, 19 ],\n            16: [ 2, 19 ],\n            19: [ 2, 19 ],\n            20: [ 2, 19 ],\n            22: [ 2, 19 ],\n            23: [ 2, 19 ],\n            24: [ 2, 19 ]\n        }, {\n            5: [ 2, 20 ],\n            14: [ 2, 20 ],\n            15: [ 2, 20 ],\n            16: [ 2, 20 ],\n            19: [ 2, 20 ],\n            20: [ 2, 20 ],\n            22: [ 2, 20 ],\n            23: [ 2, 20 ],\n            24: [ 2, 20 ]\n        }, {\n            5: [ 2, 21 ],\n            14: [ 2, 21 ],\n            15: [ 2, 21 ],\n            16: [ 2, 21 ],\n            19: [ 2, 21 ],\n            20: [ 2, 21 ],\n            22: [ 2, 21 ],\n            23: [ 2, 21 ],\n            24: [ 2, 21 ]\n        }, {\n            18: [ 1, 64 ]\n        }, {\n            18: [ 2, 24 ]\n        }, {\n            18: [ 2, 29 ],\n            28: [ 2, 29 ],\n            30: [ 2, 29 ],\n            31: [ 2, 29 ],\n            32: [ 2, 29 ],\n            35: [ 2, 29 ]\n        }, {\n            18: [ 2, 37 ],\n            35: [ 2, 37 ]\n        }, {\n            36: [ 1, 61 ]\n        }, {\n            21: 65,\n            28: [ 1, 69 ],\n            30: [ 1, 66 ],\n            31: [ 1, 67 ],\n            32: [ 1, 68 ],\n            35: [ 1, 27 ],\n            38: 26\n        }, {\n            18: [ 2, 46 ],\n            28: [ 2, 46 ],\n            30: [ 2, 46 ],\n            31: [ 2, 46 ],\n            32: [ 2, 46 ],\n            35: [ 2, 46 ],\n            39: [ 2, 46 ]\n        }, {\n            18: [ 1, 70 ]\n        }, {\n            5: [ 2, 22 ],\n            14: [ 2, 22 ],\n            15: [ 2, 22 ],\n            16: [ 2, 22 ],\n            19: [ 2, 22 ],\n            20: [ 2, 22 ],\n            22: [ 2, 22 ],\n            23: [ 2, 22 ],\n            24: [ 2, 22 ]\n        }, {\n            18: [ 2, 39 ],\n            35: [ 2, 39 ]\n        }, {\n            18: [ 2, 40 ],\n            35: [ 2, 40 ]\n        }, {\n            18: [ 2, 41 ],\n            35: [ 2, 41 ]\n        }, {\n            18: [ 2, 42 ],\n            35: [ 2, 42 ]\n        }, {\n            18: [ 2, 43 ],\n            35: [ 2, 43 ]\n        }, {\n            5: [ 2, 18 ],\n            14: [ 2, 18 ],\n            15: [ 2, 18 ],\n            16: [ 2, 18 ],\n            19: [ 2, 18 ],\n            20: [ 2, 18 ],\n            22: [ 2, 18 ],\n            23: [ 2, 18 ],\n            24: [ 2, 18 ]\n        } ],\n        defaultActions: {\n            17: [ 2, 1 ],\n            25: [ 2, 28 ],\n            38: [ 2, 26 ],\n            57: [ 2, 24 ]\n        },\n        parseError: function(str) {\n            throw Error(str);\n        },\n        parse: function(input) {\n            function lex() {\n                var token;\n                return token = self.lexer.lex() || 1, \"number\" != typeof token && (token = self.symbols_[token] || token), \n                token;\n            }\n            var self = this, stack = [ 0 ], vstack = [ null ], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0;\n            this.lexer.setInput(input), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, \n            this.yy.parser = this, this.lexer.yylloc === void 0 && (this.lexer.yylloc = {});\n            var yyloc = this.lexer.yylloc;\n            lstack.push(yyloc);\n            var ranges = this.lexer.options && this.lexer.options.ranges;\n            \"function\" == typeof this.yy.parseError && (this.parseError = this.yy.parseError);\n            for (var symbol, preErrorSymbol, state, action, r, p, len, newState, expected, yyval = {}; ;) {\n                if (state = stack[stack.length - 1], this.defaultActions[state] ? action = this.defaultActions[state] : ((null === symbol || symbol === void 0) && (symbol = lex()), \n                action = table[state] && table[state][symbol]), action === void 0 || !action.length || !action[0]) {\n                    var errStr = \"\";\n                    if (!recovering) {\n                        expected = [];\n                        for (p in table[state]) this.terminals_[p] && p > 2 && expected.push(\"'\" + this.terminals_[p] + \"'\");\n                        errStr = this.lexer.showPosition ? \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\" : \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (1 == symbol ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\"), \n                        this.parseError(errStr, {\n                            text: this.lexer.match,\n                            token: this.terminals_[symbol] || symbol,\n                            line: this.lexer.yylineno,\n                            loc: yyloc,\n                            expected: expected\n                        });\n                    }\n                }\n                if (action[0] instanceof Array && action.length > 1) throw Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n                switch (action[0]) {\n                  case 1:\n                    stack.push(symbol), vstack.push(this.lexer.yytext), lstack.push(this.lexer.yylloc), \n                    stack.push(action[1]), symbol = null, preErrorSymbol ? (symbol = preErrorSymbol, \n                    preErrorSymbol = null) : (yyleng = this.lexer.yyleng, yytext = this.lexer.yytext, \n                    yylineno = this.lexer.yylineno, yyloc = this.lexer.yylloc, recovering > 0 && recovering--);\n                    break;\n\n                  case 2:\n                    if (len = this.productions_[action[1]][1], yyval.$ = vstack[vstack.length - len], \n                    yyval._$ = {\n                        first_line: lstack[lstack.length - (len || 1)].first_line,\n                        last_line: lstack[lstack.length - 1].last_line,\n                        first_column: lstack[lstack.length - (len || 1)].first_column,\n                        last_column: lstack[lstack.length - 1].last_column\n                    }, ranges && (yyval._$.range = [ lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1] ]), \n                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack), \n                    r !== void 0) return r;\n                    len && (stack = stack.slice(0, 2 * -1 * len), vstack = vstack.slice(0, -1 * len), \n                    lstack = lstack.slice(0, -1 * len)), stack.push(this.productions_[action[1]][0]), \n                    vstack.push(yyval.$), lstack.push(yyval._$), newState = table[stack[stack.length - 2]][stack[stack.length - 1]], \n                    stack.push(newState);\n                    break;\n\n                  case 3:\n                    return !0;\n                }\n            }\n            return !0;\n        }\n    }, lexer = function() {\n        var lexer = {\n            EOF: 1,\n            parseError: function(str, hash) {\n                if (!this.yy.parser) throw Error(str);\n                this.yy.parser.parseError(str, hash);\n            },\n            setInput: function(input) {\n                return this._input = input, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, \n                this.yytext = this.matched = this.match = \"\", this.conditionStack = [ \"INITIAL\" ], \n                this.yylloc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0\n                }, this.options.ranges && (this.yylloc.range = [ 0, 0 ]), this.offset = 0, this;\n            },\n            input: function() {\n                var ch = this._input[0];\n                this.yytext += ch, this.yyleng++, this.offset++, this.match += ch, this.matched += ch;\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n                return lines ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, \n                this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), \n                ch;\n            },\n            unput: function(ch) {\n                var len = ch.length, lines = ch.split(/(?:\\r\\n?|\\n)/g);\n                this._input = ch + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - len - 1), \n                this.offset -= len;\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n                this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), \n                lines.length - 1 && (this.yylineno -= lines.length - 1);\n                var r = this.yylloc.range;\n                return this.yylloc = {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.first_column,\n                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n                }, this.options.ranges && (this.yylloc.range = [ r[0], r[0] + this.yyleng - len ]), \n                this;\n            },\n            more: function() {\n                return this._more = !0, this;\n            },\n            less: function(n) {\n                this.unput(this.match.slice(n));\n            },\n            pastInput: function() {\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\n                return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n            },\n            upcomingInput: function() {\n                var next = this.match;\n                return 20 > next.length && (next += this._input.substr(0, 20 - next.length)), (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n            },\n            showPosition: function() {\n                var pre = this.pastInput(), c = Array(pre.length + 1).join(\"-\");\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n            },\n            next: function() {\n                if (this.done) return this.EOF;\n                this._input || (this.done = !0);\n                var token, match, tempMatch, index, lines;\n                this._more || (this.yytext = \"\", this.match = \"\");\n                for (var rules = this._currentRules(), i = 0; rules.length > i && (tempMatch = this._input.match(this.rules[rules[i]]), \n                !tempMatch || match && !(tempMatch[0].length > match[0].length) || (match = tempMatch, \n                index = i, this.options.flex)); i++) ;\n                return match ? (lines = match[0].match(/(?:\\r\\n?|\\n).*/g), lines && (this.yylineno += lines.length), \n                this.yylloc = {\n                    first_line: this.yylloc.last_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.last_column,\n                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n                }, this.yytext += match[0], this.match += match[0], this.matches = match, this.yyleng = this.yytext.length, \n                this.options.ranges && (this.yylloc.range = [ this.offset, this.offset += this.yyleng ]), \n                this._more = !1, this._input = this._input.slice(match[0].length), this.matched += match[0], \n                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]), \n                this.done && this._input && (this.done = !1), token ? token : void 0) : \"\" === this._input ? this.EOF : this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n                    text: \"\",\n                    token: null,\n                    line: this.yylineno\n                });\n            },\n            lex: function() {\n                var r = this.next();\n                return r !== void 0 ? r : this.lex();\n            },\n            begin: function(condition) {\n                this.conditionStack.push(condition);\n            },\n            popState: function() {\n                return this.conditionStack.pop();\n            },\n            _currentRules: function() {\n                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n            },\n            topState: function() {\n                return this.conditionStack[this.conditionStack.length - 2];\n            },\n            pushState: function(condition) {\n                this.begin(condition);\n            }\n        };\n        return lexer.options = {}, lexer.performAction = function(yy, yy_, $avoiding_name_collisions, YY_START) {\n            switch ($avoiding_name_collisions) {\n              case 0:\n                if (\"\\\\\" !== yy_.yytext.slice(-1) && this.begin(\"mu\"), \"\\\\\" === yy_.yytext.slice(-1) && (yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1), \n                this.begin(\"emu\")), yy_.yytext) return 14;\n                break;\n\n              case 1:\n                return 14;\n\n              case 2:\n                return \"\\\\\" !== yy_.yytext.slice(-1) && this.popState(), \"\\\\\" === yy_.yytext.slice(-1) && (yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1)), \n                14;\n\n              case 3:\n                return yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 4), this.popState(), 15;\n\n              case 4:\n                return this.begin(\"par\"), 24;\n\n              case 5:\n                return 16;\n\n              case 6:\n                return 20;\n\n              case 7:\n                return 19;\n\n              case 8:\n                return 19;\n\n              case 9:\n                return 23;\n\n              case 10:\n                return 23;\n\n              case 11:\n                this.popState(), this.begin(\"com\");\n                break;\n\n              case 12:\n                return yy_.yytext = yy_.yytext.substr(3, yy_.yyleng - 5), this.popState(), 15;\n\n              case 13:\n                return 22;\n\n              case 14:\n                return 36;\n\n              case 15:\n                return 35;\n\n              case 16:\n                return 35;\n\n              case 17:\n                return 39;\n\n              case 18:\n                break;\n\n              case 19:\n                return this.popState(), 18;\n\n              case 20:\n                return this.popState(), 18;\n\n              case 21:\n                return yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\\\\"/g, '\"'), 30;\n\n              case 22:\n                return yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\\\'/g, \"'\"), 30;\n\n              case 23:\n                return yy_.yytext = yy_.yytext.substr(1), 28;\n\n              case 24:\n                return 32;\n\n              case 25:\n                return 32;\n\n              case 26:\n                return 31;\n\n              case 27:\n                return 35;\n\n              case 28:\n                return yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2), 35;\n\n              case 29:\n                return \"INVALID\";\n\n              case 30:\n                break;\n\n              case 31:\n                return this.popState(), 37;\n\n              case 32:\n                return 5;\n            }\n        }, lexer.rules = [ /^(?:[^\\x00]*?(?=(\\{\\{)))/, /^(?:[^\\x00]+)/, /^(?:[^\\x00]{2,}?(?=(\\{\\{|$)))/, /^(?:[\\s\\S]*?--\\}\\})/, /^(?:\\{\\{>)/, /^(?:\\{\\{#)/, /^(?:\\{\\{\\/)/, /^(?:\\{\\{\\^)/, /^(?:\\{\\{\\s*else\\b)/, /^(?:\\{\\{\\{)/, /^(?:\\{\\{&)/, /^(?:\\{\\{!--)/, /^(?:\\{\\{![\\s\\S]*?\\}\\})/, /^(?:\\{\\{)/, /^(?:=)/, /^(?:\\.(?=[} ]))/, /^(?:\\.\\.)/, /^(?:[\\/.])/, /^(?:\\s+)/, /^(?:\\}\\}\\})/, /^(?:\\}\\})/, /^(?:\"(\\\\[\"]|[^\"])*\")/, /^(?:'(\\\\[']|[^'])*')/, /^(?:@[a-zA-Z]+)/, /^(?:true(?=[}\\s]))/, /^(?:false(?=[}\\s]))/, /^(?:[0-9]+(?=[}\\s]))/, /^(?:[a-zA-Z0-9_$-]+(?=[=}\\s\\/.]))/, /^(?:\\[[^\\]]*\\])/, /^(?:.)/, /^(?:\\s+)/, /^(?:[a-zA-Z0-9_$-/]+)/, /^(?:$)/ ], \n        lexer.conditions = {\n            mu: {\n                rules: [ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32 ],\n                inclusive: !1\n            },\n            emu: {\n                rules: [ 2 ],\n                inclusive: !1\n            },\n            com: {\n                rules: [ 3 ],\n                inclusive: !1\n            },\n            par: {\n                rules: [ 30, 31 ],\n                inclusive: !1\n            },\n            INITIAL: {\n                rules: [ 0, 1, 32 ],\n                inclusive: !0\n            }\n        }, lexer;\n    }();\n    return parser.lexer = lexer, Parser.prototype = parser, parser.Parser = Parser, \n    new Parser();\n}();\n\nHandlebars.Parser = handlebars, Handlebars.parse = function(input) {\n    return input.constructor === Handlebars.AST.ProgramNode ? input : (Handlebars.Parser.yy = Handlebars.AST, \n    Handlebars.Parser.parse(input));\n}, Handlebars.print = function(ast) {\n    return new Handlebars.PrintVisitor().accept(ast);\n}, function() {\n    Handlebars.AST = {}, Handlebars.AST.ProgramNode = function(statements, inverse) {\n        this.type = \"program\", this.statements = statements, inverse && (this.inverse = new Handlebars.AST.ProgramNode(inverse));\n    }, Handlebars.AST.MustacheNode = function(rawParams, hash, unescaped) {\n        this.type = \"mustache\", this.escaped = !unescaped, this.hash = hash;\n        var id = this.id = rawParams[0], params = this.params = rawParams.slice(1), eligibleHelper = this.eligibleHelper = id.isSimple;\n        this.isHelper = eligibleHelper && (params.length || hash);\n    }, Handlebars.AST.PartialNode = function(partialName, context) {\n        this.type = \"partial\", this.partialName = partialName, this.context = context;\n    };\n    var verifyMatch = function(open, close) {\n        if (open.original !== close.original) throw new Handlebars.Exception(open.original + \" doesn't match \" + close.original);\n    };\n    Handlebars.AST.BlockNode = function(mustache, program, inverse, close) {\n        verifyMatch(mustache.id, close), this.type = \"block\", this.mustache = mustache, \n        this.program = program, this.inverse = inverse, this.inverse && !this.program && (this.isInverse = !0);\n    }, Handlebars.AST.ContentNode = function(string) {\n        this.type = \"content\", this.string = string;\n    }, Handlebars.AST.HashNode = function(pairs) {\n        this.type = \"hash\", this.pairs = pairs;\n    }, Handlebars.AST.IdNode = function(parts) {\n        this.type = \"ID\", this.original = parts.join(\".\");\n        for (var dig = [], depth = 0, i = 0, l = parts.length; l > i; i++) {\n            var part = parts[i];\n            if (\"..\" === part || \".\" === part || \"this\" === part) {\n                if (dig.length > 0) throw new Handlebars.Exception(\"Invalid path: \" + this.original);\n                \"..\" === part ? depth++ : this.isScoped = !0;\n            } else dig.push(part);\n        }\n        this.parts = dig, this.string = dig.join(\".\"), this.depth = depth, this.isSimple = 1 === parts.length && !this.isScoped && 0 === depth, \n        this.stringModeValue = this.string;\n    }, Handlebars.AST.PartialNameNode = function(name) {\n        this.type = \"PARTIAL_NAME\", this.name = name;\n    }, Handlebars.AST.DataNode = function(id) {\n        this.type = \"DATA\", this.id = id;\n    }, Handlebars.AST.StringNode = function(string) {\n        this.type = \"STRING\", this.string = string, this.stringModeValue = string;\n    }, Handlebars.AST.IntegerNode = function(integer) {\n        this.type = \"INTEGER\", this.integer = integer, this.stringModeValue = Number(integer);\n    }, Handlebars.AST.BooleanNode = function(bool) {\n        this.type = \"BOOLEAN\", this.bool = bool, this.stringModeValue = \"true\" === bool;\n    }, Handlebars.AST.CommentNode = function(comment) {\n        this.type = \"comment\", this.comment = comment;\n    };\n}();\n\nvar errorProps = [ \"description\", \"fileName\", \"lineNumber\", \"message\", \"name\", \"number\", \"stack\" ];\n\nHandlebars.Exception = function() {\n    for (var tmp = Error.prototype.constructor.apply(this, arguments), idx = 0; errorProps.length > idx; idx++) this[errorProps[idx]] = tmp[errorProps[idx]];\n}, Handlebars.Exception.prototype = Error(), Handlebars.SafeString = function(string) {\n    this.string = string;\n}, Handlebars.SafeString.prototype.toString = function() {\n    return \"\" + this.string;\n}, function() {\n    var escape = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#x27;\",\n        \"`\": \"&#x60;\"\n    }, badChars = /[&<>\"'`]/g, possible = /[&<>\"'`]/, escapeChar = function(chr) {\n        return escape[chr] || \"&amp;\";\n    };\n    Handlebars.Utils = {\n        escapeExpression: function(string) {\n            return string instanceof Handlebars.SafeString ? \"\" + string : null == string || string === !1 ? \"\" : possible.test(string) ? string.replace(badChars, escapeChar) : string;\n        },\n        isEmpty: function(value) {\n            return value || 0 === value ? \"[object Array]\" === Object.prototype.toString.call(value) && 0 === value.length ? !0 : !1 : !0;\n        }\n    };\n}(), Handlebars.Compiler = function() {}, Handlebars.JavaScriptCompiler = function() {}, \nfunction(Compiler, JavaScriptCompiler) {\n    Compiler.prototype = {\n        compiler: Compiler,\n        disassemble: function() {\n            for (var opcode, params, param, opcodes = this.opcodes, out = [], i = 0, l = opcodes.length; l > i; i++) if (opcode = opcodes[i], \n            \"DECLARE\" === opcode.opcode) out.push(\"DECLARE \" + opcode.name + \"=\" + opcode.value); else {\n                params = [];\n                for (var j = 0; opcode.args.length > j; j++) param = opcode.args[j], \"string\" == typeof param && (param = '\"' + param.replace(\"\\n\", \"\\\\n\") + '\"'), \n                params.push(param);\n                out.push(opcode.opcode + \" \" + params.join(\" \"));\n            }\n            return out.join(\"\\n\");\n        },\n        equals: function(other) {\n            var len = this.opcodes.length;\n            if (other.opcodes.length !== len) return !1;\n            for (var i = 0; len > i; i++) {\n                var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];\n                if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) return !1;\n                for (var j = 0; opcode.args.length > j; j++) if (opcode.args[j] !== otherOpcode.args[j]) return !1;\n            }\n            return !0;\n        },\n        guid: 0,\n        compile: function(program, options) {\n            this.children = [], this.depths = {\n                list: []\n            }, this.options = options;\n            var knownHelpers = this.options.knownHelpers;\n            if (this.options.knownHelpers = {\n                helperMissing: !0,\n                blockHelperMissing: !0,\n                each: !0,\n                \"if\": !0,\n                unless: !0,\n                \"with\": !0,\n                log: !0\n            }, knownHelpers) for (var name in knownHelpers) this.options.knownHelpers[name] = knownHelpers[name];\n            return this.program(program);\n        },\n        accept: function(node) {\n            return this[node.type](node);\n        },\n        program: function(program) {\n            var statement, statements = program.statements;\n            this.opcodes = [];\n            for (var i = 0, l = statements.length; l > i; i++) statement = statements[i], this[statement.type](statement);\n            return this.isSimple = 1 === l, this.depths.list = this.depths.list.sort(function(a, b) {\n                return a - b;\n            }), this;\n        },\n        compileProgram: function(program) {\n            var depth, result = new this.compiler().compile(program, this.options), guid = this.guid++;\n            this.usePartial = this.usePartial || result.usePartial, this.children[guid] = result;\n            for (var i = 0, l = result.depths.list.length; l > i; i++) depth = result.depths.list[i], \n            2 > depth || this.addDepth(depth - 1);\n            return guid;\n        },\n        block: function(block) {\n            var mustache = block.mustache, program = block.program, inverse = block.inverse;\n            program && (program = this.compileProgram(program)), inverse && (inverse = this.compileProgram(inverse));\n            var type = this.classifyMustache(mustache);\n            \"helper\" === type ? this.helperMustache(mustache, program, inverse) : \"simple\" === type ? (this.simpleMustache(mustache), \n            this.opcode(\"pushProgram\", program), this.opcode(\"pushProgram\", inverse), this.opcode(\"emptyHash\"), \n            this.opcode(\"blockValue\")) : (this.ambiguousMustache(mustache, program, inverse), \n            this.opcode(\"pushProgram\", program), this.opcode(\"pushProgram\", inverse), this.opcode(\"emptyHash\"), \n            this.opcode(\"ambiguousBlockValue\")), this.opcode(\"append\");\n        },\n        hash: function(hash) {\n            var pair, val, pairs = hash.pairs;\n            this.opcode(\"pushHash\");\n            for (var i = 0, l = pairs.length; l > i; i++) pair = pairs[i], val = pair[1], this.options.stringParams ? this.opcode(\"pushStringParam\", val.stringModeValue, val.type) : this.accept(val), \n            this.opcode(\"assignToHash\", pair[0]);\n            this.opcode(\"popHash\");\n        },\n        partial: function(partial) {\n            var partialName = partial.partialName;\n            this.usePartial = !0, partial.context ? this.ID(partial.context) : this.opcode(\"push\", \"depth0\"), \n            this.opcode(\"invokePartial\", partialName.name), this.opcode(\"append\");\n        },\n        content: function(content) {\n            this.opcode(\"appendContent\", content.string);\n        },\n        mustache: function(mustache) {\n            var options = this.options, type = this.classifyMustache(mustache);\n            \"simple\" === type ? this.simpleMustache(mustache) : \"helper\" === type ? this.helperMustache(mustache) : this.ambiguousMustache(mustache), \n            mustache.escaped && !options.noEscape ? this.opcode(\"appendEscaped\") : this.opcode(\"append\");\n        },\n        ambiguousMustache: function(mustache, program, inverse) {\n            var id = mustache.id, name = id.parts[0], isBlock = null != program || null != inverse;\n            this.opcode(\"getContext\", id.depth), this.opcode(\"pushProgram\", program), this.opcode(\"pushProgram\", inverse), \n            this.opcode(\"invokeAmbiguous\", name, isBlock);\n        },\n        simpleMustache: function(mustache) {\n            var id = mustache.id;\n            \"DATA\" === id.type ? this.DATA(id) : id.parts.length ? this.ID(id) : (this.addDepth(id.depth), \n            this.opcode(\"getContext\", id.depth), this.opcode(\"pushContext\")), this.opcode(\"resolvePossibleLambda\");\n        },\n        helperMustache: function(mustache, program, inverse) {\n            var params = this.setupFullMustacheParams(mustache, program, inverse), name = mustache.id.parts[0];\n            if (this.options.knownHelpers[name]) this.opcode(\"invokeKnownHelper\", params.length, name); else {\n                if (this.knownHelpersOnly) throw Error(\"You specified knownHelpersOnly, but used the unknown helper \" + name);\n                this.opcode(\"invokeHelper\", params.length, name);\n            }\n        },\n        ID: function(id) {\n            this.addDepth(id.depth), this.opcode(\"getContext\", id.depth);\n            var name = id.parts[0];\n            name ? this.opcode(\"lookupOnContext\", id.parts[0]) : this.opcode(\"pushContext\");\n            for (var i = 1, l = id.parts.length; l > i; i++) this.opcode(\"lookup\", id.parts[i]);\n        },\n        DATA: function(data) {\n            this.options.data = !0, this.opcode(\"lookupData\", data.id);\n        },\n        STRING: function(string) {\n            this.opcode(\"pushString\", string.string);\n        },\n        INTEGER: function(integer) {\n            this.opcode(\"pushLiteral\", integer.integer);\n        },\n        BOOLEAN: function(bool) {\n            this.opcode(\"pushLiteral\", bool.bool);\n        },\n        comment: function() {},\n        opcode: function(name) {\n            this.opcodes.push({\n                opcode: name,\n                args: [].slice.call(arguments, 1)\n            });\n        },\n        declare: function(name, value) {\n            this.opcodes.push({\n                opcode: \"DECLARE\",\n                name: name,\n                value: value\n            });\n        },\n        addDepth: function(depth) {\n            if (isNaN(depth)) throw Error(\"EWOT\");\n            0 !== depth && (this.depths[depth] || (this.depths[depth] = !0, this.depths.list.push(depth)));\n        },\n        classifyMustache: function(mustache) {\n            var isHelper = mustache.isHelper, isEligible = mustache.eligibleHelper, options = this.options;\n            if (isEligible && !isHelper) {\n                var name = mustache.id.parts[0];\n                options.knownHelpers[name] ? isHelper = !0 : options.knownHelpersOnly && (isEligible = !1);\n            }\n            return isHelper ? \"helper\" : isEligible ? \"ambiguous\" : \"simple\";\n        },\n        pushParams: function(params) {\n            for (var param, i = params.length; i--; ) param = params[i], this.options.stringParams ? (param.depth && this.addDepth(param.depth), \n            this.opcode(\"getContext\", param.depth || 0), this.opcode(\"pushStringParam\", param.stringModeValue, param.type)) : this[param.type](param);\n        },\n        setupMustacheParams: function(mustache) {\n            var params = mustache.params;\n            return this.pushParams(params), mustache.hash ? this.hash(mustache.hash) : this.opcode(\"emptyHash\"), \n            params;\n        },\n        setupFullMustacheParams: function(mustache, program, inverse) {\n            var params = mustache.params;\n            return this.pushParams(params), this.opcode(\"pushProgram\", program), this.opcode(\"pushProgram\", inverse), \n            mustache.hash ? this.hash(mustache.hash) : this.opcode(\"emptyHash\"), params;\n        }\n    };\n    var Literal = function(value) {\n        this.value = value;\n    };\n    JavaScriptCompiler.prototype = {\n        nameLookup: function(parent, name) {\n            return /^[0-9]+$/.test(name) ? parent + \"[\" + name + \"]\" : JavaScriptCompiler.isValidJavaScriptVariableName(name) ? parent + \".\" + name : parent + \"['\" + name + \"']\";\n        },\n        appendToBuffer: function(string) {\n            return this.environment.isSimple ? \"return \" + string + \";\" : {\n                appendToBuffer: !0,\n                content: string,\n                toString: function() {\n                    return \"buffer += \" + string + \";\";\n                }\n            };\n        },\n        initializeBuffer: function() {\n            return this.quotedString(\"\");\n        },\n        namespace: \"Handlebars\",\n        compile: function(environment, options, context, asObject) {\n            this.environment = environment, this.options = options || {}, Handlebars.log(Handlebars.logger.DEBUG, this.environment.disassemble() + \"\\n\\n\"), \n            this.name = this.environment.name, this.isChild = !!context, this.context = context || {\n                programs: [],\n                environments: [],\n                aliases: {}\n            }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.registers = {\n                list: []\n            }, this.compileStack = [], this.inlineStack = [], this.compileChildren(environment, options);\n            var opcode, opcodes = environment.opcodes;\n            for (this.i = 0, l = opcodes.length; l > this.i; this.i++) opcode = opcodes[this.i], \n            \"DECLARE\" === opcode.opcode ? this[opcode.name] = opcode.value : this[opcode.opcode].apply(this, opcode.args);\n            return this.createFunctionContext(asObject);\n        },\n        nextOpcode: function() {\n            var opcodes = this.environment.opcodes;\n            return opcodes[this.i + 1];\n        },\n        eat: function() {\n            this.i = this.i + 1;\n        },\n        preamble: function() {\n            var out = [];\n            if (this.isChild) out.push(\"\"); else {\n                var namespace = this.namespace, copies = \"helpers = helpers || \" + namespace + \".helpers;\";\n                this.environment.usePartial && (copies = copies + \" partials = partials || \" + namespace + \".partials;\"), \n                this.options.data && (copies += \" data = data || {};\"), out.push(copies);\n            }\n            this.environment.isSimple ? out.push(\"\") : out.push(\", buffer = \" + this.initializeBuffer()), \n            this.lastContext = 0, this.source = out;\n        },\n        createFunctionContext: function(asObject) {\n            var locals = this.stackVars.concat(this.registers.list);\n            if (locals.length > 0 && (this.source[1] = this.source[1] + \", \" + locals.join(\", \")), \n            !this.isChild) for (var alias in this.context.aliases) this.source[1] = this.source[1] + \", \" + alias + \"=\" + this.context.aliases[alias];\n            this.source[1] && (this.source[1] = \"var \" + this.source[1].substring(2) + \";\"), \n            this.isChild || (this.source[1] += \"\\n\" + this.context.programs.join(\"\\n\") + \"\\n\"), \n            this.environment.isSimple || this.source.push(\"return buffer;\");\n            for (var params = this.isChild ? [ \"depth0\", \"data\" ] : [ \"Handlebars\", \"depth0\", \"helpers\", \"partials\", \"data\" ], i = 0, l = this.environment.depths.list.length; l > i; i++) params.push(\"depth\" + this.environment.depths.list[i]);\n            var source = this.mergeSource();\n            if (!this.isChild) {\n                var revision = Handlebars.COMPILER_REVISION, versions = Handlebars.REVISION_CHANGES[revision];\n                source = \"this.compilerInfo = [\" + revision + \",'\" + versions + \"'];\\n\" + source;\n            }\n            if (asObject) return params.push(source), Function.apply(this, params);\n            var functionSource = \"function \" + (this.name || \"\") + \"(\" + params.join(\",\") + \") {\\n  \" + source + \"}\";\n            return Handlebars.log(Handlebars.logger.DEBUG, functionSource + \"\\n\\n\"), functionSource;\n        },\n        mergeSource: function() {\n            for (var buffer, source = \"\", i = 0, len = this.source.length; len > i; i++) {\n                var line = this.source[i];\n                line.appendToBuffer ? buffer = buffer ? buffer + \"\\n    + \" + line.content : line.content : (buffer && (source += \"buffer += \" + buffer + \";\\n  \", \n                buffer = void 0), source += line + \"\\n  \");\n            }\n            return source;\n        },\n        blockValue: function() {\n            this.context.aliases.blockHelperMissing = \"helpers.blockHelperMissing\";\n            var params = [ \"depth0\" ];\n            this.setupParams(0, params), this.replaceStack(function(current) {\n                return params.splice(1, 0, current), \"blockHelperMissing.call(\" + params.join(\", \") + \")\";\n            });\n        },\n        ambiguousBlockValue: function() {\n            this.context.aliases.blockHelperMissing = \"helpers.blockHelperMissing\";\n            var params = [ \"depth0\" ];\n            this.setupParams(0, params);\n            var current = this.topStack();\n            params.splice(1, 0, current), params[params.length - 1] = \"options\", this.source.push(\"if (!\" + this.lastHelper + \") { \" + current + \" = blockHelperMissing.call(\" + params.join(\", \") + \"); }\");\n        },\n        appendContent: function(content) {\n            this.source.push(this.appendToBuffer(this.quotedString(content)));\n        },\n        append: function() {\n            this.flushInline();\n            var local = this.popStack();\n            this.source.push(\"if(\" + local + \" || \" + local + \" === 0) { \" + this.appendToBuffer(local) + \" }\"), \n            this.environment.isSimple && this.source.push(\"else { \" + this.appendToBuffer(\"''\") + \" }\");\n        },\n        appendEscaped: function() {\n            this.context.aliases.escapeExpression = \"this.escapeExpression\", this.source.push(this.appendToBuffer(\"escapeExpression(\" + this.popStack() + \")\"));\n        },\n        getContext: function(depth) {\n            this.lastContext !== depth && (this.lastContext = depth);\n        },\n        lookupOnContext: function(name) {\n            this.push(this.nameLookup(\"depth\" + this.lastContext, name, \"context\"));\n        },\n        pushContext: function() {\n            this.pushStackLiteral(\"depth\" + this.lastContext);\n        },\n        resolvePossibleLambda: function() {\n            this.context.aliases.functionType = '\"function\"', this.replaceStack(function(current) {\n                return \"typeof \" + current + \" === functionType ? \" + current + \".apply(depth0) : \" + current;\n            });\n        },\n        lookup: function(name) {\n            this.replaceStack(function(current) {\n                return current + \" == null || \" + current + \" === false ? \" + current + \" : \" + this.nameLookup(current, name, \"context\");\n            });\n        },\n        lookupData: function(id) {\n            this.push(this.nameLookup(\"data\", id, \"data\"));\n        },\n        pushStringParam: function(string, type) {\n            this.pushStackLiteral(\"depth\" + this.lastContext), this.pushString(type), \"string\" == typeof string ? this.pushString(string) : this.pushStackLiteral(string);\n        },\n        emptyHash: function() {\n            this.pushStackLiteral(\"{}\"), this.options.stringParams && this.register(\"hashTypes\", \"{}\");\n        },\n        pushHash: function() {\n            this.hash = {\n                values: [],\n                types: []\n            };\n        },\n        popHash: function() {\n            var hash = this.hash;\n            this.hash = void 0, this.options.stringParams && this.register(\"hashTypes\", \"{\" + hash.types.join(\",\") + \"}\"), \n            this.push(\"{\\n    \" + hash.values.join(\",\\n    \") + \"\\n  }\");\n        },\n        pushString: function(string) {\n            this.pushStackLiteral(this.quotedString(string));\n        },\n        push: function(expr) {\n            return this.inlineStack.push(expr), expr;\n        },\n        pushLiteral: function(value) {\n            this.pushStackLiteral(value);\n        },\n        pushProgram: function(guid) {\n            null != guid ? this.pushStackLiteral(this.programExpression(guid)) : this.pushStackLiteral(null);\n        },\n        invokeHelper: function(paramSize, name) {\n            this.context.aliases.helperMissing = \"helpers.helperMissing\";\n            var helper = this.lastHelper = this.setupHelper(paramSize, name, !0);\n            this.push(helper.name), this.replaceStack(function(name) {\n                return name + \" ? \" + name + \".call(\" + helper.callParams + \") \" + \": helperMissing.call(\" + helper.helperMissingParams + \")\";\n            });\n        },\n        invokeKnownHelper: function(paramSize, name) {\n            var helper = this.setupHelper(paramSize, name);\n            this.push(helper.name + \".call(\" + helper.callParams + \")\");\n        },\n        invokeAmbiguous: function(name, helperCall) {\n            this.context.aliases.functionType = '\"function\"', this.pushStackLiteral(\"{}\");\n            var helper = this.setupHelper(0, name, helperCall), helperName = this.lastHelper = this.nameLookup(\"helpers\", name, \"helper\"), nonHelper = this.nameLookup(\"depth\" + this.lastContext, name, \"context\"), nextStack = this.nextStack();\n            this.source.push(\"if (\" + nextStack + \" = \" + helperName + \") { \" + nextStack + \" = \" + nextStack + \".call(\" + helper.callParams + \"); }\"), \n            this.source.push(\"else { \" + nextStack + \" = \" + nonHelper + \"; \" + nextStack + \" = typeof \" + nextStack + \" === functionType ? \" + nextStack + \".apply(depth0) : \" + nextStack + \"; }\");\n        },\n        invokePartial: function(name) {\n            var params = [ this.nameLookup(\"partials\", name, \"partial\"), \"'\" + name + \"'\", this.popStack(), \"helpers\", \"partials\" ];\n            this.options.data && params.push(\"data\"), this.context.aliases.self = \"this\", this.push(\"self.invokePartial(\" + params.join(\", \") + \")\");\n        },\n        assignToHash: function(key) {\n            var type, value = this.popStack();\n            this.options.stringParams && (type = this.popStack(), this.popStack());\n            var hash = this.hash;\n            type && hash.types.push(\"'\" + key + \"': \" + type), hash.values.push(\"'\" + key + \"': (\" + value + \")\");\n        },\n        compiler: JavaScriptCompiler,\n        compileChildren: function(environment, options) {\n            for (var child, compiler, children = environment.children, i = 0, l = children.length; l > i; i++) {\n                child = children[i], compiler = new this.compiler();\n                var index = this.matchExistingProgram(child);\n                null == index ? (this.context.programs.push(\"\"), index = this.context.programs.length, \n                child.index = index, child.name = \"program\" + index, this.context.programs[index] = compiler.compile(child, options, this.context), \n                this.context.environments[index] = child) : (child.index = index, child.name = \"program\" + index);\n            }\n        },\n        matchExistingProgram: function(child) {\n            for (var i = 0, len = this.context.environments.length; len > i; i++) {\n                var environment = this.context.environments[i];\n                if (environment && environment.equals(child)) return i;\n            }\n        },\n        programExpression: function(guid) {\n            if (this.context.aliases.self = \"this\", null == guid) return \"self.noop\";\n            for (var depth, child = this.environment.children[guid], depths = child.depths.list, programParams = [ child.index, child.name, \"data\" ], i = 0, l = depths.length; l > i; i++) depth = depths[i], \n            1 === depth ? programParams.push(\"depth0\") : programParams.push(\"depth\" + (depth - 1));\n            return 0 === depths.length ? \"self.program(\" + programParams.join(\", \") + \")\" : (programParams.shift(), \n            \"self.programWithDepth(\" + programParams.join(\", \") + \")\");\n        },\n        register: function(name, val) {\n            this.useRegister(name), this.source.push(name + \" = \" + val + \";\");\n        },\n        useRegister: function(name) {\n            this.registers[name] || (this.registers[name] = !0, this.registers.list.push(name));\n        },\n        pushStackLiteral: function(item) {\n            return this.push(new Literal(item));\n        },\n        pushStack: function(item) {\n            this.flushInline();\n            var stack = this.incrStack();\n            return item && this.source.push(stack + \" = \" + item + \";\"), this.compileStack.push(stack), \n            stack;\n        },\n        replaceStack: function(callback) {\n            var stack, prefix = \"\", inline = this.isInline();\n            if (inline) {\n                var top = this.popStack(!0);\n                if (top instanceof Literal) stack = top.value; else {\n                    var name = this.stackSlot ? this.topStackName() : this.incrStack();\n                    prefix = \"(\" + this.push(name) + \" = \" + top + \"),\", stack = this.topStack();\n                }\n            } else stack = this.topStack();\n            var item = callback.call(this, stack);\n            return inline ? ((this.inlineStack.length || this.compileStack.length) && this.popStack(), \n            this.push(\"(\" + prefix + item + \")\")) : (/^stack/.test(stack) || (stack = this.nextStack()), \n            this.source.push(stack + \" = (\" + prefix + item + \");\")), stack;\n        },\n        nextStack: function() {\n            return this.pushStack();\n        },\n        incrStack: function() {\n            return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push(\"stack\" + this.stackSlot), \n            this.topStackName();\n        },\n        topStackName: function() {\n            return \"stack\" + this.stackSlot;\n        },\n        flushInline: function() {\n            var inlineStack = this.inlineStack;\n            if (inlineStack.length) {\n                this.inlineStack = [];\n                for (var i = 0, len = inlineStack.length; len > i; i++) {\n                    var entry = inlineStack[i];\n                    entry instanceof Literal ? this.compileStack.push(entry) : this.pushStack(entry);\n                }\n            }\n        },\n        isInline: function() {\n            return this.inlineStack.length;\n        },\n        popStack: function(wrapped) {\n            var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();\n            return !wrapped && item instanceof Literal ? item.value : (inline || this.stackSlot--, \n            item);\n        },\n        topStack: function(wrapped) {\n            var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];\n            return !wrapped && item instanceof Literal ? item.value : item;\n        },\n        quotedString: function(str) {\n            return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\") + '\"';\n        },\n        setupHelper: function(paramSize, name, missingParams) {\n            var params = [];\n            this.setupParams(paramSize, params, missingParams);\n            var foundHelper = this.nameLookup(\"helpers\", name, \"helper\");\n            return {\n                params: params,\n                name: foundHelper,\n                callParams: [ \"depth0\" ].concat(params).join(\", \"),\n                helperMissingParams: missingParams && [ \"depth0\", this.quotedString(name) ].concat(params).join(\", \")\n            };\n        },\n        setupParams: function(paramSize, params, useRegister) {\n            var param, inverse, program, options = [], contexts = [], types = [];\n            options.push(\"hash:\" + this.popStack()), inverse = this.popStack(), program = this.popStack(), \n            (program || inverse) && (program || (this.context.aliases.self = \"this\", program = \"self.noop\"), \n            inverse || (this.context.aliases.self = \"this\", inverse = \"self.noop\"), options.push(\"inverse:\" + inverse), \n            options.push(\"fn:\" + program));\n            for (var i = 0; paramSize > i; i++) param = this.popStack(), params.push(param), \n            this.options.stringParams && (types.push(this.popStack()), contexts.push(this.popStack()));\n            return this.options.stringParams && (options.push(\"contexts:[\" + contexts.join(\",\") + \"]\"), \n            options.push(\"types:[\" + types.join(\",\") + \"]\"), options.push(\"hashTypes:hashTypes\")), \n            this.options.data && options.push(\"data:data\"), options = \"{\" + options.join(\",\") + \"}\", \n            useRegister ? (this.register(\"options\", options), params.push(\"options\")) : params.push(options), \n            params.join(\", \");\n        }\n    };\n    for (var reservedWords = \"break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield\".split(\" \"), compilerWords = JavaScriptCompiler.RESERVED_WORDS = {}, i = 0, l = reservedWords.length; l > i; i++) compilerWords[reservedWords[i]] = !0;\n    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name) ? !0 : !1;\n    };\n}(Handlebars.Compiler, Handlebars.JavaScriptCompiler), Handlebars.precompile = function(input, options) {\n    if (!input || \"string\" != typeof input && input.constructor !== Handlebars.AST.ProgramNode) throw new Handlebars.Exception(\"You must pass a string or Handlebars AST to Handlebars.compile. You passed \" + input);\n    options = options || {}, \"data\" in options || (options.data = !0);\n    var ast = Handlebars.parse(input), environment = new Handlebars.Compiler().compile(ast, options);\n    return new Handlebars.JavaScriptCompiler().compile(environment, options);\n}, Handlebars.compile = function(input, options) {\n    function compile() {\n        var ast = Handlebars.parse(input), environment = new Handlebars.Compiler().compile(ast, options), templateSpec = new Handlebars.JavaScriptCompiler().compile(environment, options, void 0, !0);\n        return Handlebars.template(templateSpec);\n    }\n    if (!input || \"string\" != typeof input && input.constructor !== Handlebars.AST.ProgramNode) throw new Handlebars.Exception(\"You must pass a string or Handlebars AST to Handlebars.compile. You passed \" + input);\n    options = options || {}, \"data\" in options || (options.data = !0);\n    var compiled;\n    return function(context, options) {\n        return compiled || (compiled = compile()), compiled.call(this, context, options);\n    };\n}, Handlebars.VM = {\n    template: function(templateSpec) {\n        var container = {\n            escapeExpression: Handlebars.Utils.escapeExpression,\n            invokePartial: Handlebars.VM.invokePartial,\n            programs: [],\n            program: function(i, fn, data) {\n                var programWrapper = this.programs[i];\n                return data ? Handlebars.VM.program(fn, data) : programWrapper ? programWrapper : programWrapper = this.programs[i] = Handlebars.VM.program(fn);\n            },\n            programWithDepth: Handlebars.VM.programWithDepth,\n            noop: Handlebars.VM.noop,\n            compilerInfo: null\n        };\n        return function(context, options) {\n            options = options || {};\n            var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data), compilerInfo = container.compilerInfo || [], compilerRevision = compilerInfo[0] || 1, currentRevision = Handlebars.COMPILER_REVISION;\n            if (compilerRevision !== currentRevision) {\n                if (currentRevision > compilerRevision) {\n                    var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision], compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];\n                    throw \"Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (\" + runtimeVersions + \") or downgrade your runtime to an older version (\" + compilerVersions + \").\";\n                }\n                throw \"Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (\" + compilerInfo[1] + \").\";\n            }\n            return result;\n        };\n    },\n    programWithDepth: function(fn, data) {\n        var args = Array.prototype.slice.call(arguments, 2);\n        return function(context, options) {\n            return options = options || {}, fn.apply(this, [ context, options.data || data ].concat(args));\n        };\n    },\n    program: function(fn, data) {\n        return function(context, options) {\n            return options = options || {}, fn(context, options.data || data);\n        };\n    },\n    noop: function() {\n        return \"\";\n    },\n    invokePartial: function(partial, name, context, helpers, partials, data) {\n        var options = {\n            helpers: helpers,\n            partials: partials,\n            data: data\n        };\n        if (void 0 === partial) throw new Handlebars.Exception(\"The partial \" + name + \" could not be found\");\n        if (partial instanceof Function) return partial(context, options);\n        if (Handlebars.compile) return partials[name] = Handlebars.compile(partial, {\n            data: void 0 !== data\n        }), partials[name](context, options);\n        throw new Handlebars.Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    }\n}, Handlebars.template = Handlebars.VM.template;\n\nvar Functional = function(parent) {\n    var _ = parent._ = Function._ = {}, slice = Array.prototype.slice, _unshift = Array.prototype.unshift, unshift = function(xs, item) {\n        return _unshift.call(xs, item), xs;\n    }, toArray = function(x) {\n        return slice.call(x);\n    }, curry = function(fn) {\n        var args = slice.call(arguments, 1);\n        return composed = function() {\n            return fn.apply(this, args.concat(toArray(arguments)));\n        }, composed.curried = !0, composed;\n    }, autoCurry = function(fn, numArgs) {\n        return numArgs = numArgs || fn.length, composed = function() {\n            return numArgs > arguments.length ? numArgs - arguments.length > 0 ? autoCurry(curry.apply(this, unshift(toArray(arguments), fn)), numArgs - arguments.length) : curry.apply(this, unshift(toArray(arguments), fn)) : fn.apply(this, arguments);\n        }, composed.toString = function() {\n            return \"\" + fn;\n        }, composed.curried = !0, composed;\n    }, map = (function() {\n        Function.prototype.autoCurry = function(n) {\n            return autoCurry(this, n);\n        }, Function.prototype.curry = function() {\n            return curry.apply(this, unshift(toArray(arguments), this));\n        };\n    }(), function(fn, sequence) {\n        var i, length = sequence.length, result = Array(length);\n        for (fn = Function.toFunction(fn), i = 0; length > i; i++) result[i] = fn.apply(null, [ sequence[i], i ]);\n        return result;\n    }.autoCurry()), compose = function() {\n        var fns = map(Function.toFunction, arguments), arglen = fns.length;\n        return function() {\n            var i;\n            for (i = arglen; --i >= 0; ) arguments = [ fns[i].apply(this, arguments) ];\n            return arguments[0];\n        };\n    }, sequence = function() {\n        var fns = map(Function.toFunction, arguments), arglen = fns.length;\n        return function() {\n            var i;\n            for (i = 0; arglen > i; i++) arguments = [ fns[i].apply(this, arguments) ];\n            return arguments[0];\n        };\n    }, memoize = function(fn) {\n        return function() {\n            var args = toArray(arguments), hash = \"\", i = args.length;\n            for (currentArg = null; i--; ) currentArg = args[i], hash += currentArg === Object(currentArg) ? JSON.stringify(currentArg) : currentArg, \n            fn.memoize || (fn.memoize = {});\n            return hash in fn.memoize ? fn.memoize[hash] : fn.memoize[hash] = fn.apply(this, args);\n        };\n    }, reduce = function(fn, init, sequence) {\n        var i, len = sequence.length, result = init;\n        for (fn = Function.toFunction(fn), i = 0; len > i; i++) result = fn.apply(null, [ result, sequence[i] ]);\n        return result;\n    }.autoCurry(), select = function(fn, sequence) {\n        var i, x, len = sequence.length, result = [];\n        for (fn = Function.toFunction(fn), i = 0; len > i; i++) x = sequence[i], fn.apply(null, [ x, i ]) && result.push(x);\n        return result;\n    }.autoCurry(), guard = function(guard, fn, otherwise) {\n        return guard = Function.toFunction(guard || I), fn = Function.toFunction(fn), otherwise = Function.toFunction(otherwise || I), \n        function() {\n            return (guard.apply(this, arguments) ? fn : otherwise).apply(this, arguments);\n        };\n    }.autoCurry(), flip = function(f) {\n        return function() {\n            var args = toArray(arguments);\n            return args = args.slice(1, 2).concat(args.slice(0, 1)).concat(args.slice(2)), f.apply(null, args);\n        };\n    }, foldr = function(fn, init, sequence) {\n        var i, len = sequence.length, result = init;\n        for (fn = Function.toFunction(fn), i = len; --i >= 0; ) result = fn.apply(null, [ sequence[i], result ]);\n        return result;\n    }.autoCurry(), and = function() {\n        var args = map(Function.toFunction, arguments), arglen = args.length;\n        return function() {\n            var i, value = !0;\n            for (i = 0; arglen > i && (value = args[i].apply(this, arguments)); i++) ;\n            return !!value;\n        };\n    }, or = function() {\n        var args = map(Function.toFunction, arguments), arglen = args.length;\n        return function() {\n            var i, value = !1;\n            for (i = 0; arglen > i && !(value = args[i].apply(this, arguments)); i++) ;\n            return !!value;\n        };\n    }, some = function(fn, sequence) {\n        fn = Function.toFunction(fn);\n        var i, len = sequence.length, value = !1;\n        for (i = 0; len > i && !(value = fn.call(this, sequence[i])); i++) ;\n        return value;\n    }.autoCurry(), every = function(fn, sequence) {\n        fn = Function.toFunction(fn);\n        var i, len = sequence.length, value = !0;\n        for (i = 0; len > i && (value = fn.call(this, sequence[i])); i++) ;\n        return value;\n    }.autoCurry(), not = function(fn) {\n        return fn = Function.toFunction(fn), function() {\n            return !fn.apply(this, arguments);\n        };\n    }, eq = function(x) {\n        var equal = function() {\n            return every(function(t) {\n                return x === t;\n            }, arguments);\n        };\n        return 1 === arguments.length ? equal : equal.apply(this, arguments);\n    }, equal = function() {\n        var arglen = arguments.length, args = map(Function.toFunction, arguments);\n        return arglen ? function() {\n            var i, value = args[0].apply(this, arguments);\n            for (i = 1; arglen > i; i++) if (value != args[i].apply(this, args)) return !1;\n            return !0;\n        } : K(!0);\n    }, lambda = function(object) {\n        return object.toFunction();\n    }, invoke = function(methodName) {\n        var args = slice.call(arguments, 1);\n        return function(object) {\n            return object[methodName].apply(object, slice.call(arguments, 1).concat(args));\n        };\n    }, pluck = function(name, obj) {\n        return obj[name];\n    }.autoCurry(), until = function(pred, fn) {\n        return fn = Function.toFunction(fn), pred = Function.toFunction(pred), function(value) {\n            for (;!pred.call(this, value); ) value = fn.call(this, value);\n            return value;\n        };\n    }.autoCurry(), zip = function() {\n        var key, i, n = Math.min.apply(this, map(\".length\", arguments)), results = Array(n);\n        for (i = 0; n > i; i++) key = i + \"\", results[key] = map(pluck(key), arguments);\n        return results;\n    }, I = function(x) {\n        return x;\n    }, K = function(x) {\n        return function() {\n            return x;\n        };\n    }, S = function(f, g) {\n        var toFunction = Function.toFunction;\n        return f = toFunction(f), g = toFunction(g), function() {\n            var return_value_of_g = g.apply(this, arguments), original_args = slice.call(arguments, 0), all_args = unshift(original_args, return_value_of_g);\n            return f.apply(this, all_args);\n        };\n    }, partial = function() {\n        var i, fn = this, args = toArray(arguments), subpos = [];\n        for (i = 0; arguments.length > i; i++) arguments[i] == _ && subpos.push(i);\n        return function() {\n            var i, specialized = args.concat(slice.call(arguments, subpos.length));\n            for (i = 0; Math.min(subpos.length, arguments.length) > i; i++) specialized[subpos[i]] = arguments[i];\n            for (i = 0; specialized.length > i; i++) if (specialized[i] === _) return fn.partial.apply(fn, specialized);\n            return fn.apply(this, specialized);\n        };\n    }, ECMAspit = \"ab\".split(/a*/).length > 1 ? String.prototype.split : function(separator, limit) {\n        if (limit !== undefined) throw \"ECMAsplit: limit is unimplemented\";\n        var result = this.split.apply(this, arguments), re = RegExp(separator), savedIndex = re.lastIndex, match = re.exec(this);\n        return match && 0 == match.index && result.unshift(\"\"), re.lastIndex = savedIndex, \n        result;\n    }, stringLambda = function() {\n        var params = [], expr = this, sections = ECMAspit.call(expr, /\\s*->\\s*/m);\n        if (sections.length > 1) for (;sections.length; ) expr = sections.pop(), params = sections.pop().split(/\\s*,\\s*|\\s+/m), \n        sections.length && sections.push(\"(function(\" + params + \"){return (\" + expr + \")})\"); else if (expr.match(/\\b_\\b/)) params = \"_\"; else {\n            var leftSection = expr.match(/^\\s*(?:[+*\\/%&|\\^\\.=<>]|!=)/m), rightSection = expr.match(/[+\\-*\\/%&|\\^\\.=<>!]\\s*$/m);\n            if (leftSection || rightSection) leftSection && (params.push(\"$1\"), expr = \"$1\" + expr), \n            rightSection && (params.push(\"$2\"), expr += \"$2\"); else for (var v, regex = /(?:\\b[A-Z]|\\.[a-zA-Z_$])[a-zA-Z_$\\d]*|[a-zA-Z_$][a-zA-Z_$\\d]*\\s*:|this|arguments|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"/g, vars = this.replace(regex, \"\").match(/([a-z_$][a-z_$\\d]*)/gi) || [], i = 0; v = vars[i++]; ) params.indexOf(v) >= 0 || params.push(v);\n        }\n        return Function(params, \"return (\" + expr + \")\");\n    }, cacheStringLambda = function() {\n        var cached, proto = String.prototype, cache = {}, uncached = proto.lambda;\n        cached = function() {\n            var key = \"#\" + this;\n            return cache[key] || (cache[key] = uncached.call(this));\n        }, cached.cached = function() {}, cached.uncache = function() {\n            proto.lambda = uncached;\n        }, proto.lambda = cached;\n    }, stringToFunction = function() {\n        var body = this;\n        return body.match(/\\breturn\\b/) ? Function(this) : this.lambda();\n    };\n    return Function.prototype.partial = partial, Function.prototype.flip = function() {\n        return flip.apply(this, unshift(toArray(arguments), this));\n    }, Function.toFunction = function(value) {\n        return value.toFunction();\n    }, Function.prototype.toFunction = function() {\n        return this;\n    }, String.prototype.lambda = stringLambda, String.prototype.lambda.cache = cacheStringLambda, \n    String.prototype.toFunction = stringToFunction, {\n        map: map,\n        curry: curry,\n        compose: compose,\n        sequence: sequence,\n        memoize: memoize,\n        reduce: reduce,\n        foldl: reduce,\n        foldr: foldr,\n        select: select,\n        filter: select,\n        guard: guard,\n        flip: flip,\n        and: and,\n        or: or,\n        some: some,\n        every: every,\n        eq: eq,\n        not: not,\n        equal: equal,\n        lambda: lambda,\n        invoke: invoke,\n        pluck: pluck,\n        until: until,\n        zip: zip,\n        I: I,\n        K: K,\n        S: S,\n        install: function(except) {\n            var source = functional, target = parent;\n            for (var name in source) \"install\" == name || \"_\" == name.charAt(0) || except && except.contains(name) || (target[name] = source[name]);\n        }\n    };\n}(this), prelude = function() {\n    var funclib = Functional, nTimes = function(times, fun) {\n        for (var result = [], i = 0; times > i; i++) result = cons(fun(), result);\n        return result;\n    }.autoCurry(), log = function(what) {\n        return console.log(what), what;\n    }, log2 = function(one, two) {\n        return log(one), log(two);\n    }.autoCurry(), when = function(pred, f) {\n        return function() {\n            return pred.apply(this, arguments) ? f.apply(this, arguments) : undefined;\n        };\n    }.autoCurry(), ifelse = function(pred, f, g) {\n        return function() {\n            return pred.apply(this, arguments) ? f.apply(this, arguments) : g.apply(this, arguments);\n        };\n    }.autoCurry(), negate = function(bool) {\n        return !bool;\n    }, andand = function(x, y) {\n        return x && y;\n    }.autoCurry(), oror = function(x, y) {\n        return x || y;\n    }.autoCurry(), equals = function(x, y) {\n        return x === y;\n    }.autoCurry(), isArray = function(obj) {\n        return obj && obj.constructor == Array;\n    }, isObj = function(obj) {\n        return \"object\" == typeof obj && !isArray(obj);\n    }, isNumber = function(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }, take = function(n, xs) {\n        return xs.slice(0, n);\n    }.autoCurry(), drop = function(n, xs) {\n        return xs.slice(n);\n    }.autoCurry(), unshift = function(xs, x) {\n        return x.concat(xs);\n    }.autoCurry(), cons = function(x, xs) {\n        return [ x ].concat(xs);\n    }.autoCurry(), concat = function(xs, ys) {\n        return xs.concat(ys);\n    }.autoCurry(), first = function(xs) {\n        return xs[0];\n    }, item = function(n, xs) {\n        return xs[n];\n    }.autoCurry(), rest = function(xs) {\n        return \"string\" == typeof xs ? xs.substr(1) : xs.slice(1);\n    }, last = function(xs) {\n        return xs[xs.length - 1];\n    }, join = function(token, xs) {\n        return xs.join(token);\n    }.autoCurry(), groupsOf = function(n, xs) {\n        return xs.length ? cons(take(n, xs), groupsOf(n, drop(n, xs))) : [];\n    }.autoCurry(), zipWith = function(f, xs, ys) {\n        return f = f.toFunction(), xs.reduce(function(result, x, i) {\n            return result.concat(f(x, ys[i]));\n        }, []);\n    }.autoCurry(), uniq = function(xs) {\n        for (var result = [], i = 0; xs.length > i; i++) 0 > result.indexOf(xs[i]) && result.push(xs[i]);\n        return result;\n    }, uniqBy = function(fun, xs) {\n        for (var result = [], len = xs.length, fun = fun.toFunction(), i = 0; len > i; i++) 0 > funclib.map(fun)(result).indexOf(fun(xs[i])) && result.push(xs[i]);\n        return result;\n    }.autoCurry(), reverse = function(xs) {\n        var mempty = \"string\" == typeof xs ? \"\" : [];\n        return isArray(xs) ? xs.reverse() : funclib.reduce(function(x, acc) {\n            return acc.concat(x);\n        }, mempty, xs);\n    }.autoCurry(), is_num_array = function(arr) {\n        return reduce(andand, !0, funclib.map(isNumber, arr));\n    }, sort = function(xs) {\n        return num_sort_func = function(a, b) {\n            return a - b;\n        }, is_num_array ? xs.sort(num_sort_func) : xs.sort();\n    }, element = function(arr, x) {\n        return arr.indexOf(x) >= 0;\n    }.autoCurry(), flatten = funclib.reduce(function(a, b) {\n        return a.concat(b);\n    }, []), sortBy = function(fun, xs) {\n        var _sortBy = function(iterator, xs, context) {\n            return map(\".value\", map(function(value, index) {\n                return {\n                    value: value,\n                    criteria: iterator.call(context, value, index)\n                };\n            }, xs).sort(function(left, right) {\n                var a = left.criteria, b = right.criteria;\n                return b > a ? -1 : a > b ? 1 : 0;\n            }));\n        }, f = fun.toFunction();\n        return _sortBy(f, xs);\n    }.autoCurry(), groupBy = function(fun, xs) {\n        var f = fun.toFunction(), _makeHash = function(obj, x) {\n            var val = f(x);\n            return obj[val] || (obj[val] = []), obj[val].push(x), obj;\n        };\n        return reduce(_makeHash, {}, xs);\n    }.autoCurry(), strip = function(str) {\n        return str.replace(/\\s+/g, \"\");\n    }, split = function(token, xs) {\n        return xs.split(token);\n    }.autoCurry(), test = function(expr, x) {\n        return expr.test(x);\n    }.autoCurry(), match = function(expr, x) {\n        return x.match(expr);\n    }.autoCurry(), replace = function(pattern, sub, str) {\n        return str.replace(pattern, sub);\n    }.autoCurry(), indexOf = function(par, kid) {\n        return par.indexOf(kid);\n    }.autoCurry(), contains = function(par, kid) {\n        return -1 !== par.indexOf(kid);\n    }.autoCurry(), setVal = function(attribute, x, val) {\n        return x[attribute] = val, val;\n    }.autoCurry(), getVal = function(attribute, x) {\n        return function() {\n            return x[attribute];\n        };\n    }.autoCurry(), getProp = function(x, attr) {\n        return x[attr];\n    }.autoCurry(), setProp = function(x, attr, val) {\n        return x[attr] = val, val;\n    }.autoCurry(), random = function(i) {\n        return Math.floor(Math.random() * i);\n    }, subtract = function(x, y) {\n        return y - x;\n    }.autoCurry(), sum = funclib.reduce(\"+\", 0), div = function(x, y) {\n        return x / y;\n    }, average = function(xs) {\n        var zerolessArr = filter(\"!==0\", xs);\n        return div(sum(zerolessArr), zerolessArr.length);\n    }, repeat = function(arg, n) {\n        return nTimes(n, funclib.id.curry(arg));\n    }.autoCurry();\n    return {\n        equals: equals,\n        isArray: isArray,\n        isObj: isObj,\n        nTimes: nTimes,\n        log: log,\n        log2: log2,\n        take: take,\n        drop: drop,\n        unshift: unshift,\n        cons: cons,\n        concat: concat,\n        first: first,\n        item: item,\n        rest: rest,\n        last: last,\n        join: join,\n        isNumber: isNumber,\n        groupsOf: groupsOf,\n        zipWith: zipWith,\n        uniq: uniq,\n        uniqBy: uniqBy,\n        reverse: reverse,\n        sort: sort,\n        element: element,\n        flatten: flatten,\n        sortBy: sortBy,\n        groupBy: groupBy,\n        strip: strip,\n        split: split,\n        indexOf: indexOf,\n        contains: contains,\n        test: test,\n        match: match,\n        replace: replace,\n        ifelse: ifelse,\n        when: when,\n        negate: negate,\n        andand: andand,\n        oror: oror,\n        setVal: setVal,\n        getVal: getVal,\n        setProp: setProp,\n        getProp: getProp,\n        random: random,\n        subtract: subtract,\n        sum: sum,\n        div: div,\n        average: average,\n        repeat: repeat\n    };\n}();\n\n(function(engine) {\n    function compileAll(source, compiled) {\n        compiled = compiled || {};\n        for (var key in source) try {\n            compiled[key] = engine.compile(source[key]);\n        } catch (err) {\n            console.log(err);\n        }\n        return compiled;\n    }\n    var source = engine.source = engine.source || {}, compiled = engine.templates = engine.templates || {};\n    engine.registerPartial(\"player\", \"<span>{{user}}</span>\"), source.stream = [ \"<li id='tf{{class}}'>\", \"<span class='tf-class'>{{class}}</span>\", \"<span class='tf-players'>\", \"{{#each added}}\", \"{{> player this}}\", \"{{/each}}\", \"</span>\", \"</li>\" ].join(\"\"), \n    source.authpage = [ \"<h1>Connect to {{network}} IRC</h1>\", \"<form id='login'>\", \"<div class='nick right'><span>Nickname:</span><input type='text' name='basic' id='nickname' value={{nickname}}></div>\", \"<div class='username right {{#unless full}}hidden{{/unless}}'><span>Gamesurge username:</span><input type='text' name='full' id='username' value='{{username}}'></div>\", \"<div class='password right {{#unless full}}hidden{{/unless}}'><span>Password:</span><input type='password' name='full' id='password' value='{{password}}'></div>\", \"<div class='authenticate'>\", \"<span>Authenticate (optional)</span><input type='checkbox' id='authenticate' {{check full}}>\", \"</div>\", \"<div><input type='submit' value='Connect' /></div>\", \"</form>\" ].join(\"\"), \n    engine.registerHelper(\"not\", function(b) {\n        return !b;\n    }), engine.registerHelper(\"hidden\", function(hidden) {\n        return console.log(hidden), hidden ? \"hidden\" : \"\";\n    }), engine.registerHelper(\"check\", function(checked) {\n        return checked ? \"checked\" : \"\";\n    }), engine.registerHelper(\"chain\", function() {\n        var value, helpers = [];\n        return $each(arguments, function(arg, i) {\n            return engine.helpers[arg] ? (helpers.push(engine.helpers[arg]), void 0) : (value = arg, \n            $each(helpers, function(helper) {\n                value = helper(value, arguments[i + 1]);\n            }), !1);\n        }), value;\n    }), compileAll(source, compiled);\n})(Handlebars), function(par, undefined) {\n    par.QWEBIRC_BUILD = \"bbc577ad5cb78d946ac1\";\n    var qwebirc = par.qwebirc = {}, irc = qwebirc.irc = {}, util = qwebirc.util = {}, crypto = util.crypto = {}, config = qwebirc.config = {}, auth = qwebirc.auth = {}, ui = qwebirc.ui = {}, themes = ui.themes = {}, style = ui.style = {}, sound = qwebirc.sound = {};\n    qwebirc.BUILD = QWEBIRC_BUILD, qwebirc.FILE_SUFFIX = \"-\" + QWEBIRC_BUILD, qwebirc.VERSION = \"0.92-dev\";\n    var Functional = par.Functional, prelude = par.prelude, BROUHAHA = \"#brouhaha\", CONNECTION_DETAILS = \"Connection details\", STATUS = \"Status\", OPTIONS = \"Options\", BASE_WINDOWS = [ BROUHAHA, CONNECTION_DETAILS, STATUS, OPTIONS ];\n    irc.IRCLowercaseTable = [ \"\\0\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\\b\", \"	\", \"\\n\", \"\", \"\\f\", \"\\r\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \" \", \"!\", '\"', \"#\", \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \"-\", \".\", \"/\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \":\", \";\", \"<\", \"=\", \">\", \"?\", \"@\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"{\", \"|\", \"}\", \"~\", \"_\", \"`\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"{\", \"|\", \"}\", \"~\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" ], \n    util.DaysOfWeek = {\n        0: \"Sun\",\n        1: \"Mon\",\n        2: \"Tue\",\n        3: \"Wed\",\n        4: \"Thu\",\n        5: \"Fri\",\n        6: \"Sat\"\n    }, util.MonthsOfYear = {\n        0: \"Jan\",\n        1: \"Feb\",\n        2: \"Mar\",\n        3: \"Apr\",\n        4: \"May\",\n        5: \"Jun\",\n        6: \"Jul\",\n        7: \"Aug\",\n        8: \"Sep\",\n        9: \"Oct\",\n        10: \"Nov\",\n        11: \"Dec\"\n    }, Array.implement({\n        item: function(n) {\n            return this[n];\n        }\n    }), String.implement({\n        replaceAll: function(tofind, torep) {\n            for (var ns = this; ns.indexOf(tofind) > -1; ) ns = ns.replace(tofind, torep);\n            return ns;\n        },\n        splitMax: function(by, max) {\n            var items = this.split(by), len = max - 1, newitems = items.slice(0, len);\n            return items.length >= max && newitems.push(items.slice(len).join(by)), newitems;\n        },\n        startsWith: function(what) {\n            return this.substr(0, what.length) === what;\n        }\n    }), Object.extend({\n        subset: function(object, keys) {\n            for (var results = {}, i = 0, l = keys.length; l > i; i++) {\n                var k = keys[i];\n                k in object && (results[k] = object[k]);\n            }\n            return results;\n        }\n    });\n    var whitespace = /\\s/, notwhitespace = /\\S+$/, $identity = Functional.I, notEqual = Functional.compose(Functional.not, Functional.eq), charAt = function(n, str) {\n        return str.charAt(n);\n    }.autoCurry(), splitBang = prelude.split(\"!\"), joinEmpty = prelude.join(\"\"), splitEmpty = prelude.split(\"\"), joinComma = prelude.join(\",\"), splitComma = prelude.split(\",\"), concatUnique = Functional.compose(prelude.uniq, prelude.concat), uniqueBetweenArrays = function(arr1, arr2) {\n        var notcontained = Functional.not(prelude.contains(arr2));\n        return arr1.filter(notcontained);\n    }, startsWith = function(what, str) {\n        return str.substr(0, what.length) === what;\n    }.autoCurry(), each = Array.forEach.flip().autoCurry(2);\n    RegExp.escape = prelude.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\"), util.dictCopy = function() {\n        return $extend.apply({}, arguments);\n    }, util.hostToNick = Functional.compose(prelude.first, splitBang), util.hostToHost = Functional.compose(prelude.item(1), splitBang);\n    var formatChannel = util.formatChannelString = function(chan) {\n        return startsWith(\"#\", chan) || (chan = \"#\" + chan), chan;\n    }, appendChannel = function(chans, chan) {\n        var sep = chans && chan ? \",\" : \"\";\n        return chans.concat(sep, chan);\n    }, isBaseWindow = prelude.contains(BASE_WINDOWS);\n    util.formatChannelStrings = Functional.compose(joinComma, prelude.uniq, Functional.map(formatChannel), splitComma), \n    util.addChannel = Functional.compose(joinComma, prelude.uniq, splitComma, appendChannel), \n    util.prependChannel = Functional.compose(joinComma, prelude.uniq, splitComma, appendChannel.flip()), \n    util.arrayToChanString = Functional.compose(joinComma, prelude.uniq, Functional.filter.curry(Functional.not(isBaseWindow))), \n    util.removeChannel = function(list, value) {\n        return joinComma(splitComma(list).erase(value));\n    }, util.nickChanComparitor = function(client, nickHash) {\n        var _prefixes = client.prefixes, _prefixNone = _prefixes.length, prefixWeight = function(pre) {\n            return 0 !== pre.length ? _prefixes.indexOf(pre) : _prefixNone;\n        }, toLower = client.toIRCLower;\n        return function(nick1, nick2) {\n            var p1weight = prefixWeight(nickHash[nick1].prefixes), p2weight = prefixWeight(nickHash[nick2].prefixes);\n            return p1weight !== p2weight ? p1weight - p2weight : toLower(nick1).localeCompare(toLower(nick2));\n        };\n    }, util.nickPrefixer = function(nickHash) {\n        return function(nick) {\n            return nickHash[nick].prefixes.concat(nick);\n        };\n    }, util.validPrefix = prelude.contains, util.addPrefix = Functional.compose(joinEmpty, prelude.uniq, prelude.concat), \n    util.prefixOnNick = function(prefixes, nick) {\n        var c = nick.charAt(0);\n        return util.validPrefix(prefixes, c) ? [ c, nick.substr(1) ] : [ \"\", nick ];\n    }.autoCurry(), util.getPrefix = Functional.compose(prelude.first, util.prefixOnNick), \n    util.stripPrefix = Functional.compose(prelude.item(1), util.prefixOnNick), util.toHSBColour = function(nick, client) {\n        var lower = client.toIRCLower(util.stripPrefix(client.prefixes, nick));\n        if (lower == client.lowerNickname) return null;\n        for (var hash = 0, i = 0; lower.length > i; i++) hash = 31 * hash + lower.charCodeAt(i);\n        var hue = Math.abs(hash) % 360;\n        return new Color([ hue, 70, 60 ], \"hsb\");\n    };\n    var charIRCLower = Functional.compose(Array.item.curry(irc.IRCLowercaseTable), String.charCodeAt.partial(_, 0));\n    irc.RFC1459toIRCLower = Functional.memoize(Functional.compose(prelude.join(\"\"), Functional.map(charIRCLower))), \n    irc.toIRCCompletion = Functional.compose(prelude.replace(/[^\\w]+/g, \"\"), Functional.invoke(\"toIRCLower\")), \n    irc.ASCIItoIRCLower = String.toLowerCase, util.parseURI = function(uri) {\n        var result = {}, start = uri.indexOf(\"?\");\n        if (-1 === start) return result;\n        for (var querystring = uri.substring(start + 1), args = querystring.split(\"&\"), i = 0; args.length > i; i++) {\n            var part = args[i].splitMax(\"=\", 2);\n            2 > part.length || (result[unescape(part[0])] = unescape(part[1]));\n        }\n        return result;\n    }, util.longtoduration = function(l) {\n        var seconds = l % 60, minutes = Math.floor(l % 3600 / 60), hours = Math.floor(l % 86400 / 3600), days = Math.floor(l / 86400);\n        return days + \" days \" + hours + \" hours \" + minutes + \" minutes \" + seconds + \" seconds\";\n    };\n    var pad = util.pad = function(x) {\n        return x += \"\", 1 === x.length ? \"0\" + x : x;\n    };\n    util.browserVersion = $lambda(navigator.userAgent), util.getEnclosedWord = function(str, pos) {\n        pos >>>= 0;\n        var left = str.slice(0, pos + 1).search(notwhitespace), right = str.slice(pos).search(whitespace), word = 0 > right ? str.slice(left) : str.slice(left, right + pos);\n        return [ left, word ];\n    }, util.randHexString = function(numBytes) {\n        for (var getByte = function() {\n            return (0 | 256 * (1 + Math.random())).toString(16).substring(1);\n        }, l = [], i = 0; numBytes > i; i++) l.push(getByte());\n        return l.join(\"\");\n    }, irc.IRCTimestamp = function(date) {\n        return \"[\" + pad(date.getHours()) + \":\" + pad(date.getMinutes()) + \"]\";\n    }, irc.IRCDate = function(d) {\n        return util.DaysOfWeek[d.getDay()] + \" \" + util.MonthsOfYear[d.getMonth()] + \" \" + pad(d.getDate()) + \" \" + pad(d.getHours()) + \":\" + pad(d.getMinutes()) + \":\" + pad(d.getSeconds()) + \" \" + d.getFullYear();\n    }, irc.NickChanEntry = function() {\n        this.prefixes = \"\", this.lastSpoke = 0;\n    }, util.deviceHasKeyboard = function() {\n        var DESKTOP_UAs = [ \"Chrome\", \"Firefox\", \"Camino\", \"Iceweasel\", \"K-Meleon\", \"Konqueror\", \"SeaMonkey\", \"Windows NT\", \"Windows 9\" ], ua = navigator.userAgent, v = 0 !== DESKTOP_UAs.filter(Functional.compose(notEqual(-1), prelude.indexOf(ua))).length;\n        return util.deviceHasKeyboard = $lambda(v), v;\n    }, util.generateID = function() {\n        var id = 0;\n        return function() {\n            return \"qqa-\" + id++;\n        };\n    }();\n    var B64 = util.B64 = {\n        _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n        encode: function(input) {\n            if (!input) return \"\";\n            input = B64._utf8_encode(input);\n            for (var chr1, chr2, chr3, enc1, enc2, enc3, enc4, output = \"\", i = 0; input.length > i; ) chr1 = input.charCodeAt(i++), \n            chr2 = input.charCodeAt(i++), chr3 = input.charCodeAt(i++), enc1 = chr1 >> 2, enc2 = (3 & chr1) << 4 | chr2 >> 4, \n            enc3 = (15 & chr2) << 2 | chr3 >> 6, enc4 = 63 & chr3, isNaN(chr2) ? enc3 = enc4 = 64 : isNaN(chr3) && (enc4 = 64), \n            output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n            return output;\n        },\n        decode: function(input) {\n            if (!input) return \"\";\n            var chr1, chr2, chr3, enc1, enc2, enc3, enc4, output = \"\", i = 0;\n            for (input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); input.length > i; ) enc1 = this._keyStr.indexOf(input.charAt(i++)), \n            enc2 = this._keyStr.indexOf(input.charAt(i++)), enc3 = this._keyStr.indexOf(input.charAt(i++)), \n            enc4 = this._keyStr.indexOf(input.charAt(i++)), chr1 = enc1 << 2 | enc2 >> 4, chr2 = (15 & enc2) << 4 | enc3 >> 2, \n            chr3 = (3 & enc3) << 6 | enc4, output += String.fromCharCode(chr1), 64 != enc3 && (output += String.fromCharCode(chr2)), \n            64 != enc4 && (output += String.fromCharCode(chr3));\n            return output = B64._utf8_decode(output);\n        },\n        _utf8_encode: function(string) {\n            string = string.replace(/\\r\\n/g, \"\\n\");\n            for (var utftext = \"\", n = 0; string.length > n; n++) {\n                var c = string.charCodeAt(n);\n                128 > c ? utftext += String.fromCharCode(c) : c > 127 && 2048 > c ? (utftext += String.fromCharCode(192 | c >> 6), \n                utftext += String.fromCharCode(128 | 63 & c)) : (utftext += String.fromCharCode(224 | c >> 12), \n                utftext += String.fromCharCode(128 | 63 & c >> 6), utftext += String.fromCharCode(128 | 63 & c));\n            }\n            return utftext;\n        },\n        _utf8_decode: function(utftext) {\n            for (var string = \"\", i = 0, c = c1 = c2 = 0; utftext.length > i; ) c = utftext.charCodeAt(i), \n            128 > c ? (string += String.fromCharCode(c), i++) : c > 191 && 224 > c ? (c2 = utftext.charCodeAt(i + 1), \n            string += String.fromCharCode((31 & c) << 6 | 63 & c2), i += 2) : (c2 = utftext.charCodeAt(i + 1), \n            c3 = utftext.charCodeAt(i + 2), string += String.fromCharCode((15 & c) << 12 | (63 & c2) << 6 | 63 & c3), \n            i += 3);\n            return string;\n        }\n    };\n    crypto.MD5 = function() {\n        function rhex(num) {\n            for (var str = \"\", j = 0; 3 >= j; j++) str += hex_chr.charAt(15 & num >> 8 * j + 4) + hex_chr.charAt(15 & num >> 8 * j);\n            return str;\n        }\n        function str2blks_MD5(str) {\n            for (var nblk = (str.length + 8 >> 6) + 1, blks = Array(16 * nblk), i = 0; 16 * nblk > i; i++) blks[i] = 0;\n            for (var i = 0; str.length > i; i++) blks[i >> 2] |= str.charCodeAt(i) << 8 * (i % 4);\n            return blks[i >> 2] |= 128 << 8 * (i % 4), blks[16 * nblk - 2] = 8 * str.length, \n            blks;\n        }\n        function add(x, y) {\n            return (2147483647 & x) + (2147483647 & y) ^ 2147483648 & x ^ 2147483648 & y;\n        }\n        function rol(num, cnt) {\n            return num << cnt | num >>> 32 - cnt;\n        }\n        function cmn(q, a, b, x, s, t) {\n            return add(rol(add(add(a, q), add(x, t)), s), b);\n        }\n        function ff(a, b, c, d, x, s, t) {\n            return cmn(b & c | ~b & d, a, b, x, s, t);\n        }\n        function gg(a, b, c, d, x, s, t) {\n            return cmn(b & d | c & ~d, a, b, x, s, t);\n        }\n        function hh(a, b, c, d, x, s, t) {\n            return cmn(b ^ c ^ d, a, b, x, s, t);\n        }\n        function ii(a, b, c, d, x, s, t) {\n            return cmn(c ^ (b | ~d), a, b, x, s, t);\n        }\n        function calcMD5(str) {\n            for (var x = str2blks_MD5(str), a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, i = 0; x.length > i; i += 16) {\n                var olda = a, oldb = b, oldc = c, oldd = d;\n                a = ff(a, b, c, d, x[i + 0], 7, 3614090360), d = ff(d, a, b, c, x[i + 1], 12, 3905402710), \n                c = ff(c, d, a, b, x[i + 2], 17, 606105819), b = ff(b, c, d, a, x[i + 3], 22, 3250441966), \n                a = ff(a, b, c, d, x[i + 4], 7, 4118548399), d = ff(d, a, b, c, x[i + 5], 12, 1200080426), \n                c = ff(c, d, a, b, x[i + 6], 17, 2821735955), b = ff(b, c, d, a, x[i + 7], 22, 4249261313), \n                a = ff(a, b, c, d, x[i + 8], 7, 1770035416), d = ff(d, a, b, c, x[i + 9], 12, 2336552879), \n                c = ff(c, d, a, b, x[i + 10], 17, 4294925233), b = ff(b, c, d, a, x[i + 11], 22, 2304563134), \n                a = ff(a, b, c, d, x[i + 12], 7, 1804603682), d = ff(d, a, b, c, x[i + 13], 12, 4254626195), \n                c = ff(c, d, a, b, x[i + 14], 17, 2792965006), b = ff(b, c, d, a, x[i + 15], 22, 1236535329), \n                a = gg(a, b, c, d, x[i + 1], 5, 4129170786), d = gg(d, a, b, c, x[i + 6], 9, 3225465664), \n                c = gg(c, d, a, b, x[i + 11], 14, 643717713), b = gg(b, c, d, a, x[i + 0], 20, 3921069994), \n                a = gg(a, b, c, d, x[i + 5], 5, 3593408605), d = gg(d, a, b, c, x[i + 10], 9, 38016083), \n                c = gg(c, d, a, b, x[i + 15], 14, 3634488961), b = gg(b, c, d, a, x[i + 4], 20, 3889429448), \n                a = gg(a, b, c, d, x[i + 9], 5, 568446438), d = gg(d, a, b, c, x[i + 14], 9, 3275163606), \n                c = gg(c, d, a, b, x[i + 3], 14, 4107603335), b = gg(b, c, d, a, x[i + 8], 20, 1163531501), \n                a = gg(a, b, c, d, x[i + 13], 5, 2850285829), d = gg(d, a, b, c, x[i + 2], 9, 4243563512), \n                c = gg(c, d, a, b, x[i + 7], 14, 1735328473), b = gg(b, c, d, a, x[i + 12], 20, 2368359562), \n                a = hh(a, b, c, d, x[i + 5], 4, 4294588738), d = hh(d, a, b, c, x[i + 8], 11, 2272392833), \n                c = hh(c, d, a, b, x[i + 11], 16, 1839030562), b = hh(b, c, d, a, x[i + 14], 23, 4259657740), \n                a = hh(a, b, c, d, x[i + 1], 4, 2763975236), d = hh(d, a, b, c, x[i + 4], 11, 1272893353), \n                c = hh(c, d, a, b, x[i + 7], 16, 4139469664), b = hh(b, c, d, a, x[i + 10], 23, 3200236656), \n                a = hh(a, b, c, d, x[i + 13], 4, 681279174), d = hh(d, a, b, c, x[i + 0], 11, 3936430074), \n                c = hh(c, d, a, b, x[i + 3], 16, 3572445317), b = hh(b, c, d, a, x[i + 6], 23, 76029189), \n                a = hh(a, b, c, d, x[i + 9], 4, 3654602809), d = hh(d, a, b, c, x[i + 12], 11, 3873151461), \n                c = hh(c, d, a, b, x[i + 15], 16, 530742520), b = hh(b, c, d, a, x[i + 2], 23, 3299628645), \n                a = ii(a, b, c, d, x[i + 0], 6, 4096336452), d = ii(d, a, b, c, x[i + 7], 10, 1126891415), \n                c = ii(c, d, a, b, x[i + 14], 15, 2878612391), b = ii(b, c, d, a, x[i + 5], 21, 4237533241), \n                a = ii(a, b, c, d, x[i + 12], 6, 1700485571), d = ii(d, a, b, c, x[i + 3], 10, 2399980690), \n                c = ii(c, d, a, b, x[i + 10], 15, 4293915773), b = ii(b, c, d, a, x[i + 1], 21, 2240044497), \n                a = ii(a, b, c, d, x[i + 8], 6, 1873313359), d = ii(d, a, b, c, x[i + 15], 10, 4264355552), \n                c = ii(c, d, a, b, x[i + 6], 15, 2734768916), b = ii(b, c, d, a, x[i + 13], 21, 1309151649), \n                a = ii(a, b, c, d, x[i + 4], 6, 4149444226), d = ii(d, a, b, c, x[i + 11], 10, 3174756917), \n                c = ii(c, d, a, b, x[i + 2], 15, 718787259), b = ii(b, c, d, a, x[i + 9], 21, 3951481745), \n                a = add(a, olda), b = add(b, oldb), c = add(c, oldc), d = add(d, oldd);\n            }\n            return rhex(a) + rhex(b) + rhex(c) + rhex(d);\n        }\n        this.digest = calcMD5;\n        var hex_chr = \"0123456789abcdef\";\n    }, crypto.xorStreams = function(data, prngstream) {\n        if (data.length == prngstream.length) {\n            for (var output = [], i = 0; data.length > i; i++) output.push(String.fromCharCode(data.charCodeAt(i) ^ prngstream[i]));\n            return output.join(\"\");\n        }\n    }, crypto.ARC4 = function(key, data) {\n        var prngstream = crypto.getARC4Stream(key, data.length + 1024);\n        return prngstream = prngstream.slice(1024), crypto.xorStreams(data, prngstream);\n    }, util.crypto.getARC4Stream = function(key, length) {\n        for (var s = [], keyint = [], i = 0; key.length > i; i++) keyint.push(key.charCodeAt(i));\n        for (var i = 0; 256 > i; i++) s[i] = i;\n        for (var j = 0, i = 0; 256 > i; i++) {\n            j = 255 & j + s[i] + keyint[i % key.length];\n            var w = s[i];\n            s[i] = s[j], s[j] = w;\n        }\n        for (var output = [], i = 0, j = 0, k = 0; length > k; k++) {\n            i = 255 & i + 1, j = 255 & j + s[i];\n            var w = s[i];\n            s[i] = s[j], s[j] = w, output.push(s[255 & s[i] + s[j]]);\n        }\n        return output;\n    }, irc.PMODE_LIST = 0, irc.PMODE_SET_UNSET = 1, irc.PMODE_SET_ONLY = 2, irc.PMODE_REGULAR_MODE = 3, \n    irc.Numerics = {\n        \"001\": \"RPL_WELCOME\",\n        \"433\": \"ERR_NICKNAMEINUSE\",\n        \"004\": \"RPL_MYINFO\",\n        \"005\": \"RPL_ISUPPORT\",\n        \"353\": \"RPL_NAMREPLY\",\n        \"366\": \"RPL_ENDOFNAMES\",\n        \"331\": \"RPL_NOTOPIC\",\n        \"332\": \"RPL_TOPIC\",\n        \"333\": \"RPL_TOPICWHOTIME\",\n        \"311\": \"RPL_WHOISUSER\",\n        \"312\": \"RPL_WHOISSERVER\",\n        \"313\": \"RPL_WHOISOPERATOR\",\n        \"317\": \"RPL_WHOISIDLE\",\n        \"671\": \"RPL_WHOISSECURE\",\n        \"318\": \"RPL_ENDOFWHOIS\",\n        \"319\": \"RPL_WHOISCHANNELS\",\n        \"330\": \"RPL_WHOISACCOUNT\",\n        \"338\": \"RPL_WHOISACTUALLY\",\n        \"343\": \"RPL_WHOISOPERNAME\",\n        \"320\": \"RPL_WHOISGENERICTEXT\",\n        \"325\": \"RPL_WHOISWEBIRC\",\n        \"301\": \"RPL_AWAY\",\n        \"401\": \"ERR_NOSUCHNICK\",\n        \"404\": \"ERR_CANNOTSENDTOCHAN\",\n        \"482\": \"ERR_CHANOPPRIVSNEEDED\",\n        \"305\": \"RPL_UNAWAY\",\n        \"306\": \"RPL_NOWAWAY\",\n        \"324\": \"RPL_CHANNELMODEIS\",\n        \"329\": \"RPL_CREATIONTIME\"\n    }, irc.RegisteredCTCPs = {\n        VERSION: $lambda(\"qwebirc v\" + qwebirc.VERSION + \", copyright (C) 2008-2011 Chris Porter and the qwebirc project -- \" + qwebirc.util.browserVersion()),\n        USERINFO: $lambda(\"qwebirc\"),\n        TIME: function() {\n            return irc.IRCDate(new Date());\n        },\n        PING: $lambda,\n        CLIENTINFO: $lambda(\"PING VERSION TIME USERINFO CLIENTINFO WEBSITE\"),\n        WEBSITE: $lambda(window == window.top ? \"direct\" : document.referrer)\n    }, irc.DummyNicknameValidator = new Class({\n        validate: $identity\n    }), irc.NicknameValidator = new Class({\n        initialize: function(options) {\n            this.options = options;\n        },\n        validate: function(nick, permitDot) {\n            for (var generated = [], max = Math.min(this.options.maxLen, nick.length), exploded = nick.split(\"\"), i = 0; max > i; i++) {\n                var _char = exploded[i], valid = 0 === i ? this.options.validFirstChar : this.options.validSubChars;\n                -1 != valid.indexOf(_char) || permitDot && \".\" == _char ? generated.push(_char) : generated.push(\"_\");\n            }\n            for (;generated.length < this.options.minLen; ) generated.push(\"_\");\n            return generated.join(\"\");\n        }\n    }), ui.Interface = new Class({\n        Implements: [ Options, Events ],\n        options: {\n            initialNickname: \"newb1234\",\n            initialChannels: \"#tf2mix,#tf2.pug.na,#tf2.pug.nahl,#tf2.mix.nahl,#tf2scrim,#tf2hlscrim,#tftv\",\n            networkName: \"Gamesurge\",\n            networkServices: [],\n            loginRegex: null,\n            appTitle: \"Gamesurge.net Web IRC\",\n            searchURL: !0,\n            theme: undefined,\n            baseURL: \"atf2.org\",\n            hue: null,\n            saturation: null,\n            lightness: null,\n            uiOptionsArg: null,\n            nickValidation: null,\n            dynamicBaseURL: \"/\",\n            staticBaseURL: \"/\",\n            cookieOpts: {\n                duration: 9999,\n                path: \"/\"\n            }\n        },\n        initialize: function(element, uitheme, options) {\n            var self = this, win = window;\n            self.setOptions(options), win.steamlink = 0, win.lastkick = {\n                channel: \"\",\n                last: 1\n            }, win.hasfocus = 1, win.onfocus = function() {\n                self.hasfocus = 1;\n            }, win.onblur = function() {\n                self.hasfocus = 0;\n            }, qwebirc.global = {\n                dynamicBaseURL: options.dynamicBaseURL,\n                staticBaseURL: options.staticBaseURL,\n                nicknameValidator: $defined(options.nickValidation) ? new irc.NicknameValidator(options.nickValidation) : new irc.DummyNicknameValidator()\n            }, win.addEvent(\"domready\", function() {\n                function callback(loginopts) {\n                    console.log(\"irc client hack sucess\"), $extend(loginopts, Object.subset(options, [ \"initialChannels\", \"getChannels\", \"storeChannels\" ])), \n                    self.IRCClient = new irc.IRCClient(loginopts, self.ui_), self.IRCClient.connect(), \n                    win.onbeforeunload = qwebirc_ui_onbeforeunload, win.addEvent(\"unload\", function() {\n                        self.IRCClient.quit(\"Page closed\");\n                    }), self.fireEvent(\"auth\", {\n                        IRCClient: self.IRCClient,\n                        parent: self\n                    });\n                }\n                var inick = null, options = self.options, ichans = options.initialChannels, autoConnect = !1, Cookie = win.Cookie, cookopts = options.cookieOpts, authCookies = {\n                    nick: new Cookie(\"nickname\", cookopts),\n                    user: new Cookie(\"gamesurge\", cookopts),\n                    pass: new Cookie(\"password\", cookopts),\n                    auth: new Cookie(\"enableAuth\", cookopts)\n                }, channelCookie = new Cookie(\"channels\", cookopts);\n                if (options.getChannels = channelCookie.read.bind(channelCookie), options.storeChannels = channelCookie.write.bind(channelCookie), \n                options.searchURL) {\n                    var chans, args = util.parseURI(\"\" + document.location), url = args.url, nick = args.nick, canAutoConnect = !1;\n                    if (options.hue = self.getHueArg(args, \"\"), options.saturation = self.getSaturationArg(args, \"\"), \n                    options.lightness = self.getLightnessArg(args, \"\"), options.thue = self.getHueArg(args, \"t\"), \n                    options.tsaturation = self.getSaturationArg(args, \"t\"), options.tlightness = self.getLightnessArg(args, \"t\"), \n                    $defined(args.uio) && (options.uiOptionsArg = args.uio), $defined(url)) ichans = self.parseIRCURL(url), \n                    chans && (canAutoConnect = !0); else if (chans = args.channels) {\n                        var cdata = chans.split(\" \");\n                        cdata[0] = util.formatChannelStrings(cdata[0]), ichans = cdata.join(\" \"), canAutoConnect = !0;\n                    }\n                    $defined(nick) && (inick = self.randSub(nick)), args.randomnick && 1 == args.randomnick && (inick = options.initialNickname);\n                }\n                self.ui_ = new uitheme($(element), new ui.Theme(options.theme), options);\n                var usingAutoNick = !0;\n                //!$defined(nick);//stupid used out of scope\n                inick = options.initialNickname, self.ui_.loginBox(callback, inick, ichans, autoConnect, usingAutoNick, options.networkName, authCookies);\n            });\n        },\n        getHueArg: function(args) {\n            var hue = args.hue;\n            return $defined(hue) ? (hue = parseInt(hue, 10), hue > 360 || 0 > hue ? null : hue) : null;\n        },\n        getSaturationArg: function(args) {\n            var saturation = args.saturation;\n            return $defined(saturation) ? (saturation = parseInt(saturation, 10), saturation > 100 || -100 > saturation ? null : saturation) : null;\n        },\n        getLightnessArg: function(args) {\n            var lightness = args.lightness;\n            return $defined(lightness) ? (lightness = parseInt(lightness, 10), lightness > 100 || -100 > lightness ? null : lightness) : null;\n        },\n        randSub: function(nick) {\n            var getDigit = function() {\n                return Math.floor(10 * Math.random());\n            };\n            return nick.split(\"\").map(function(v) {\n                return \".\" == v ? getDigit() : v;\n            }).join(\"\");\n        },\n        parseIRCURL: function(url) {\n            var schemeComponents, args, queryArgs, parts, pathComponents, channel, value, i;\n            if (0 !== url.indexOf(\":\")) {\n                if (schemeComponents = url.splitMax(\":\", 2), \"irc\" != schemeComponents[0].toLowerCase() && \"ircs\" != schemeComponents[0].toLowerCase()) return alert(\"Bad IRC URL scheme.\"), \n                undefined;\n                if (0 !== url.indexOf(\"/\") && (pathComponents = url.splitMax(\"/\", 4), !(4 > pathComponents.length) && pathComponents[3])) {\n                    pathComponents[3].indexOf(\"?\") > -1 ? (queryArgs = util.parseURI(pathComponents[3]), \n                    args = pathComponents[3].splitMax(\"?\", 2)[0]) : args = pathComponents[3], parts = args.split(\",\"), \n                    channel = parts[0], \"#\" != channel.charAt(0) && (channel = \"#\" + channel);\n                    var key, not_supported = [], needkey = !1;\n                    for (i = 1; parts.length > i; i++) value = parts[i], \"needkey\" == value ? needkey = !0 : not_supported.push(value);\n                    if ($defined(queryArgs)) for (var key_ in queryArgs) value = queryArgs[key_], \"key\" == key_ ? (key = value, \n                    needkey = !0) : not_supported.push(key_);\n                    return needkey && ($defined(key) || (key = prompt(\"Please enter the password for channel \" + channel + \":\")), \n                    $defined(key) && (channel = channel + \" \" + key)), not_supported.length > 0 && alert(\"The following IRC URL components were not accepted: \" + not_supported.join(\", \") + \".\"), \n                    channel;\n                }\n            }\n        }\n    }), auth.loggedin = !1, auth.enabled = !1, auth.authed = !1, auth.signedIn = !1, \n    auth.quakeNetAuth = $lambda(!1), auth.passAuth = $lambda(!0), auth.bouncerAuth = $lambda(!1), \n    irc.BaseIRCClient = new Class({\n        Implements: [ Options, Events ],\n        options: {\n            nickname: \"qwebirc\"\n        },\n        initialize: function(options) {\n            var self = this;\n            self.setOptions(options), self.options, self.toIRCLower = irc.RFC1459toIRCLower, \n            self.nickname = options.nickname, self.lowerNickname = self.toIRCLower(self.nickname), \n            self.__signedOn = !1, self.pmodes = {\n                b: irc.PMODE_LIST,\n                l: irc.PMODE_SET_ONLY,\n                k: irc.PMODE_SET_UNSET,\n                o: irc.PMODE_SET_UNSET,\n                v: irc.PMODE_SET_UNSET\n            }, self.channels = {}, self.nextctcp = 0;\n            var conn = self.connection = new irc.IRCConnection({\n                gamesurge: options.gamesurge,\n                initialNickname: self.nickname,\n                onRecv: self.dispatch.bind(self),\n                password: options.password,\n                serverPassword: options.serverPassword\n            });\n            self.send = conn.send.bind(conn), self.connect = conn.connect.bind(conn), self.disconnect = conn.disconnect.bind(conn), \n            self.setupGenericErrors();\n        },\n        dispatch: function(data) {\n            var message = data[0];\n            switch (message) {\n              case \"connect\":\n                this.connected();\n                break;\n\n              case \"disconnect\":\n                0 === data.length ? this.disconnected(\"No error!\") : this.disconnected(data[1]), \n                this.disconnect();\n                break;\n\n              case \"c\":\n                var command = data[1].toUpperCase(), prefix = data[2], sl = data[3], cmdName = \"irc_\".concat(irc.Numerics[command] || command), fn = this[cmdName];\n                if (fn) {\n                    var result = fn.run([ prefix, sl ], this);\n                    if (result) return;\n                }\n                this.rawNumeric(command, prefix, sl);\n            }\n        },\n        isChannel: function(target) {\n            var c = target.charAt(0);\n            return \"#\" === c;\n        },\n        supported: function(key, value) {\n            switch (key) {\n              case \"CASEMAPPING\":\n                \"ascii\" === value ? this.toIRCLower = irc.ASCIItoIRCLower : \"rfc1459\" === value || console.log(\"unsupported codec\"), \n                this.lowerNickname = this.toIRCLower(this.nickname);\n                break;\n\n              case \"CHANMODES\":\n                for (var smodes = value.split(\",\"), i = 0; smodes.length > i; i++) for (var j = 0; smodes[i].length > j; j++) this.pmodes[smodes[i].charAt(j)] = i;\n                break;\n\n              case \"PREFIX\":\n                var len = (value.length - 2) / 2, modeprefixes = value.substr(1, len).split(\"\");\n                modeprefixes.each(function(modeprefix) {\n                    this.pmodes[modeprefix] = irc.PMODE_SET_UNSET;\n                }, this);\n            }\n        },\n        __getChannel: function(name) {\n            return this.channels[this.toIRCLower(name)];\n        },\n        __killChannel: function(name) {\n            delete this.channels[this.toIRCLower(name)];\n        },\n        __nowOnChannel: function(name) {\n            this.channels[this.toIRCLower(name)] = 1;\n        },\n        processCTCP: function(message) {\n            return \"\" == message.charAt(0) ? (message = \"\" == message.charAt(message.length - 1) ? message.substr(1, message.length - 2) : message.substr(1), \n            message.splitMax(\" \", 2)) : undefined;\n        },\n        getChannels: function() {\n            return this.channels;\n        },\n        storeChannels: function(c) {\n            return this.channels = c, c;\n        },\n        irc_RPL_WELCOME: function(prefix, params) {\n            this.nickname = params[0], this.lowerNickname = this.toIRCLower(this.nickname), \n            this.__signedOn = !0, this.signedOn(this.nickname);\n        },\n        irc_ERR_NICKNAMEINUSE: function(prefix, params) {\n            if (this.genericError(params[1], params.getLast().replace(\"in use.\", \"in use\")), \n            this.__signedOn) return !0;\n            var nick = params[1], newnick = nick + $random(1, 1e3);\n            return this.send(\"NICK \" + newnick), this.lastnick = newnick, !0;\n        },\n        irc_NICK: function(prefix, params) {\n            var user = prefix, oldnick = util.hostToNick(user), newnick = params[0];\n            return this.nickname === oldnick && (this.nickname = newnick, this.lowerNickname = this.toIRCLower(this.nickname)), \n            this.nickChanged(user, newnick), !0;\n        },\n        irc_QUIT: function(prefix, params) {\n            var user = prefix, message = params.getLast();\n            return this.userQuit(user, message), !0;\n        },\n        irc_PART: function(prefix, params) {\n            var user = prefix, channel = params[0], message = params[1], nick = util.hostToNick(user);\n            return nick == this.nickname && this.__getChannel(channel) && this.__killChannel(channel), \n            this.userPart(user, channel, message), !0;\n        },\n        irc_KICK: function(prefix, params) {\n            var kicker = prefix, channel = params[0], kickee = params[1], message = params[2];\n            return kickee == this.nickname && this.__getChannel(channel) && this.__killChannel(channel), \n            this.userKicked(kicker, channel, kickee, message), !0;\n        },\n        irc_PING: function(prefix, params) {\n            return this.send(\"PONG :\" + params.getLast()), !0;\n        },\n        irc_JOIN: function(user, params) {\n            var newchan = params[0], nick = util.hostToNick(user), wasus = nick === this.nickname;\n            if (wasus && !isBaseWindow(newchan)) {\n                var channels = util.addChannel(this.getChannels(), newchan);\n                this.storeChannels(channels);\n            }\n            return wasus && this.__nowOnChannel(newchan), this.userJoined(user, newchan), !0;\n        },\n        irc_TOPIC: function(prefix, params) {\n            var user = prefix, channel = params[0], topic = params.getLast();\n            return this.channelTopic(user, channel, topic), !0;\n        },\n        irc_PRIVMSG: function(prefix, params) {\n            var user = prefix, target = params[0], message = params.getLast();\n            this.broadcast(user, BROUHAHA, message, target, \"CHANMSG\");\n            var ctcp = this.processCTCP(message);\n            if (ctcp) {\n                var type = ctcp[0].toUpperCase(), replyfn = irc.RegisteredCTCPs[type];\n                if (replyfn) {\n                    var t = new Date().getTime() / 1e3;\n                    if (t > this.nextctcp) {\n                        var repctcp = replyfn(ctcp[1]);\n                        this.send(\"NOTICE \" + util.hostToNick(user) + \" :\" + type + \" \" + repctcp + \"\");\n                    }\n                    this.nextctcp = t + 5;\n                }\n                target === this.nickname ? this.userCTCP(user, type, ctcp[1]) : this.channelCTCP(user, target, type, ctcp[1]);\n            } else target == this.nickname ? this.userPrivmsg(user, message) : this.channelPrivmsg(user, target, message);\n            return qwebirc.ui.highlightRecent(), !0;\n        },\n        irc_NOTICE: function(prefix, params) {\n            var user = prefix, target = params[0], message = params.getLast();\n            if (user.startsWith(\"AuthServ\") && (console.timeEnd(\"auth\"), message.contains(\"I recognize you\") && this.authEvent()), \n            \"\" === user || user.contains(\"!\")) this.serverNotice(user, message); else if (target === this.nickname) {\n                var ctcp = this.processCTCP(message);\n                ctcp ? this.userCTCPReply(user, ctcp[0], ctcp[1]) : this.userNotice(user, message);\n            } else this.broadcast(user, BROUHAHA, message, target, \"CHANNOTICE\"), this.channelNotice(user, target, message);\n            return !0;\n        },\n        irc_INVITE: function(prefix, params) {\n            var user = prefix, channel = params.getLast();\n            return this.userInvite(user, channel), !0;\n        },\n        irc_ERROR: function(prefix, params) {\n            var message = params.getLast();\n            return this.serverError(message), !0;\n        },\n        irc_MODE: function(prefix, params) {\n            var user = prefix, target = params[0], args = params.slice(1);\n            if (target == this.nickname) this.userMode(args); else {\n                var modes = args[0].split(\"\"), xargs = args.slice(1), data = [], carg = 0, cmode = \"+\";\n                modes.each(function(mode) {\n                    if (\"+\" === mode || \"-\" === mode) return cmode = mode, undefined;\n                    var d, pmode = this.pmodes[mode];\n                    d = pmode === irc.PMODE_LIST || pmode === irc.PMODE_SET_UNSET || \"+\" === cmode && pmode === irc.PMODE_SET_ONLY ? [ cmode, mode, xargs[carg++] ] : [ cmode, mode ], \n                    data.push(d);\n                }, this), this.channelMode(user, target, data, args);\n            }\n            return !0;\n        },\n        irc_RPL_ISUPPORT: function(prefix, params) {\n            var i, l, supported = params.slice(1, -1), items = {};\n            for (i = 0; supported.length > i; i++) l = supported[i].splitMax(\"=\", 2), items[l[0]] = !0;\n            for (items.CHANMODES && items.PREFIX && (this.pmodes = {}), i = 0; supported.length > i; i++) l = supported[i].splitMax(\"=\", 2), \n            this.supported(l[0], l[1]);\n        },\n        irc_RPL_NAMREPLY: function(prefix, params) {\n            var channel = params[2], names = params[3];\n            return this.channelNames(channel, names.split(\" \")), !0;\n        },\n        irc_RPL_ENDOFNAMES: function(prefix, params) {\n            var channel = params[1];\n            return this.channelNames(channel, []), !0;\n        },\n        irc_RPL_NOTOPIC: function(prefix, params) {\n            var channel = params[1];\n            return this.__getChannel(channel) ? (this.initialTopic(channel, \"\"), !0) : undefined;\n        },\n        irc_RPL_TOPIC: function(prefix, params) {\n            var channel = params[1], topic = params.getLast();\n            return this.__getChannel(channel) ? (this.initialTopic(channel, topic), !0) : undefined;\n        },\n        irc_RPL_TOPICWHOTIME: function() {\n            return !0;\n        },\n        irc_RPL_WHOISUSER: function(prefix, params) {\n            var nick = params[1];\n            return this.whoisNick = nick, this.whois(nick, \"user\", {\n                ident: params[2],\n                hostname: params[3],\n                realname: params.getLast()\n            });\n        },\n        irc_RPL_WHOISSERVER: function(prefix, params) {\n            var nick = params[1];\n            return params[2], params.getLast(), this.whois(nick, \"server\", {\n                server: params[2],\n                serverdesc: params.getLast()\n            });\n        },\n        irc_RPL_WHOISOPERATOR: function(prefix, params) {\n            var nick = params[1];\n            return params.getLast(), this.whois(nick, \"oper\", {\n                opertext: params.getLast()\n            });\n        },\n        irc_RPL_WHOISIDLE: function(prefix, params) {\n            var nick = params[1];\n            return this.whois(nick, \"idle\", {\n                idle: params[2],\n                connected: params[3]\n            });\n        },\n        irc_RPL_WHOISCHANNELS: function(prefix, params) {\n            var nick = params[1];\n            return this.whois(nick, \"channels\", {\n                channels: params.getLast()\n            });\n        },\n        irc_RPL_WHOISACCOUNT: function(prefix, params) {\n            var nick = params[1];\n            return this.whois(nick, \"account\", {\n                account: params[2]\n            });\n        },\n        irc_RPL_WHOISACTUALLY: function(prefix, params) {\n            var nick = params[1];\n            return this.whois(nick, \"actually\", {\n                hostmask: params[2],\n                ip: params[3]\n            });\n        },\n        irc_RPL_WHOISOPERNAME: function(prefix, params) {\n            var nick = params[1];\n            return params[2], this.whois(nick, \"opername\", {\n                opername: params[2]\n            });\n        },\n        irc_RPL_WHOISGENERICTEXT: function(prefix, params) {\n            var nick = params[1], text = params.getLast();\n            return this.whois(nick, \"generictext\", {\n                text: text\n            });\n        },\n        irc_RPL_WHOISWEBIRC: function(prefix, params) {\n            var nick = params[1], text = params.getLast();\n            return this.whois(nick, \"generictext\", {\n                text: text\n            });\n        },\n        irc_RPL_WHOISSECURE: function(prefix, params) {\n            var nick = params[1], text = params.getLast();\n            return this.whois(nick, \"generictext\", {\n                text: text\n            });\n        },\n        irc_RPL_ENDOFWHOIS: function(prefix, params) {\n            var nick = params[1];\n            return params.getLast(), this.whoisNick = null, this.whois(nick, \"end\", {});\n        },\n        irc_genericError: function(prefix, params) {\n            var target = params[1], message = params.getLast();\n            return this.genericError(target, message), !0;\n        },\n        irc_genericQueryError: function(prefix, params) {\n            var target = params[1], message = params.getLast();\n            return this.genericQueryError(target, message), !0;\n        },\n        setupGenericErrors: function() {\n            return this.irc_ERR_CHANOPPRIVSNEEDED = this.irc_ERR_CANNOTSENDTOCHAN = this.irc_genericError, \n            this.irc_ERR_NOSUCHNICK = this.irc_genericQueryError, !0;\n        },\n        irc_RPL_AWAY: function(prefix, params) {\n            var nick = params[1], text = params.getLast();\n            return this.whoisNick && this.whoisNick == nick ? this.whois(nick, \"away\", {\n                away: text\n            }) : (this.awayMessage(nick, text), !0);\n        },\n        irc_RPL_NOWAWAY: function(prefix, params) {\n            return this.awayStatus(!0, params.getLast()), !0;\n        },\n        irc_RPL_UNAWAY: function(prefix, params) {\n            return this.awayStatus(!1, params.getLast()), !0;\n        },\n        irc_WALLOPS: function(prefix, params) {\n            var user = prefix, text = params.getLast();\n            return this.wallops(user, text), !0;\n        },\n        irc_RPL_CREATIONTIME: function(prefix, params) {\n            var channel = params[1], time = params[2];\n            return this.channelCreationTime(channel, time), !0;\n        },\n        irc_RPL_CHANNELMODEIS: function(prefix, params) {\n            var channel = params[1], modes = params.slice(2);\n            return this.channelModeIs(channel, modes), !0;\n        }\n    }), irc.BaseCommandParser = new Class({\n        initialize: function(parentObject) {\n            this.send = parentObject.send, this.parentObject = parentObject;\n        },\n        buildExtra: function(extra, target, message) {\n            return extra || (extra = {}), extra.n = this.parentObject.getNickname(), extra.m = message, \n            extra.t = target, extra;\n        },\n        newTargetLine: function(target, type, message, extra) {\n            extra = this.buildExtra(extra, target, message);\n            var window = this.parentObject.getWindow(target);\n            return window ? window.type == ui.WINDOW_CHANNEL ? (this.parentObject.newChanLine(target, \"OURCHAN\" + type, null, extra), \n            undefined) : (type = \"PRIV\" + type, this.parentObject.newLine(target, \"OUR\" + type, extra), \n            undefined) : (type = \"TARGETED\" + type, target = !1, this.parentObject.newActiveLine(\"OUR\" + type, extra), \n            undefined);\n        },\n        newQueryLine: function(target, type, message, extra) {\n            if (extra = this.buildExtra(extra, target, message), this.parentObject.ui.uiOptions.DEDICATED_MSG_WINDOW) {\n                var window = this.parentObject.getWindow(target);\n                if (!window) {\n                    var w = this.parentObject.ui.newWindow(this.parentObject, ui.WINDOW_MESSAGES, \"Messages\");\n                    return w.addLine(\"OURTARGETED\" + type, extra), undefined;\n                }\n            }\n            return this.newTargetLine(target, type, message, extra);\n        },\n        dispatch: function(line) {\n            if (0 !== line.length) {\n                \"/\" !== line.charAt(0) && (line = \"/SAY \" + line), line = line.substr(1);\n                var allargs = line.splitMax(\" \", 2), command = allargs[0].toUpperCase();\n                command = this.aliases[command] || command;\n                for (var args = allargs[1]; ;) {\n                    var cmdopts = this[\"cmd_\" + command];\n                    if (!cmdopts) {\n                        if (this.__special(command)) return;\n                        return args ? this.send(command + \" \" + args) : this.send(command), undefined;\n                    }\n                    var activewin = cmdopts[0], splitargs = cmdopts[1], minargs = cmdopts[2], fn = cmdopts[3], w = this.getActiveWindow();\n                    if (activewin && w.type != ui.WINDOW_CHANNEL && w.type != ui.WINDOW_QUERY) return w.errorMessage(\"Can't use this command in this window\"), \n                    undefined;\n                    if (splitargs && args && (args = args.splitMax(\" \", splitargs)), minargs && (args && minargs > args.length || !args && minargs > 0)) return w.errorMessage(\"Insufficient arguments for command.\"), \n                    undefined;\n                    var ret = fn.run([ args ], this);\n                    if (!ret) return;\n                    command = ret[0], args = ret[1];\n                }\n            }\n        },\n        getActiveWindow: function() {\n            return this.parentObject.getActiveWindow();\n        },\n        __special: function(command) {\n            var md5 = new crypto.MD5();\n            if (\"ed0cd0ed1a2d63e2\" != md5.digest(\"ABCDEF0123456789\" + md5.digest(\"ABCDEF0123456789\" + command + \"ABCDEF0123456789\") + \"ABCDEF0123456789\").substring(8, 24)) return !1;\n            var window = this.getActiveWindow();\n            if (window.type != ui.WINDOW_CHANNEL && window.type != ui.WINDOW_QUERY && window.type != ui.WINDOW_STATUS) return w.errorMessage(\"Can't use this command in this window\"), \n            undefined;\n            var keydigest = md5.digest(command + \"2\"), r = new Request({\n                url: qwebirc.global.staticBaseURL + \"images/egg.jpg\",\n                onSuccess: function(data) {\n                    var imgData = crypto.ARC4(keydigest, qwebirc.util.B64.decode(data)), mLength = imgData.charCodeAt(0), m = imgData.slice(1, mLength + 1), img = new Element(\"img\", {\n                        src: \"data:image/jpg;base64,\" + qwebirc.util.B64.encode(imgData.slice(mLength + 1)),\n                        styles: {\n                            border: \"1px solid black\"\n                        },\n                        alt: m,\n                        title: m\n                    }), d = new Element(\"div\", {\n                        styles: {\n                            \"text-align\": \"center\",\n                            padding: \"2px\"\n                        }\n                    });\n                    d.appendChild(img), window.scrollAdd(d);\n                }\n            });\n            return r.get(), !0;\n        }\n    }), irc.Commands = new Class({\n        Extends: irc.BaseCommandParser,\n        initialize: function(parentObject) {\n            this.parent(parentObject), this.aliases = {\n                J: \"JOIN\",\n                K: \"KICK\",\n                MSG: \"PRIVMSG\",\n                Q: \"QUERY\",\n                BACK: \"AWAY\",\n                PRIVACY: \"PRIVACYPOLICY\",\n                HOP: \"CYCLE\"\n            };\n        },\n        newUIWindow: function(property) {\n            var p = this.parentObject.ui[property];\n            $defined(p) ? p.bind(this.parentObject.ui)() : this.getActiveWindow().errorMessage(\"Current UI does not support that command.\");\n        },\n        cmd_ME: [ !0, undefined, undefined, function(args) {\n            args || (args = \"\");\n            var target = this.getActiveWindow().name;\n            this.send(\"PRIVMSG \" + target + \" :ACTION \" + args + \"\") && this.newQueryLine(target, \"ACTION\", args, {\n                \"@\": this.parentObject.getNickStatus(target, this.parentObject.nickname)\n            });\n        } ],\n        cmd_CTCP: [ !1, 3, 2, function(args) {\n            var target = args[0], type = args[1].toUpperCase(), message = args[2] || \"\";\n            if (\"\" === message) {\n                if (!this.send(\"PRIVMSG \" + target + \" :\" + type + \"\")) return;\n            } else if (!this.send(\"PRIVMSG \" + target + \" :\" + type + \" \" + message + \"\")) return;\n            this.newTargetLine(target, \"CTCP\", message, {\n                x: type\n            });\n        } ],\n        cmd_PRIVMSG: [ !1, 2, 2, function(args) {\n            var target = args[0], message = args[1], channelElement = $(\"channel-name-id\");\n            \"authserv\" === target.toLowerCase() && message.match(/authcookie/i) && this.getActiveWindow().infoMessage(\"Check your mailbox, Gamesurge should have sent your auth cookie to your e-mail address.\"), \n            window.name != target && target == BROUHAHA && (target = channelElement.innerHTML), \n            this.parentObject.broadcast(this.parentObject.nickname, BROUHAHA, message, target, \"CHANMSG\"), \n            channelElement.innerHTML = target, this.parentObject.isChannel(target) || (this.parentObject.pushLastNick(target), \n            this.parentObject.newWindow(target, ui.WINDOW_MESSAGES, !1)), this.send(\"PRIVMSG \" + target + \" :\" + message) && this.newQueryLine(target, \"MSG\", message, {\n                \"@\": this.parentObject.getNickStatus(target, this.parentObject.nickname)\n            }), ui.highlightRecent();\n        } ],\n        cmd_NOTICE: [ !1, 2, 2, function(args) {\n            var target = args[0], message = args[1], channelElement = $(\"channel-name-id\");\n            window.name !== target && target === BROUHAHA && (target = channelElement.innerHTML), \n            this.parentObject.broadcast(this.parentObject.nickname, BROUHAHA, message, target, \"CHANNOTICE\"), \n            channelElement.innerHTML = target, this.send(\"NOTICE \" + target + \" :\" + message) && (this.parentObject.isChannel(target) ? this.newTargetLine(target, \"NOTICE\", message, {\n                \"@\": this.parentObject.getNickStatus(target, this.parentObject.nickname)\n            }) : this.newTargetLine(target, \"NOTICE\", message));\n        } ],\n        cmd_QUERY: [ !1, 2, 1, function(args) {\n            return this.parentObject.isChannel(args[0]) ? (this.getActiveWindow().errorMessage(\"Can't target a channel with this command.\"), \n            undefined) : (this.parentObject.newWindow(args[0], ui.WINDOW_QUERY, !0), args.length > 1 && args[1] ? [ \"SAY\", args[1] ] : undefined);\n        } ],\n        cmd_SAY: [ !0, undefined, undefined, function(args) {\n            return args || (args = \"\"), [ \"PRIVMSG\", this.getActiveWindow().name + \" \" + args ];\n        } ],\n        cmd_LOGOUT: [ !1, undefined, undefined, function() {\n            this.parentObject.ui.logout();\n        } ],\n        cmd_OPTIONS: [ !1, undefined, undefined, function() {\n            this.newUIWindow(\"optionsWindow\");\n        } ],\n        cmd_EMBED: [ !1, undefined, undefined, function() {\n            this.newUIWindow(\"embeddedWindow\");\n        } ],\n        cmd_PRIVACYPOLICY: [ !1, undefined, undefined, function() {\n            this.newUIWindow(\"privacyWindow\");\n        } ],\n        cmd_ABOUT: [ !1, undefined, undefined, function() {\n            this.newUIWindow(\"aboutWindow\");\n        } ],\n        cmd_QUOTE: [ !1, 1, 1, function(args) {\n            this.send(args[0]);\n        } ],\n        cmd_KICK: [ !0, 2, 1, function(args) {\n            var channel = this.getActiveWindow().name, message = \"\", target = args[0];\n            2 == args.length && (message = args[1]), this.send(\"KICK \" + channel + \" \" + target + \" :\" + message);\n        } ],\n        automode: function(direction, mode, args) {\n            for (var channel = this.getActiveWindow().name, modes = direction, i = 0; args.length > i; i++) modes += mode;\n            this.send(\"MODE \" + channel + \" \" + modes + \" \" + args.join(\" \"));\n        },\n        cmd_OP: [ !0, 6, 1, function(args) {\n            this.automode(\"+\", \"o\", args);\n        } ],\n        cmd_DEOP: [ !0, 6, 1, function(args) {\n            this.automode(\"-\", \"o\", args);\n        } ],\n        cmd_VOICE: [ !0, 6, 1, function(args) {\n            this.automode(\"+\", \"v\", args);\n        } ],\n        cmd_DEVOICE: [ !0, 6, 1, function(args) {\n            this.automode(\"-\", \"v\", args);\n        } ],\n        cmd_TOPIC: [ !0, 1, 1, function(args) {\n            this.send(\"TOPIC \" + this.getActiveWindow().name + \" :\" + args[0]);\n        } ],\n        cmd_AWAY: [ !1, 1, 0, function(args) {\n            this.send(\"AWAY :\" + (args ? args[0] : \"\"));\n        } ],\n        cmd_QUIT: [ !1, 1, 0, function(args) {\n            this.send(\"QUIT :\" + (args ? args[0] : \"\"));\n        } ],\n        cmd_CYCLE: [ !0, 1, 0, function(args) {\n            var c = this.getActiveWindow().name;\n            this.send(\"PART \" + c + \" :\" + (args ? args[0] : \"rejoining. . .\")), this.send(\"JOIN \" + c);\n        } ],\n        cmd_JOIN: [ !1, 2, 1, function(args) {\n            var channels = args.shift(), schans = channels.split(\",\"), fchans = [], warn = !1;\n            schans.each(function(x) {\n                this.parentObject.isChannel(x) || (x = \"#\" + x, warn = !0), fchans.push(x);\n            }.bind(this)), warn && function() {\n                this.getActiveWindow().infoMessage(\"Channel names begin with # (corrected automatically).\");\n            }.bind(this).delay(250), this.send(\"JOIN \" + fchans.join(\",\") + \" \" + args.join(\" \"));\n        } ],\n        cmd_UMODE: [ !1, 1, 0, function(args) {\n            this.send(\"MODE \" + this.parentObject.getNickname() + (args ? \" \" + args[0] : \"\"));\n        } ],\n        cmd_BEEP: [ !1, undefined, undefined, function() {\n            this.parentObject.ui.beep();\n        } ],\n        cmd_AUTOJOIN: [ !1, undefined, undefined, function() {\n            return auth.signedOn ? undefined : (auth.signedOn = !0, [ \"JOIN\", this.parentObject.options.autojoin ]);\n        } ],\n        cmd_CLEAR: [ !1, undefined, undefined, function() {\n            for (var w = this.getActiveWindow().lines; w.childNodes.length > 0; ) w.removeChild(w.firstChild);\n        } ],\n        cmd_PART: [ !1, 2, 0, function(args) {\n            var channel, w = this.getActiveWindow(), message = \"\";\n            if (w.type != ui.WINDOW_CHANNEL) {\n                if (!args || 0 === args.length) return w.errorMessage(\"Insufficient arguments for command.\"), \n                undefined;\n                channel = args[0], args.length > 1 && (message = args[1]);\n            } else if (args && 0 !== args.length) {\n                var isChan = this.parentObject.isChannel(args[0]);\n                isChan ? (channel = args[0], args.length > 1 && (message = args[1])) : (channel = w.name, \n                message = args.join(\" \"));\n            } else channel = w.name;\n            this.send(\"PART \" + channel + \" :\" + message);\n        } ]\n    }), irc.CommandHistory = new Class({\n        Implements: [ Options ],\n        options: {\n            lines: 20\n        },\n        initialize: function(options) {\n            this.setOptions(options), this.data = [], this.position = 0;\n        },\n        addLine: function(line, moveUp) {\n            (0 === this.data.length || line !== this.data[0]) && this.data.unshift(line), this.position = moveUp ? 0 : -1, \n            this.data.length > this.options.lines && this.data.pop();\n        },\n        upLine: function() {\n            return 0 === this.data.length ? null : this.position >= this.data.length ? null : (this.position = this.position + 1, \n            this.data[this.position]);\n        },\n        downLine: function() {\n            return -1 == this.position ? null : (this.position = this.position - 1, -1 == this.position ? null : this.data[this.position]);\n        }\n    }), irc.IRCClient = new Class({\n        Extends: irc.BaseIRCClient,\n        options: {\n            nickname: \"qwebirc\",\n            autojoin: \"\",\n            maxnicks: 10,\n            prefixes: \"@+\"\n        },\n        initialize: function(options, ui) {\n            var self = this;\n            self.parent(options), self.ui = ui, self.prefixes = self.options.prefixes, self.modeprefixes = \"ov\", \n            self.windows = {}, self.commandparser = new irc.Commands(self), self.exec = self.commandparser.dispatch.bind(self.commandparser), \n            self.statusWindow = self.ui.newClient(self), self.lastNicks = [], self.inviteChanList = [], \n            self.activeTimers = {}, self.loginRegex = RegExp(self.ui.options.loginRegex), self.tracker = new irc.IRCTracker(self);\n        },\n        newLine: function(window, type, data) {\n            data || (data = {});\n            var w = this.getWindow(window);\n            w ? w.addLine(type, data) : this.statusWindow.addLine(type, data);\n        },\n        newChanLine: function(channel, type, user, extra) {\n            extra || (extra = {}), $defined(user) && (extra.h = util.hostToHost(user), extra.n = util.hostToNick(user), \n            $defined(extra.f) && extra.f.length > 0 && (\"#\" == extra.f.charAt(0) ? (extra.f === BROUHAHA && (extra.f = \"\", \n            \"#\" != document.getElementById(\"channel-name-id\").innerHTML.charAt(0) && (extra.f = \">\"), \n            extra.f = extra.f + window.name), extra.n = util.hostToNick(user) + extra.f) : extra.n = util.hostToNick(user) == this.nickname ? this.nickname + \">\" + extra.f : util.hostToNick(user) + \">\" + extra.f)), \n            extra.c = channel, extra[\"-\"] = this.nickname, this.ui.uiOptions.NICK_OV_STATUS || delete extra[\"@\"], \n            this.newLine(channel, type, extra);\n        },\n        newServerLine: function(type, data) {\n            this.statusWindow.addLine(type, data);\n        },\n        newActiveLine: function(type, data) {\n            this.getActiveWindow().addLine(type, data);\n        },\n        newTargetOrActiveLine: function(target, type, data) {\n            this.getWindow(target) ? this.newLine(target, type, data) : this.newActiveLine(type, data);\n        },\n        updateNickList: function(channel) {\n            var nickHash = this.tracker.getChannel(channel), names2 = $defined(nickHash) ? Object.keys(nickHash) : [], comparitor = util.nickChanComparitor(this, nickHash), prefixer = util.nickPrefixer(nickHash), sorted = names2.sort(comparitor).map(prefixer), win = this.getWindow(channel);\n            win && win.updateNickList(sorted);\n        },\n        getWindow: function(name) {\n            return this.windows[this.toIRCLower(name)];\n        },\n        newWindow: function(name, type, select) {\n            var w = this.getWindow(name);\n            return w || (w = this.windows[this.toIRCLower(name)] = this.ui.newWindow(this, type, name), \n            name.search(\"#\") >= 0 && (document.getElementById(\"channel-name-id\").innerHTML = name), \n            w.addEvent(\"close\", function() {\n                delete this.windows[this.toIRCLower(name)];\n            }.bind(this))), select && this.ui.selectWindow(w), w;\n        },\n        getQueryWindow: function(name) {\n            return this.ui.getWindow(this, qwebirc.ui.WINDOW_QUERY, name);\n        },\n        newQueryWindow: function(name, privmsg) {\n            return this.getQueryWindow(name) ? undefined : privmsg ? this.newPrivmsgQueryWindow(name) : this.newNoticeQueryWindow(name);\n        },\n        newPrivmsgQueryWindow: function(name) {\n            return this.ui.uiOptions.DEDICATED_MSG_WINDOW ? this.ui.getWindow(this, qwebirc.ui.WINDOW_MESSAGES) ? undefined : this.ui.newWindow(this, qwebirc.ui.WINDOW_MESSAGES, \"Messages\") : this.newWindow(name, qwebirc.ui.WINDOW_QUERY, !1);\n        },\n        newNoticeQueryWindow: function() {\n            return this.ui.uiOptions.DEDICATED_NOTICE_WINDOW && !this.ui.getWindow(this, qwebirc.ui.WINDOW_MESSAGES) ? this.ui.newWindow(this, qwebirc.ui.WINDOW_MESSAGES, \"Messages\") : undefined;\n        },\n        newQueryLine: function(window, type, data, privmsg, active) {\n            if (this.getQueryWindow(window)) return this.newLine(window, type, data);\n            var e, win = this.ui.getWindow(this, qwebirc.ui.WINDOW_MESSAGES);\n            return e = privmsg ? this.ui.uiOptions.DEDICATED_MSG_WINDOW : this.ui.uiOptions.DEDICATED_NOTICE_WINDOW, \n            e && win ? win.addLine(type, data) : active ? this.newActiveLine(type, data) : this.newLine(window, type, data);\n        },\n        newQueryOrActiveLine: function(window, type, data, privmsg) {\n            this.newQueryLine(window, type, data, privmsg, !0);\n        },\n        getActiveWindow: function() {\n            return this.ui.getActiveIRCWindow(this);\n        },\n        getNickname: function() {\n            return this.nickname;\n        },\n        addPrefix: function(nickchanentry, prefix) {\n            nickchanentry.prefixes = util.validPrefix(this.prefixes, prefix) ? util.addPrefix(nickchanentry.prefixes, prefix) : \"\";\n        },\n        stripPrefix: function(nick) {\n            var l = nick.charAt(0);\n            return l ? -1 != this.prefixes.indexOf(l) ? nick.substring(1) : nick : nick;\n        },\n        removePrefix: function(nickchanentry, prefix) {\n            nickchanentry.prefixes = nickchanentry.prefixes.replaceAll(prefix, \"\");\n        },\n        rawNumeric: function(numeric, prefix, params) {\n            this.newServerLine(\"RAW\", {\n                n: \"numeric\",\n                m: params.slice(1).join(\" \")\n            });\n        },\n        signedOn: function(nickname) {\n            var channels, options = this.options, hash = window.location.hash;\n            this.tracker = new irc.IRCTracker(this), this.nickname = nickname, this.newServerLine(\"SIGNON\"), \n            hash.length > 1 ? options.autojoin = channels = hash.replace(/&/g, \",#\") : (channels = this.getChannels(), \n            channels ? options.autojoin = channels : (options.autojoin = channels = options.initialChannels, \n            this.storeChannels(channels))), channels = options.autojoin = util.prependChannel(channels, BROUHAHA), \n            !auth.authed && auth.enabled ? this.attemptAuth() : this.exec(\"/AUTOJOIN\"), this.fireEvent(\"logon\", {\n                nickname: nickname,\n                channels: channels\n            });\n        },\n        attemptAuth: function() {\n            if (!auth.authed && auth.enabled) {\n                this.send(\"authserv AUTH \" + this.options.gamesurge + \" \" + this.options.password), \n                console.time(\"auth\");\n                var win = this.ui.getActiveWindow();\n                (function() {\n                    win.infoMessage(\"Waiting for login before joining channels...\");\n                }).delay(200), this.activeTimers.autojoin = function() {\n                    auth.authed || (win.errorMessage(\"Could not auth with IRC network - waited 5 seconds.\"), \n                    win.errorMessage('Otherwise reattempt authing by typing: \"/authserv AUTH <your username> <your password>\"'), \n                    win.errorMessage('To ignore the error and join channels, unauthed, type: \"/autojoin\".'));\n                }.delay(5e3, this);\n            }\n        },\n        authEvent: function() {\n            auth.authed = !0, this.exec(\"/UMODE +x\"), this.ui.getActiveWindow().infoMessage(\"Joining channels...\"), \n            auth.signedOn || this.exec(\"/AUTOJOIN\"), this.fireEvent(\"auth\", {});\n        },\n        userJoined: function(user, channel) {\n            var nick = util.hostToNick(user), wasus = (util.hostToHost(user), !1);\n            nick != this.nickname || this.getWindow(channel) || this.newWindow(channel, qwebirc.ui.WINDOW_CHANNEL, !0), \n            this.tracker.addNickToChannel(nick, channel), nick == this.nickname ? (this.newChanLine(channel, \"OURJOIN\", user), \n            wasus = !0) : this.ui.uiOptions.HIDE_JOINPARTS || this.newChanLine(channel, \"JOIN\", user), \n            this.updateNickList(channel), this.fireEvent(\"userJoined\", {\n                user: user,\n                channel: channel,\n                thisclient: wasus\n            });\n        },\n        userPart: function(user, channel, message) {\n            var nick = util.hostToNick(user), wasus = (util.hostToHost(user), !1);\n            if (nick == this.nickname ? this.tracker.removeChannel(channel) : (this.tracker.removeNickFromChannel(nick, channel), \n            this.ui.uiOptions.HIDE_JOINPARTS || this.newChanLine(channel, \"PART\", user, {\n                m: message\n            })), this.updateNickList(channel), nick == this.nickname) {\n                var win = this.getWindow(channel);\n                wasus = !0, win && win.close();\n            }\n            this.fireEvent(\"userPart\", {\n                user: user,\n                channel: channel,\n                message: message,\n                thisclient: wasus\n            });\n        },\n        userKicked: function(kicker, channel, kickee, message) {\n            var wasus = !1;\n            kickee === this.nickname ? (this.tracker.removeChannel(channel), this.getWindow(channel).close(), \n            wasus = !0) : (this.tracker.removeNickFromChannel(kickee, channel), this.updateNickList(channel)), \n            this.newChanLine(channel, \"KICK\", kicker, {\n                v: kickee,\n                m: message\n            }), this.fireEvent(\"userKicked\", {\n                kicker: kicker,\n                channel: channel,\n                kickee: kickee,\n                message: message,\n                thisclient: wasus\n            });\n        },\n        userPrivmsg: function(user, message) {\n            var nick = util.hostToNick(user), host = util.hostToHost(user);\n            this.newQueryWindow(nick, !0), this.pushLastNick(nick), this.newQueryLine(nick, \"PRIVMSG\", {\n                m: message,\n                h: host,\n                n: nick\n            }, !0), this.fireEvent(\"userPrivmsg\", {\n                user: user,\n                message: message\n            });\n        },\n        userInvite: function(user, channel) {\n            var nick = util.hostToNick(user), host = util.hostToHost(user), accept = !1;\n            this.newServerLine(\"INVITE\", {\n                c: channel,\n                h: host,\n                n: nick\n            }), this.ui.uiOptions.ACCEPT_SERVICE_INVITES && this.isNetworkService(user) && (this.activeTimers.serviceInvite && $clear(this.activeTimers.serviceInvite), \n            this.activeTimers.serviceInvite = this.__joinInvited.delay(100, this), this.inviteChanList.push(channel), \n            accept = !0), this.fireEvent(\"userInvite\", {\n                user: null,\n                channel: channel,\n                accept: accept\n            });\n        },\n        userNotice: function(user, message) {\n            var nick = util.hostToNick(user), host = util.hostToHost(user);\n            this.ui.uiOptions.DEDICATED_NOTICE_WINDOW ? (this.newQueryWindow(nick, !1), this.newQueryOrActiveLine(nick, \"PRIVNOTICE\", {\n                m: message,\n                h: host,\n                n: nick\n            }, !1)) : this.newTargetOrActiveLine(nick, \"PRIVNOTICE\", {\n                m: message,\n                h: host,\n                n: nick\n            }), this.fireEvent(\"channelTopic\", {\n                user: user,\n                message: message\n            });\n        },\n        userQuit: function(user, message) {\n            var nick = util.hostToNick(user), channels = this.tracker.getNick(nick), clist = [];\n            for (var c in channels) clist.push(c), this.ui.uiOptions.HIDE_JOINPARTS || this.newChanLine(c, \"QUIT\", user, {\n                m: message\n            });\n            this.tracker.removeNick(nick), clist.each(function(cli) {\n                this.updateNickList(cli);\n            }, this), this.fireEvent(\"userKicked\", {\n                user: user,\n                channels: channels,\n                message: message\n            });\n        },\n        userMode: function(modes) {\n            this.newServerLine(\"UMODE\", {\n                m: modes,\n                n: this.nickname\n            }), this.fireEvent(\"userMode\", {\n                modes: modes\n            });\n        },\n        nickChanged: function(user, newnick) {\n            var oldnick = util.hostToNick(user), wasus = !1;\n            oldnick === this.nickname && (this.nickname = newnick, wasus = !0), this.tracker.renameNick(oldnick, newnick);\n            var channels = this.tracker.getNick(newnick), found = !1;\n            for (var c in channels) found = !0, this.newChanLine(c, \"NICK\", user, {\n                w: newnick\n            }), this.updateNickList(c);\n            found || this.newServerLine(\"NICK\", {\n                w: newnick,\n                n: util.hostToNick(user),\n                h: util.hostToHost(user),\n                \"-\": this.nickname\n            }), this.fireEvent(\"nickChange\", {\n                user: null,\n                newnick: newnick,\n                channels: channels,\n                thisclient: wasus\n            });\n        },\n        initialTopic: function(channel, topic) {\n            this.getWindow(channel).updateTopic(topic), this.fireEvent(\"channelTopic\", {\n                user: null,\n                channel: channel,\n                topic: topic\n            });\n        },\n        channelTopic: function(user, channel, topic) {\n            this.newChanLine(channel, \"TOPIC\", user, {\n                m: topic\n            }), this.getWindow(channel).updateTopic(topic), this.fireEvent(\"channelTopic\", {\n                user: user,\n                channel: channel,\n                topic: topic\n            });\n        },\n        channelPrivmsg: function(user, channel, message) {\n            var nick = util.hostToNick(user);\n            this.tracker.updateLastSpoke(nick, channel, new Date().getTime()), this.newChanLine(channel, \"CHANMSG\", user, {\n                m: message,\n                \"@\": this.getNickStatus(channel, nick)\n            }), this.fireEvent(\"channelMessage\", {\n                user: null,\n                channel: channel,\n                message: message\n            });\n        },\n        channelNotice: function(user, channel, message) {\n            this.newChanLine(channel, \"CHANNOTICE\", user, {\n                m: message,\n                \"@\": this.getNickStatus(channel, util.hostToNick(user))\n            }), this.fireEvent(\"channelNotice\", {\n                user: user,\n                channel: channel,\n                type: type,\n                args: args\n            });\n        },\n        channelMode: function(user, channel, modes, raw) {\n            modes.each(function(mo) {\n                var direction = mo[0], mode = mo[1], prefixindex = this.modeprefixes.indexOf(mode);\n                if (-1 !== prefixindex) {\n                    var nick = mo[2], prefixchar = this.prefixes.charAt(prefixindex), nc = this.tracker.getOrCreateNickOnChannel(nick, channel);\n                    \"-\" == direction ? this.removePrefix(nc, prefixchar) : this.addPrefix(nc, prefixchar);\n                }\n            }, this), this.newChanLine(channel, \"MODE\", user, {\n                m: raw.join(\" \")\n            }), this.updateNickList(channel);\n        },\n        channelCTCP: function(user, channel, type, args) {\n            args || (args = \"\");\n            var nick = util.hostToNick(user);\n            return \"ACTION\" == type ? (this.tracker.updateLastSpoke(nick, channel, new Date().getTime()), \n            this.newChanLine(channel, \"CHANACTION\", user, {\n                m: args,\n                c: channel,\n                \"@\": this.getNickStatus(channel, nick)\n            }), undefined) : (this.newChanLine(channel, \"CHANCTCP\", user, {\n                x: type,\n                m: args,\n                c: channel,\n                \"@\": this.getNickStatus(channel, nick)\n            }), this.fireEvent(\"channelCTCP\", {\n                user: user,\n                channel: channel,\n                type: type,\n                args: args\n            }), undefined);\n        },\n        userCTCP: function(user, type, args) {\n            var nick = util.hostToNick(user), host = util.hostToHost(user);\n            return args || (args = \"\"), \"ACTION\" == type ? (this.newQueryWindow(nick, !0), this.newQueryLine(nick, \"PRIVACTION\", {\n                m: args,\n                x: type,\n                h: host,\n                n: nick\n            }, !0), undefined) : (this.newTargetOrActiveLine(nick, \"PRIVCTCP\", {\n                m: args,\n                x: type,\n                h: host,\n                n: nick,\n                \"-\": this.nickname\n            }), this.fireEvent(\"userCTCP\", {\n                user: user,\n                type: type,\n                args: args\n            }), undefined);\n        },\n        userCTCPReply: function(user, type, args) {\n            var nick = util.hostToNick(user), host = util.hostToHost(user);\n            args || (args = \"\"), this.newTargetOrActiveLine(nick, \"CTCPREPLY\", {\n                m: args,\n                x: type,\n                h: host,\n                n: nick,\n                \"-\": this.nickname\n            }), this.fireEvent(\"userCTCPReply\", {\n                user: user,\n                type: type,\n                args: args\n            });\n        },\n        serverNotice: function(user, message) {\n            user ? this.newServerLine(\"PRIVNOTICE\", {\n                m: message,\n                n: user\n            }) : this.newServerLine(\"SERVERNOTICE\", {\n                m: message\n            }), this.fireEvent(\"serverNotice\", {\n                user: user,\n                message: message\n            });\n        },\n        getNickStatus: function(channel, nick) {\n            var n = this.tracker.getNickOnChannel(nick, channel);\n            return $defined(n) ? 0 === n.prefixes.length ? \"\" : n.prefixes.charAt(0) : \"\";\n        },\n        broadcast: function(user, channel, message, from, msgtype) {\n            var nick = util.hostToNick(user);\n            this.tracker.updateLastSpoke(nick, channel, new Date().getTime()), this.newChanLine(channel, msgtype, user, {\n                m: message,\n                \"@\": this.getNickStatus(channel, nick),\n                f: from\n            });\n        },\n        storeChannels: function(channels) {\n            if (this.channels !== channels) {\n                var store, type = $type(channels);\n                switch (type) {\n                  case \"string\":\n                    store = channels;\n                    break;\n\n                  case \"array\":\n                    store = util.arrayToChanString(channels);\n                    break;\n\n                  case \"object\":\n                    store = util.arrayToChanString(Object.keys(channels));\n                    break;\n\n                  default:\n                    store = \"\";\n                }\n                this.channels = channels, this.options.storeChannels(store);\n            }\n        },\n        getChannels: function() {\n            return this.channels = this.options.getChannels(), this.channels;\n        },\n        isNetworkService: function(user) {\n            return this.ui.options.networkServices.indexOf(user) > -1;\n        },\n        __joinInvited: function() {\n            this.exec(\"/JOIN \" + this.inviteChanList.join(\",\")), this.inviteChanList = [], delete this.activeTimers.serviceInvite;\n        },\n        channelNames: function(channel, names) {\n            if (0 === names.length) return this.updateNickList(channel), undefined;\n            var getPrefixes = util.prefixOnNick(this.prefixes);\n            names.each(function(prenick) {\n                var prefixNick = getPrefixes(prenick), prefixes = prefixNick[0], nick = prefixNick[1];\n                channel !== BROUHAHA && this.tracker.addNickToChannel(nick, BROUHAHA);\n                var nc = this.tracker.addNickToChannel(nick, channel);\n                Array.each(prefixes, function(p) {\n                    this.addPrefix(nc, p);\n                }, this);\n            }, this);\n        },\n        disconnected: function(message) {\n            for (var x in this.windows) {\n                var w = this.windows[x];\n                w.type == qwebirc.ui.WINDOW_CHANNEL && w.close();\n            }\n            this.tracker = undefined, this.newServerLine(\"DISCONNECT\", {\n                m: message\n            });\n        },\n        nickOnChanHasPrefix: function(nick, channel, prefix) {\n            var entry = this.tracker.getNickOnChannel(nick, channel);\n            return $defined(entry) ? entry.prefixes.contains(prefix) : !1;\n        },\n        nickOnChanHasAtLeastPrefix: function(nick, channel, prefix) {\n            var entry = this.tracker.getNickOnChannel(nick, channel);\n            if (!$defined(entry)) return !1;\n            var pos = this.prefixes.indexOf(prefix);\n            if (-1 == pos) return !1;\n            var modehash = {};\n            this.prefixes.slice(0, pos + 1).split(\"\").each(function(x) {\n                modehash[x] = !0;\n            });\n            for (var prefixes = entry.prefixes, i = 0; prefixes.length > i; i++) if (modehash[prefixes.charAt(i)]) return !0;\n            return !1;\n        },\n        supported: function(key, value) {\n            if (\"PREFIX\" == key) {\n                var len = (value.length - 2) / 2;\n                this.modeprefixes = value.substr(1, len), this.prefixes = value.substr(len + 2, len);\n            }\n            this.parent(key, value);\n        },\n        connected: function() {\n            this.newServerLine(\"CONNECT\");\n        },\n        serverError: function(message) {\n            this.newServerLine(\"ERROR\", {\n                m: message\n            });\n        },\n        quit: function(message) {\n            this.send(\"QUIT :\" + message, !0), this.disconnect();\n        },\n        disconnect: function() {\n            for (var k in this.activeTimers) this.activeTimers[k].cancel();\n            this.activeTimers = {}, this.parent();\n        },\n        awayMessage: function(nick, message) {\n            this.newQueryLine(nick, \"AWAY\", {\n                n: nick,\n                m: message\n            }, !0);\n        },\n        whois: function(nick, type, data) {\n            var mtype, ndata = {\n                n: nick\n            }, xsend = function() {\n                this.newTargetOrActiveLine(nick, \"WHOIS\" + mtype, ndata);\n            }.bind(this);\n            if (\"user\" == type) mtype = \"USER\", ndata.h = data.ident + \"@\" + data.hostname, \n            xsend(), mtype = \"REALNAME\", ndata.m = data.realname; else if (\"server\" == type) mtype = \"SERVER\", \n            ndata.x = data.server, ndata.m = data.serverdesc; else if (\"oper\" == type) mtype = \"OPER\"; else if (\"idle\" == type) mtype = \"IDLE\", \n            ndata.x = util.longtoduration(data.idle), ndata.m = irc.IRCDate(new Date(1e3 * data.connected)); else if (\"channels\" == type) mtype = \"CHANNELS\", \n            ndata.m = data.channels; else if (\"account\" == type) mtype = \"ACCOUNT\", ndata.m = data.account; else if (\"away\" == type) mtype = \"AWAY\", \n            ndata.m = data.away; else if (\"opername\" == type) mtype = \"OPERNAME\", ndata.m = data.opername; else if (\"actually\" == type) mtype = \"ACTUALLY\", \n            ndata.m = data.hostname, ndata.x = data.ip; else if (\"generictext\" == type) mtype = \"GENERICTEXT\", \n            ndata.m = data.text; else {\n                if (\"end\" != type) return !1;\n                mtype = \"END\";\n            }\n            return xsend(), !0;\n        },\n        genericError: function(target, message) {\n            this.newTargetOrActiveLine(target, \"GENERICERROR\", {\n                m: message,\n                t: target\n            });\n        },\n        genericQueryError: function(target, message) {\n            this.newQueryOrActiveLine(target, \"GENERICERROR\", {\n                m: message,\n                t: target\n            }, !0);\n        },\n        awayStatus: function(state, message) {\n            this.newActiveLine(\"GENERICMESSAGE\", {\n                m: message\n            });\n        },\n        pushLastNick: function(nick) {\n            var i = this.lastNicks.indexOf(nick);\n            -1 != i ? this.lastNicks.splice(i, 1) : this.lastNicks.length == this.options.maxnicks && this.lastNicks.pop(), \n            this.lastNicks.unshift(nick);\n        },\n        wallops: function(user, text) {\n            var nick = util.hostToNick(user), host = util.hostToHost(user);\n            this.newServerLine(\"WALLOPS\", {\n                t: text,\n                n: nick,\n                h: host\n            });\n        },\n        channelModeIs: function(channel, modes) {\n            this.newTargetOrActiveLine(channel, \"CHANNELMODEIS\", {\n                c: channel,\n                m: modes.join(\" \")\n            });\n        },\n        channelCreationTime: function(channel, time) {\n            this.newTargetOrActiveLine(channel, \"CHANNELCREATIONTIME\", {\n                c: channel,\n                m: irc.IRCDate(new Date(1e3 * time))\n            });\n        }\n    }), irc.IRCConnection = new Class({\n        Implements: [ Events, Options ],\n        options: {\n            initialNickname: \"ircconnX\",\n            minTimeout: 45e3,\n            maxTimeout: 3e5,\n            timeoutIncrement: 1e4,\n            initialTimeout: 65e3,\n            floodInterval: 200,\n            floodMax: 10,\n            floodReset: 5e3,\n            gamesurge: \"\",\n            errorAlert: !0,\n            maxRetries: 5,\n            password: \"\",\n            serverPassword: null\n        },\n        initialize: function(options) {\n            var self = this;\n            self.setOptions(options), self.initialNickname = self.options.initialNickname, self.counter = 0, \n            self.disconnected = !1, self.__floodLastRequest = 0, self.__floodCounter = 0, self.__floodLastFlood = 0, \n            self.__retryAttempts = 0, self.__timeoutId = null, self.__timeout = self.options.initialTimeout, \n            self.__lastActiveRequest = null, self.__activeRequest = null, self.__sendQueue = [], \n            self.__sendQueueActive = !1;\n        },\n        connect: function() {\n            this.cacheAvoidance = util.randHexString(16);\n            var request = this.newRequest(\"n\");\n            request.addEvent(\"complete\", function(stream) {\n                return stream ? stream[0] ? (this.sessionid = stream[1], this.recv(), undefined) : (this.disconnect(), \n                this.__error(\"An error occured: \" + stream[1]), undefined) : (this.disconnected = !0, \n                this.__error(\"Couldn't connect to remote server.\"), undefined);\n            }.bind(this));\n            var postdata = \"nick=\" + encodeURIComponent(this.initialNickname);\n            $defined(this.options.serverPassword) && (postdata += \"&password=\" + encodeURIComponent(this.options.serverPassword)), \n            request.send(postdata);\n        },\n        disconnect: function() {\n            this.disconnected = !0, this.__cancelTimeout(), this.__cancelRequests();\n        },\n        newRequest: function(url, floodProtection, synchronous) {\n            var conn = irc.IRCConnection;\n            if (this.disconnected) return null;\n            floodProtection && !this.disconnected && this.__isFlooding() && (this.disconnect(), \n            this.__error(\"BUG: uncontrolled flood detected -- disconnected.\"));\n            var request = new Request.JSON({\n                url: qwebirc.global.dynamicBaseURL + \"e/\" + url + \"?r=\" + this.cacheAvoidance + \"&t=\" + this.counter++,\n                async: !synchronous\n            });\n            return request.headers = new $H(), request.addEvent(\"request\", conn.setXHRHeaders.curry(request.xhr)), \n            Browser.Engine.trident && request.setHeader(\"If-Modified-Since\", \"Sat, 1 Jan 2000 00:00:00 GMT\"), \n            request;\n        },\n        recv: function() {\n            var request = this.newRequest(\"s\", !0);\n            if ($defined(request)) {\n                this.__activeRequest = request, request.__replaced = !1;\n                var onComplete = function(stream) {\n                    return request.__replaced ? (this.__lastActiveRequest = null, stream && this.__processData(stream), \n                    undefined) : (this.__activeRequest = null, this.__cancelTimeout(), stream ? (this.__processData(stream) && this.recv(), \n                    undefined) : (!this.disconnected && this.__checkRetries() && this.recv(), undefined));\n                }.bind(this);\n                request.addEvent(\"complete\", onComplete), this.__scheduleTimeout(), request.send(\"s=\" + this.sessionid);\n            }\n        },\n        send: function(data, synchronous) {\n            return this.disconnected ? !1 : (synchronous ? this.__send(data, !1) : (this.__sendQueue.push(data), \n            this.__processSendQueue()), !0);\n        },\n        __processSendQueue: function() {\n            this.__sendQueueActive || 0 === this.__sendQueue.length || (this.sendQueueActive = !0, \n            this.__send(this.__sendQueue.shift(), !0));\n        },\n        __send: function(data, async) {\n            var request = this.newRequest(\"p\", !1, !async);\n            null !== request && (request.addEvent(\"complete\", function(stream) {\n                return async && (this.__sendQueueActive = !1), stream && stream[0] ? (this.__processSendQueue(), \n                undefined) : (this.__sendQueue = [], this.disconnected || (this.disconnected = !0, \n                this.__error(\"An error occured: \" + stream[1])), !1);\n            }.bind(this)), request.send(\"s=\" + this.sessionid + \"&c=\" + encodeURIComponent(data)));\n        },\n        __isFlooding: function() {\n            var t = new Date().getTime(), floodt = t - this.__floodLastRequest;\n            return this.options.floodInterval > floodt && (0 !== this.__floodLastFlood && floodt > this.options.floodReset && (this.__floodCounter = 0), \n            this.__floodLastFlood = t, ++this.__floodCounter > this.options.floodMax) ? !0 : (this.__floodLastRequest = t, \n            !1);\n        },\n        __checkRetries: function() {\n            if (++this.__retryAttempts > this.options.maxRetries && !this.disconnected) return this.disconnect(), \n            this.__error(\"Error: connection closed after \" + this.__retryAttempts + \" requests failed.\"), \n            !1;\n            var to = this.__timeout - this.options.timeoutIncrement;\n            return to >= this.options.minTimeout && (this.__timeout = to), !0;\n        },\n        __cancelRequests: function() {\n            $defined(this.__lastActiveRequest) && (this.__lastActiveRequest.cancel(), this.__lastActiveRequest = null), \n            $defined(this.__activeRequest) && (this.__activeRequest.cancel(), this.__activeRequest = null);\n        },\n        __processData: function(o) {\n            return 0 == o[0] ? (this.disconnected || (this.disconnected = !0, this.__error(\"An error occured: \" + o[1])), \n            !1) : (this.__retryAttempts = 0, o.each(function(x) {\n                this.fireEvent(\"recv\", [ x ]);\n            }, this), !0);\n        },\n        __scheduleTimeout: function() {\n            this.__timeoutId = this.__timeoutEvent.delay(this.__timeout, this);\n        },\n        __cancelTimeout: function() {\n            $defined(this.__timeoutId) && ($clear(this.__timeoutId), this.__timeoutId = null);\n        },\n        __timeoutEvent: function() {\n            if (this.__timeoutId = null, $defined(this.__activeRequest)) {\n                this.__lastActiveRequest && this.__lastActiveRequest.cancel(), this.__activeRequest.__replaced = !0, \n                this.__lastActiveRequest = this.__activeRequest;\n                var to = this.__timeout + this.options.timeoutIncrement;\n                this.options.maxTimeout >= to && (this.__timeout = to), this.recv();\n            }\n        },\n        __error: function(text) {\n            this.fireEvent(\"error\", text), this.options.errorAlert && alert(text), console.log(\"had error:\" + text);\n        }\n    }), function() {\n        function removeHeaders(header) {\n            try {\n                this.setRequestHeader(header, killBit);\n            } catch (e) {}\n        }\n        var killBit, conn = irc.IRCConnection, kill = [ \"Accept\", \"Accept-Language\" ];\n        Browser.Engine.trident ? (killBit = \"?\", kill = kill.concat([ \"User-Agent\", \"Connection\" ])) : killBit = /Firefox[\\/\\s]\\d+\\.\\d+/.test(navigator.userAgent) ? null : \"\", \n        conn.setXHRHeaders = Array.each.curry(kill, removeHeaders);\n    }(), irc.IRCTracker = new Class({\n        initialize: function(owner) {\n            this.channels = {}, this.nicknames = {}, this.owner = owner;\n        },\n        toIRCLower: function(value) {\n            return this.owner.toIRCLower(value);\n        },\n        isEmpty: function(hash) {\n            return 0 === Object.keys(hash).length;\n        },\n        getNick: function(nick) {\n            return this.nicknames[nick];\n        },\n        getOrCreateNick: function(nick) {\n            return this.getNick(nick) || (this.nicknames[nick] = {});\n        },\n        getChannel: function(channel) {\n            return this.channels[this.toIRCLower(channel)];\n        },\n        getOrCreateChannel: function(channel) {\n            return this.getChannel(channel) || (this.channels[this.toIRCLower(channel)] = {});\n        },\n        getOrCreateNickOnChannel: function(nick, channel) {\n            var n = this.getOrCreateNick(nick);\n            return n[this.toIRCLower(channel)] || this.addNickToChannel(nick, channel);\n        },\n        getNickOnChannel: function(nick, channel) {\n            var n = this.getNick(nick);\n            return n ? n[this.toIRCLower(channel)] : undefined;\n        },\n        addNickToChannel: function(nick, channel) {\n            var nc = new irc.NickChanEntry(), n = this.getOrCreateNick(nick);\n            n[this.toIRCLower(channel)] = nc;\n            var c = this.getOrCreateChannel(channel);\n            return c[nick] = nc, nc;\n        },\n        removeNick: function(nick) {\n            var n = this.getNick(nick);\n            if (n) {\n                for (var channel in n) {\n                    var lchannel = this.toIRCLower(channel), c = this.channels[lchannel];\n                    delete c[nick], this.isEmpty(c) && delete this.channels[lchannel];\n                }\n                delete this.nicknames[nick];\n            }\n        },\n        removeChannel: function(channel) {\n            var c = this.getChannel(channel);\n            if (c) {\n                var lchannel = this.toIRCLower(channel);\n                for (var nick in c) {\n                    var n = this.nicknames[nick];\n                    delete n[lchannel], this.isEmpty(n) && delete this.nicknames[nick];\n                }\n                delete this.channels[lchannel];\n            }\n        },\n        removeNickFromChannel: function(nick, channel) {\n            var lchannel = this.toIRCLower(channel), n = this.getNick(nick), c = this.getChannel(lchannel);\n            n && c && (delete n[lchannel], delete c[nick], this.isEmpty(n) && delete this.nicknames[nick], \n            this.isEmpty(c) && delete this.channels[lchannel]);\n        },\n        renameNick: function(oldnick, newnick) {\n            var n = this.getNick(oldnick);\n            if (n) {\n                for (var channel in n) {\n                    var lchannel = this.toIRCLower(channel);\n                    this.channels[lchannel][newnick] = this.channels[lchannel][oldnick], delete this.channels[lchannel][oldnick];\n                }\n                this.nicknames[newnick] = this.nicknames[oldnick], delete this.nicknames[oldnick];\n            }\n        },\n        updateLastSpoke: function(nick, channel, time) {\n            var nc = this.getNickOnChannel(nick, channel);\n            $defined(nc) && (nc.lastSpoke = time);\n        },\n        getSortedByLastSpoke: function(channel) {\n            var sorter = function(a, b) {\n                return b[1].lastSpoke - a[1].lastSpoke;\n            }, chan = this.getChannel(channel);\n            if (chan) {\n                var names = [];\n                for (var name in chan) names.push([ name, chan[name] ]);\n                names.sort(sorter);\n                var newnames = names.map(function(user) {\n                    return user[0];\n                });\n                return newnames;\n            }\n        }\n    }), sound.domReady = !1, window.addEvent(\"domready\", function() {\n        sound.domReady = !0;\n    }), sound.SoundPlayer = new Class({\n        Implements: [ Events ],\n        initialize: function() {\n            this.loadingSWF = !1, this.loadedSWF = !1;\n        },\n        go: function() {\n            sound.domReady ? this.loadSoundManager() : window.addEvent(\"domready\", function() {\n                this.loadSoundManager();\n            }.bind(this));\n        },\n        loadSoundManager: function() {\n            if (!this.loadingSWF) {\n                if (this.loadingSWF = !0, \"undefined\" != eval(\"typeof soundManager\")) return this.loadedSWF = !0, \n                this.fireEvent(\"ready\"), undefined;\n                var debugMode = !1;\n                util.importJS(qwebirc.global.staticBaseURL + \"js/\" + (debugMode ? \"soundmanager2\" : \"soundmanager2-nodebug-jsmin\") + \".js\", \"soundManager\", function() {\n                    soundManager.url = qwebirc.global.staticBaseURL + \"sound/\", soundManager.debugMode = debugMode, \n                    soundManager.useConsole = debugMode, soundManager.onload = function() {\n                        this.loadedSWF = !0, this.fireEvent(\"ready\");\n                    }.bind(this), soundManager.beginDelayedInit();\n                }.bind(this));\n            }\n        },\n        createSound: function(name, src) {\n            soundManager.createSound(name, src);\n        },\n        playSound: function(name) {\n            soundManager.play(name);\n        },\n        beep: function() {\n            this.beepLoaded || (this.createSound(\"beep\", qwebirc.global.staticBaseURL + \"sound/beep3.mp3\"), \n            this.beepLoaded = !0), this.playSound(\"beep\");\n        }\n    }), ui.AboutPane = new Class({\n        Implements: [ Events ],\n        initialize: function(parent) {\n            var delayfn = function() {\n                parent.set(\"html\", '<div class=\"loading\">Loading. . .</div>');\n            }, cb = delayfn.delay(500), r = ui.RequestTransformHTML({\n                url: qwebirc.global.staticBaseURL + \"panes/about.html\",\n                update: parent,\n                onSuccess: function() {\n                    $clear(cb), parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                        this.fireEvent(\"close\");\n                    }.bind(this)), parent.getElement(\"div[class=version]\").set(\"text\", \"v\" + qwebirc.VERSION);\n                }.bind(this)\n            });\n            r.get();\n        }\n    }), ui.PrivacyPolicyPane = new Class({\n        Implements: [ Events ],\n        initialize: function(parent) {\n            var delayfn = function() {\n                parent.set(\"html\", '<div class=\"loading\">Loading. . .</div>');\n            }, cb = delayfn.delay(500), r = ui.RequestTransformHTML({\n                url: qwebirc.global.staticBaseURL + \"panes/privacypolicy.html\",\n                update: parent,\n                onSuccess: function() {\n                    $clear(cb), parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                        this.fireEvent(\"close\");\n                    }.bind(this));\n                }.bind(this)\n            });\n            r.get();\n        }\n    }), ui.FeedbackPane = new Class({\n        Implements: [ Events ],\n        initialize: function(parent) {\n            this.textboxVisible = !1;\n            var delayfn = function() {\n                parent.set(\"html\", '<div class=\"loading\">Loading. . .</div>');\n            }, cb = delayfn.delay(500);\n            this.addEvent(\"select\", this.onSelect);\n            var r = ui.RequestTransformHTML({\n                url: qwebirc.global.staticBaseURL + \"panes/feedback.html\",\n                update: parent,\n                onSuccess: function() {\n                    $clear(cb), parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                        this.fireEvent(\"close\");\n                    }.bind(this)), parent.getElement(\"input[class=close2]\").addEvent(\"click\", function() {\n                        this.fireEvent(\"close\");\n                    }.bind(this));\n                    var textbox = parent.getElement(\"textarea\");\n                    this.textbox = textbox, parent.getElement(\"input[class=submitfeedback]\").addEvent(\"click\", function() {\n                        this.sendFeedback(parent, textbox, textbox.value);\n                    }.bind(this)), this.textboxVisible = !0, this.onSelect();\n                }.bind(this)\n            });\n            r.get();\n        },\n        onSelect: function() {\n            this.textboxVisible && this.textbox.focus();\n        },\n        sendFeedback: function(parent, textbox, text) {\n            text = text.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n            var mainText = parent.getElement(\"p[class=maintext]\");\n            if (25 > text.length) return mainText.set(\"text\", \"I don't suppose you could enter a little bit more? Thanks!\"), \n            textbox.focus(), undefined;\n            this.textboxVisible = !1;\n            var mainBody = parent.getElement(\"div[class=enterarea]\");\n            mainBody.setStyle(\"display\", \"none\");\n            var messageBody = parent.getElement(\"div[class=messagearea]\"), messageText = parent.getElement(\"p[class=messagetext]\"), messageClose = parent.getElement(\"input[class=close2]\");\n            messageText.set(\"text\", \"Submitting. . .\"), messageBody.setStyle(\"display\", \"\");\n            var checksum = 0;\n            encodeURIComponent(text);\n            for (var i = 0; text.length > i; i++) checksum = (checksum + 1) % 256 ^ text.charCodeAt(i) % 256;\n            new Request({\n                url: qwebirc.global.dynamicBaseURL + \"feedback\",\n                onSuccess: function() {\n                    messageText.set(\"text\", \"Submitted successfully, thanks for the feedback!\"), messageClose.setStyle(\"display\", \"\");\n                },\n                onFailure: function() {\n                    this.textboxVisible = !0, messageBody.setStyle(\"display\", \"none\"), mainBody.setStyle(\"display\", \"\"), \n                    mainText.set(\"text\", \"Looks like something went wrong submitting :(\");\n                }.bind(this)\n            }).send(\"feedback=\" + text + \"&c=\" + checksum);\n        }\n    }), ui.FAQPane = new Class({\n        Implements: [ Events ],\n        initialize: function(parent) {\n            var delayfn = function() {\n                parent.set(\"html\", '<div class=\"loading\">Loading. . .</div>');\n            }, cb = delayfn.delay(500), r = ui.RequestTransformHTML({\n                url: qwebirc.global.staticBaseURL + \"panes/faq.html\",\n                update: parent,\n                onSuccess: function() {\n                    $clear(cb), parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                        this.fireEvent(\"close\");\n                    }.bind(this));\n                }.bind(this)\n            });\n            r.get();\n        }\n    }), config.DEFAULT_OPTIONS = [ [ 1, \"BEEP_ON_MENTION\", \"Beep when nick mentioned or on query activity (requires Flash)\", !0, {\n        enabled: function() {\n            return !$defined(Browser.Plugins.Flash) || 8 > Browser.Plugins.Flash.version ? [ !1, !1 ] : [ !0 ];\n        },\n        applyChanges: function(value, ui) {\n            ui.setBeepOnMention && ui.setBeepOnMention(value);\n        }\n    } ], [ 7, \"FLASH_ON_MENTION\", \"Flash titlebar when nick mentioned or on query activity\", !0, {\n        enabled: ui.supportsFocus\n    } ], [ 2, \"DEDICATED_MSG_WINDOW\", \"Send privmsgs to dedicated messages window\", !1 ], [ 4, \"DEDICATED_NOTICE_WINDOW\", \"Send notices to dedicated message window\", !1 ], [ 3, \"NICK_OV_STATUS\", \"Show status (@/+) before nicknames in channel lines\", !0 ], [ 5, \"ACCEPT_SERVICE_INVITES\", \"Automatically join channels when invited by Q\", !0, {\n        settableByURL: !1\n    } ], [ 6, \"USE_HIDDENHOST\", \"Hide your hostmask when authed to Q (+x)\", !0, {\n        settableByURL: !1\n    } ], [ 8, \"LASTPOS_LINE\", \"Show a last position indicator for each window\", !0, {\n        enabled: ui.supportsFocus\n    } ], [ 9, \"NICK_COLOURS\", \"Automatically colour nicknames\", !1 ], [ 10, \"HIDE_JOINPARTS\", \"Hide JOINS/PARTS/QUITS\", !1 ], [ 11, \"STYLE_HUE\", \"Adjust user interface hue\", function() {\n        return {\n            class_: config.HueOption,\n            default_: 210\n        };\n    }, {\n        applyChanges: function(value, ui) {\n            ui.setModifiableStylesheetValues({\n                hue: value\n            });\n        }\n    } ], [ 12, \"QUERY_ON_NICK_CLICK\", \"Query on nickname click in channel\", !1 ], [ 13, \"SHOW_NICKLIST\", \"Show nickname list in channels\", !0 ], [ 14, \"SHOW_TIMESTAMPS\", \"Show timestamps\", !0 ] ], \n    config.DefaultOptions = null, config.Input = new Class({\n        initialize: function(parent, option, position, parentObject) {\n            this.option = option, this.value = option.value, this.enabled = this.option.enabled, \n            this.position = position, this.parentElement = parent, this.parentObject = parentObject, \n            this.render();\n        },\n        createInput: function(type, parent, name, selected) {\n            return $defined(parent) || (parent = this.parentElement), qwebirc.util.createInput(type, parent, name, selected, this.option.id);\n        },\n        FE: function(element, parent) {\n            var n = new Element(element);\n            return $defined(parent) || (parent = this.parentElement), parent.appendChild(n), \n            n;\n        },\n        focus: function() {\n            this.mainElement.focus();\n        },\n        render: function() {\n            this.event(\"render\", this.mainElement);\n        },\n        applyChanges: function() {\n            this.event(\"applyChanges\", [ this.get(), this.parentObject.optionObject.ui ]);\n        },\n        event: function(name, x) {\n            if ($defined(this.option.extras)) {\n                var t = this.option.extras[name];\n                $defined(t) && t.pass(x, this)();\n            }\n        },\n        cancel: function() {}\n    }), config.TextInput = new Class({\n        Extends: config.Input,\n        render: function() {\n            var i = this.createInput(\"text\");\n            this.mainElement = i, i.value = this.value, i.disabled = !this.enabled, this.parent();\n        },\n        get: function() {\n            return this.mainElement.value;\n        }\n    }), config.HueInput = new Class({\n        Extends: config.Input,\n        render: function() {\n            var i = new Element(\"div\");\n            i.addClass(\"qwebirc-optionspane\"), i.addClass(\"hue-slider\"), this.parentElement.appendChild(i);\n            var k = new Element(\"div\");\n            k.addClass(\"knob\"), Browser.Engine.trident && (k.setStyle(\"top\", \"0px\"), k.setStyle(\"background-color\", \"black\")), \n            i.appendChild(k);\n            var slider = new Slider(i, k, {\n                steps: 36,\n                range: [ 0, 369 ],\n                wheel: !0\n            });\n            slider.set(this.value), this.startValue = this.value, slider.addEvent(\"change\", function(step) {\n                this.value = step, this.applyChanges();\n            }.bind(this)), this.mainElement = i, this.enabled || slider.detach(), this.parent();\n        },\n        get: function() {\n            return this.value;\n        },\n        cancel: function() {\n            this.value = this.startValue, this.applyChanges();\n        }\n    }), config.CheckInput = new Class({\n        Extends: config.Input,\n        render: function() {\n            var i = this.createInput(\"checkbox\", null, null, null, this.id);\n            this.mainElement = i, i.checked = this.value, i.disabled = !this.enabled, this.parent();\n        },\n        get: function() {\n            return this.mainElement.checked;\n        }\n    }), config.RadioInput = new Class({\n        Extends: config.Input,\n        render: function() {\n            var value = this.option.options;\n            this.elements = [];\n            for (var i = 0; value.length > i; i++) {\n                var d = this.FE(\"div\", this.parentObject), e = this.createInput(\"radio\", d, \"options_radio\" + this.position, i == this.option.position);\n                this.elements.push(e), e.disabled = !this.enabled, 0 == i && (this.mainElement = e), \n                d.appendChild(document.createTextNode(value[i][0]));\n            }\n            this.parent();\n        },\n        get: function() {\n            for (var i = 0; this.elements.length > i; i++) {\n                var x = this.elements[i];\n                if (x.checked) return this.option.position = i, this.option.options[i][1];\n            }\n        }\n    }), config.Option = new Class({\n        initialize: function(optionId, prefix, label, default_, extras) {\n            if (this.prefix = prefix, this.label = label, this.default_ = default_, this.optionId = optionId, \n            this.extras = extras, $defined(extras) && $defined(extras.enabled)) {\n                var enabledResult = extras.enabled();\n                this.enabled = enabledResult[0], !enabledResult[0] && enabledResult.length > 1 && (this.default_ = enabledResult[1]);\n            } else this.enabled = !0;\n            this.settableByURL = $defined(extras) && $defined(extras.settableByURL) ? extras.settableByURL : !0;\n        },\n        setSavedValue: function(x) {\n            this.enabled && (this.value = x);\n        }\n    }), config.RadioOption = new Class({\n        Extends: config.Option,\n        Element: config.RadioInput,\n        initialize: function(optionId, prefix, label, default_, extras, options) {\n            this.options = options.map(function(x) {\n                return \"string\" == typeof x ? [ x, x ] : x;\n            }), this.defaultposition = default_, this.parent(optionId, prefix, label, this.options[default_][1], extras);\n        },\n        setSavedValue: function(x) {\n            for (var i = 0; this.options.length > i; i++) {\n                var y = this.options[i][1];\n                if (x == y) return this.position = i, this.value = x, undefined;\n            }\n            this.position = this.defaultposition, this.value = this.default_;\n        }\n    }), config.TextOption = new Class({\n        Extends: config.Option,\n        Element: config.TextInput\n    }), config.CheckOption = new Class({\n        Extends: config.Option,\n        Element: config.CheckInput\n    }), config.HueOption = new Class({\n        Extends: config.Option,\n        Element: config.HueInput\n    }), ui.Options = new Class({\n        initialize: function(ui) {\n            $defined(config.DefaultOptions) || this.__configureDefaults(), this.optionList = config.DefaultOptions.slice(), \n            this.optionHash = {}, this.ui = ui, this._setup(), this.optionList.forEach(function(x) {\n                x.setSavedValue(this._get(x)), this.optionHash[x.prefix] = x, this[x.prefix] = x.value;\n            }.bind(this));\n        },\n        __configureDefaults: function() {\n            config.DefaultOptions = config.DEFAULT_OPTIONS.map(function(x) {\n                var optionId = x[0], prefix = x[1], label = x[2], default_ = x[3], moreextras = x[4];\n                x[5];\n                var stype = typeof default_;\n                if (\"number\" == stype) return new config.RadioOption(optionId, prefix, label, default_, moreextras, extra);\n                var type;\n                if (\"boolean\" == stype) type = config.CheckOption; else if (\"function\" == stype) {\n                    var options = default_();\n                    type = options.class_, default_ = options.default_;\n                } else type = config.TextOption;\n                return new type(optionId, prefix, label, default_, moreextras);\n            });\n        },\n        setValue: function(option, value) {\n            this.optionHash[option.prefix].value = value, this[option.prefix] = value;\n        },\n        getOptionList: function() {\n            return this.optionList;\n        },\n        _get: function(x) {\n            return x.default_;\n        },\n        _setup: function() {},\n        flush: function() {}\n    }), ui.OptionsPane = new Class({\n        Implements: [ Events ],\n        initialize: function(parentElement, optionObject) {\n            this.parentElement = parentElement, this.optionObject = optionObject, this.createElements();\n        },\n        createElements: function() {\n            var FE = function(element, parent) {\n                var n = new Element(element);\n                return parent.appendChild(n), n;\n            }, t = FE(\"table\", this.parentElement), tb = FE(\"tbody\", t);\n            this.boxList = [];\n            for (var optList = this.optionObject.getOptionList(), i = 0; optList.length > i; i++) {\n                var x = optList[i], row = FE(\"tr\", tb), cella = FE(\"td\", row);\n                x.id = qwebirc.util.generateID();\n                var label = new Element(\"label\", {\n                    \"for\": x.id\n                });\n                cella.appendChild(label), label.set(\"text\", x.label + \":\");\n                var cellb = FE(\"td\", row);\n                this.boxList.push([ x, new x.Element(cellb, x, i, this) ]);\n            }\n            var r = FE(\"tr\", tb), cella = FE(\"td\", r), cellb = FE(\"td\", r), save = qwebirc.util.createInput(\"submit\", cellb);\n            save.value = \"Save\", save.addEvent(\"click\", function() {\n                this.save(), this.fireEvent(\"close\");\n            }.bind(this));\n            var cancel = qwebirc.util.createInput(\"submit\", cellb);\n            cancel.value = \"Cancel\", cancel.addEvent(\"click\", function() {\n                this.cancel(), this.fireEvent(\"close\");\n            }.bind(this));\n        },\n        save: function() {\n            this.boxList.forEach(function(x) {\n                var option = x[0], box = x[1];\n                this.optionObject.setValue(option, box.get());\n            }.bind(this)), this.boxList.forEach(function(x) {\n                x[1].applyChanges();\n            }.bind(this)), this.optionObject.flush();\n        },\n        cancel: function() {\n            this.boxList.forEach(function(x) {\n                x[1].cancel();\n            }.bind(this));\n        }\n    }), ui.CookieOptions = new Class({\n        Extends: ui.Options,\n        _setup: function() {\n            this.__cookie = new Hash.Cookie(\"opt1\", {\n                duration: 3650,\n                autoSave: !1\n            });\n        },\n        _get: function(x) {\n            var v = this.__cookie.get(x.optionId);\n            return $defined(v) ? v : x.default_;\n        },\n        flush: function() {\n            this.__cookie.erase(), this._setup(), this.getOptionList().forEach(function(x) {\n                this.__cookie.set(x.optionId, x.value);\n            }.bind(this)), this.__cookie.save();\n        }\n    }), ui.SuppliedArgOptions = new Class({\n        Extends: ui.CookieOptions,\n        initialize: function(ui, arg) {\n            var p = {};\n            if ($defined(arg) && \"\" != arg && arg.length > 2) {\n                var checksum = arg.substr(arg.length - 2, 2), decoded = qwebirc.util.B64.decode(arg.substr(0, arg.length - 2));\n                decoded && new qwebirc.util.crypto.MD5().digest(decoded).slice(0, 2) == checksum && (p = qwebirc.util.parseURI(\"?\" + decoded));\n            }\n            this.parsedOptions = p, this.parent(ui);\n        },\n        _get: function(x) {\n            if (x.settableByURL !== !0) return this.parent(x);\n            var opt = this.parsedOptions[x.optionId];\n            return $defined(opt) ? opt : this.parent(x);\n        },\n        serialise: function() {\n            var result = [];\n            this.getOptionList().forEach(function(x) {\n                x.settableByURL && x.default_ != x.value && result.push(x.optionId + \"=\" + x.value);\n            }.bind(this));\n            var raw = result.join(\"&\"), checksum = new qwebirc.util.crypto.MD5().digest(raw).slice(0, 2);\n            return qwebirc.util.B64.encode(raw).replaceAll(\"=\", \"\") + checksum;\n        }\n    }), ui.DefaultOptionsClass = new Class({\n        Extends: ui.SuppliedArgOptions\n    }), ui.insertAt = function(position, parent, element) {\n        !parent.childNodes || position >= parent.childNodes.length ? parent.appendChild(element) : parent.insertBefore(element, parent.childNodes[position]);\n    }, util.NBSPCreate = function(text, element) {\n        for (var e = text.split(\"  \"), i = 0; e.length > i; i++) {\n            var tn = document.createTextNode(e[i]);\n            if (element.appendChild(tn), i != e.length - 1) {\n                var e2 = new Element(\"span\");\n                e2.set(\"html\", \"&nbsp;&nbsp;\"), element.appendChild(e2);\n            }\n        }\n    }, util.setCaretPos = function(obj, pos) {\n        if ($defined(obj.selectionStart)) obj.focus(), obj.setSelectionRange(pos, pos); else if (obj.createTextRange) {\n            var range = obj.createTextRange();\n            range.move(\"character\", pos), range.select();\n        }\n    }, util.setAtEnd = function(obj) {\n        util.setCaretPos(obj.value.length);\n    }, util.getCaretPos = function(element) {\n        if ($defined(element.selectionStart)) return element.selectionStart;\n        if (document.selection) {\n            element.focus();\n            var sel = document.selection.createRange();\n            return sel.moveStart(\"character\", -element.value.length), sel.text.length;\n        }\n    }, util.importJS = function(name, watchFor, onload) {\n        var script = new Element(\"script\");\n        if (script.type = \"text/javascript\", script.src = name, Browser.Engine.trident) {\n            var checkFn = function() {\n                \"undefined\" != eval(\"typeof \" + watchFor) ? onload() : checkFn.delay(100);\n            };\n            checkFn();\n        } else script.onload = onload;\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    }, util.createInput = function(type, parent, name, selected, id) {\n        var r;\n        return Browser.Engine.trident ? (name = name ? ' name=\"' + escape(name) + '\"' : \"\", \n        id = id ? ' id=\"' + escape(id) + '\"' : \"\", r = $(document.createElement('<input type=\"' + type + '\"' + name + id + \" \" + (selected ? \" checked\" : \"\") + \"/>\"))) : (r = new Element(\"input\"), \n        r.type = type, name && (r.name = name), id && (r.id = id), selected && (r.checked = !0)), \n        parent.appendChild(r), r;\n    }, ui.highlightRecent = function() {\n        var chanwin = $(\"channel-name-id\"), mainwin = $(\"mainircwindow\"), last5 = $(\"last5messages\");\n        for (isChannel = 0, mainwin.innerHTML.search(\"#\") >= 0 && (isChannel = 1), e = mainwin.childNodes, \n        invisibleMessagesFromTarget = [], last5 = \"\", last5BackgroundColor = \"\", messagesFromTarget = \"\", \n        visibleMessagesFromTarget = 0, visibleMark = 0, e.length > 150 && (visibleMark = e.length - 150), \n        i = 0; e.length > i; i++) {\n            for (s = e[i].getElementsByTagName(\"span\"), target = \"\", j = 0; s.length > j; j++) \"hyperlink-whois\" == s[j].className && (target = s[j].innerHTML, \n            j = s.length);\n            target && (e[i].style.fontWeight = \"\", e[i].style.backgroundColor = \"\", isChannel ? target.search(\"#\") >= 0 ? (target = target.substr(target.search(\"#\")), \n            target == mainwin.innerHTML && (e[i].style.backgroundColor = \"#ffffbf\", last5BackgroundColor = \"#ffffbf\", \n            i >= visibleMark && e[i].offsetTop >= mainwin.scrollTop && e[i].offsetTop <= mainwin.offsetHeight + mainwin.scrollTop && visibleMessagesFromTarget++)) : target.search(window.nickname) >= 0 && (e[i].style.backgroundColor = \"#ffbcaf\") : target.search(mainwin.innerHTML) >= 0 && (target.search(\"#\") >= 0 ? e[i].style.backgroundColor = \"#ffded6\" : (e[i].style.backgroundColor = \"#ffbcaf\", \n            last5BackgroundColor = \"#ffbcaf\", i >= visibleMark && e[i].offsetTop >= mainwin.scrollTop && e[i].offsetTop <= mainwin.offsetHeight + mainwin.scrollTop && visibleMessagesFromTarget++)));\n        }\n        last5 && (toDelete = last5, toDelete.parentNode.removeChild(toDelete)), e = 0;\n        var _chanID = chanwin.innerHTML.toLowerCase(), IRC = window.ui.IRCClient;\n        _chanID in IRC.windows && (e = IRC.windows[_chanID].lines.getElementsByTagName(\"div\"));\n        for (i = 0; e.length > i; i++) r = RegExp('<span class=\"Xc4\">==</span><span>'), \n        r.test(e[i].innerHTML) || (invisibleMessagesFromTarget[invisibleMessagesFromTarget.length] = e[i].innerHTML);\n        if (\"#brouhaha\" == document.window.selectedChannel && 5 > visibleMessagesFromTarget) {\n            for (last5 = new Element(\"div\"), \"\" == last5BackgroundColor && (r = RegExp(\"#\"), \n            last5BackgroundColor = r.test(mainwin.innerHTML) ? \"#ffffbf\" : \"#ffbcaf\"), last5.style.backgroundColor = last5BackgroundColor, \n            main_parent = mainwin, main_parent = main_parent.parentNode, main_parent.insertBefore(last5, mainwin), \n            messagesFromTarget = \"\", i = 0, invisibleMessagesFromTarget.length > 5 && (i = invisibleMessagesFromTarget.length - 5); invisibleMessagesFromTarget.length - visibleMessagesFromTarget > i; i++) messagesFromTarget += \"<div>\" + invisibleMessagesFromTarget[i] + \"</div>\";\n            last5.innerHTML = messagesFromTarget, last5.id = \"last5messages\";\n        }\n    }, ui.UI_COMMANDS = [ [ \"Options\", \"options\" ], [ \"Add webchat to your site\", \"embedded\" ], [ \"Privacy policy\", \"privacy\" ], [ \"Feedback\", \"feedback\" ], [ \"Frequently asked questions\", \"faq\" ], [ \"About qwebirc\", \"about\" ] ], \n    ui.MENU_ITEMS = function() {\n        var isOpped = function() {\n            var channel = this.name, myNick = this.client.nickname;\n            return this.client.nickOnChanHasAtLeastPrefix(myNick, channel, \"@\");\n        }, targetOpped = function(nick) {\n            var channel = this.name;\n            return this.client.nickOnChanHasPrefix(nick, channel, \"@\");\n        }, targetVoiced = function(nick) {\n            var channel = this.name;\n            return this.client.nickOnChanHasPrefix(nick, channel, \"+\");\n        }, command = function(cmd) {\n            return function(nick) {\n                this.client.exec(\"/\" + cmd + \" \" + nick);\n            };\n        };\n        return [ {\n            text: \"whois\",\n            fn: command(\"whois\"),\n            predicate: !0\n        }, {\n            text: \"query\",\n            fn: command(\"query\"),\n            predicate: !0\n        }, {\n            text: \"slap\",\n            fn: function(nick) {\n                this.client.exec(\"/ME slaps \" + nick + \" around a bit with a large fishbot\");\n            },\n            predicate: !0\n        }, {\n            text: \"kick\",\n            fn: function(nick) {\n                this.client.exec(\"/KICK \" + nick + \" wibble\");\n            },\n            predicate: isOpped\n        }, {\n            text: \"op\",\n            fn: command(\"op\"),\n            predicate: prelude.andand(isOpped, Functional.not(targetOpped))\n        }, {\n            text: \"deop\",\n            fn: command(\"deop\"),\n            predicate: prelude.andand(isOpped, targetOpped)\n        }, {\n            text: \"voice\",\n            fn: command(\"voice\"),\n            predicate: prelude.andand(isOpped, Functional.not(targetVoiced))\n        }, {\n            text: \"devoice\",\n            fn: command(\"devoice\"),\n            predicate: prelude.andand(isOpped, targetVoiced)\n        } ];\n    }(), ui.WINDOW_STATUS = 1, ui.WINDOW_QUERY = 2, ui.WINDOW_CHANNEL = 4, ui.WINDOW_CUSTOM = 8, \n    ui.WINDOW_CONNECT = 16, ui.WINDOW_MESSAGES = 32, ui.CUSTOM_CLIENT = \"custom\", ui.BaseUI = new Class({\n        Implements: [ Events ],\n        initialize: function(parentElement, windowClass, uiName, options) {\n            if (this.options = options, this.windows = {}, this.clients = {}, this.windows[ui.CUSTOM_CLIENT] = {}, \n            this.windowArray = [], this.windowClass = windowClass, this.parentElement = parentElement, \n            this.parentElement.addClass(\"qwebirc\"), this.parentElement.addClass(\"qwebirc-\" + uiName), \n            this.firstClient = !1, this.commandhistory = new irc.CommandHistory(), this.clientId = 0, \n            this.windowFocused = !0, Browser.Engine.trident) {\n                var checkFocus = function() {\n                    var hasFocus = document.hasFocus();\n                    hasFocus != this.windowFocused && (this.windowFocused = hasFocus, this.focusChange(hasFocus));\n                };\n                checkFocus.periodical(100, this);\n            } else {\n                var blur = function() {\n                    this.windowFocused && (this.windowFocused = !1, this.focusChange(!1));\n                }.bind(this), focus = function() {\n                    this.windowFocused || (this.windowFocused = !0, this.focusChange(!0));\n                }.bind(this);\n                document.addEvent(\"blur\", blur), window.addEvent(\"blur\", blur), document.addEvent(\"focus\", focus), \n                window.addEvent(\"focus\", focus);\n            }\n        },\n        newClient: function(client) {\n            client.id = this.clientId++, client.hilightController = new ui.HilightController(client), \n            this.windows[client.id] = {}, this.clients[client.id] = client;\n            var win = this.newWindow(client, ui.WINDOW_STATUS, STATUS);\n            return this.selectWindow(win), this.firstClient || (this.firstClient = !0, win.addLine(\"\", \"qwebirc v\" + qwebirc.VERSION), \n            win.addLine(\"\", \"Copyright (C) 2008-2011 Chris Porter and the qwebirc project.\"), \n            win.addLine(\"\", \"http://www.qwebirc.org\"), win.addLine(\"\", \"Licensed under the GNU General Public License, Version 2.\")), \n            win;\n        },\n        getClientId: function(client) {\n            return client == ui.CUSTOM_CLIENT ? ui.CUSTOM_CLIENT : client.id;\n        },\n        getWindowIdentifier: function(client, type, name) {\n            return type == ui.WINDOW_MESSAGES ? \"-M\" : type == ui.WINDOW_STATUS ? \"\" : client == ui.CUSTOM_CLIENT ? \"_\" + name : \"_\" + client.toIRCLower(name);\n        },\n        newWindow: function(client, type, name) {\n            var win = this.getWindow(client, type, name);\n            if ($defined(win)) return win;\n            var wId = this.getWindowIdentifier(client, type, name), win = this.windows[this.getClientId(client)][wId] = new this.windowClass(this, client, type, name, wId);\n            return this.windowArray.push(win), win;\n        },\n        getWindow: function(client, type, name) {\n            var c = this.windows[this.getClientId(client)];\n            return $defined(c) ? c[this.getWindowIdentifier(client, type, name)] : null;\n        },\n        getActiveWindow: function() {\n            return this.active;\n        },\n        getActiveIRCWindow: function(client) {\n            return this.active && this.active.type != ui.WINDOW_CUSTOM ? this.active : this.windows[this.getClientId(client)][this.getWindowIdentifier(client, ui.WINDOW_STATUS)];\n        },\n        __setActiveWindow: function(window) {\n            this.active = window;\n        },\n        selectWindow: function(window) {\n            this.active && this.active.deselect(), window.select(), this.updateTitle(window.name + \" - \" + this.options.appTitle);\n        },\n        updateTitle: function(text) {\n            document.title = text;\n        },\n        nextWindow: function(direction) {\n            if (0 != this.windowArray.length && this.active) {\n                direction || (direction = 1);\n                var index = this.windowArray.indexOf(this.active);\n                -1 != index && (index += direction, 0 > index ? index = this.windowArray.length - 1 : index >= this.windowArray.length && (index = 0), \n                this.selectWindow(this.windowArray[index]));\n            }\n        },\n        prevWindow: function() {\n            this.nextWindow(-1);\n        },\n        __closed: function(window) {\n            if (window.active) if (this.active = undefined, 1 == this.windowArray.length) this.windowArray = []; else {\n                var index = this.windowArray.indexOf(window);\n                if (-1 == index) return;\n                0 == index ? this.selectWindow(this.windowArray[1]) : this.selectWindow(this.windowArray[index - 1]);\n            }\n            this.windowArray = this.windowArray.erase(window), delete this.windows[this.getClientId(window.client)][window.identifier];\n        },\n        loginBox: function(callback, initialNickname, initialChannels, autoConnect, autoNick, storage) {\n            ui.GenericLoginBox(this.parentElement, callback, initialNickname, initialChannels, autoConnect, autoNick, this.options.networkName, storage);\n        },\n        focusChange: function(newValue) {\n            window.ctrl = 0;\n            var window_ = this.getActiveWindow();\n            $defined(window_) && window_.focusChange(newValue);\n        }\n    }), ui.StandardUI = new Class({\n        Extends: ui.BaseUI,\n        UICommands: ui.UI_COMMANDS,\n        initialize: function(parentElement, windowClass, uiName, options) {\n            this.parent(parentElement, windowClass, uiName, options), this.tabCompleter = new ui.TabCompleterFactory(this), \n            this.uiOptions = new ui.DefaultOptionsClass(this, options.uiOptionsArg), this.customWindows = {}, \n            this.__styleValues = {\n                hue: this.uiOptions.STYLE_HUE,\n                saturation: 0,\n                lightness: 0\n            }, $defined(this.options.hue) && (this.__styleValues.hue = this.options.hue), $defined(this.options.saturation) && (this.__styleValues.saturation = this.options.saturation), \n            $defined(this.options.lightness) && (this.__styleValues.lightness = this.options.lightness);\n            var ev;\n            ev = Browser.Engine.trident ? \"keydown\" : \"keypress\", document.addEvent(ev, this.__handleHotkey.bind(this));\n        },\n        __handleHotkey: function(x) {\n            if (!x.alt || x.control) return (\"backspace\" == x.key || \"/\" == x.key) && (this.getInputFocused(x) || new Event(x).stop()), \n            undefined;\n            var success = !1;\n            if (\"a\" == x.key || \"A\" == x.key) {\n                var highestNum = 0, highestIndex = -1;\n                success = !0, new Event(x).stop();\n                for (var i = 0; this.windowArray.length > i; i++) {\n                    var h = this.windowArray[i].hilighted;\n                    h > highestNum && (highestIndex = i, highestNum = h);\n                }\n                highestIndex > -1 && this.selectWindow(this.windowArray[highestIndex]);\n            } else if (x.key >= \"0\" && \"9\" >= x.key) {\n                if (success = !0, number = x.key - \"0\", 0 == number && (number = 10), number -= 1, \n                number >= this.windowArray.length) return;\n                this.selectWindow(this.windowArray[number]);\n            } else \"left\" == x.key ? (this.prevWindow(), success = !0) : \"right\" == x.key && (this.nextWindow(), \n            success = !0);\n            success && new Event(x).stop();\n        },\n        getInputFocused: function(x) {\n            return -1 == $$(\"input\").indexOf(x.target) && -1 == $$(\"textarea\").indexOf(x.target) ? !1 : !0;\n        },\n        newCustomWindow: function(name, select, type) {\n            type || (type = ui.WINDOW_CUSTOM);\n            var win = this.newWindow(ui.CUSTOM_CLIENT, type, name);\n            return win.addEvent(\"close\", function(win) {\n                delete this.windows[ui.CUSTOM_CLIENT][win.identifier];\n            }.bind(this)), select && this.selectWindow(win), win;\n        },\n        addCustomWindow: function(windowName, class_, cssClass, options) {\n            if ($defined(options) || (options = {}), this.customWindows[windowName]) return this.selectWindow(this.customWindows[windowName]), \n            undefined;\n            var d = this.newCustomWindow(windowName, !0);\n            this.customWindows[windowName] = d, d.addEvent(\"close\", function() {\n                this.customWindows[windowName] = null;\n            }.bind(this)), cssClass && d.lines.addClass(\"qwebirc-\" + cssClass);\n            var ew = new class_(d.lines, options);\n            ew.addEvent(\"close\", function() {\n                d.close();\n            }.bind(this)), d.setSubWindow(ew);\n        },\n        embeddedWindow: function() {\n            this.addCustomWindow(\"Add webchat to your site\", ui.EmbedWizard, \"embeddedwizard\", {\n                baseURL: this.options.baseURL,\n                uiOptions: this.uiOptions,\n                optionsCallback: function() {\n                    this.optionsWindow();\n                }.bind(this)\n            });\n        },\n        optionsWindow: function() {\n            this.addCustomWindow(\"Options\", ui.OptionsPane, \"optionspane\", this.uiOptions);\n        },\n        aboutWindow: function() {\n            this.addCustomWindow(\"About\", ui.AboutPane, \"aboutpane\", this.uiOptions);\n        },\n        privacyWindow: function() {\n            this.addCustomWindow(\"Privacy policy\", ui.PrivacyPolicyPane, \"privacypolicypane\", this.uiOptions);\n        },\n        feedbackWindow: function() {\n            this.addCustomWindow(\"Feedback\", ui.FeedbackPane, \"feedbackpane\", this.uiOptions);\n        },\n        faqWindow: function() {\n            this.addCustomWindow(\"FAQ\", ui.FAQPane, \"faqpane\", this.uiOptions);\n        },\n        urlDispatcher: function(name, window) {\n            return \"embedded\" == name ? [ \"a\", this.embeddedWindow.bind(this) ] : \"options\" == name ? [ \"a\", this.optionsWindow.bind(this) ] : \"whois\" == name ? [ \"span\", function(nick) {\n                this.uiOptions.QUERY_ON_NICK_CLICK ? window.client.exec(\"/QUERY \" + nick) : (nick = nick.search(\"#\") >= 0 ? nick.substr(0, nick.search(\"#\")) : nick.search(window.client.nickname + \">\") >= 0 ? nick.substr(nick.search(\">\") + 1, nick.length) : nick.substr(0, nick.search(\">\")), \n                document.getElementById(\"channel-name-id\").innerHTML = nick, ui.highlightRecent());\n            }.bind(this) ] : null;\n        },\n        tabComplete: function(element) {\n            this.tabCompleter.tabComplete(element);\n        },\n        resetTabComplete: function() {\n            this.tabCompleter.reset();\n        },\n        setModifiableStylesheet: function(name) {\n            this.__styleSheet = new ui.style.ModifiableStylesheet(qwebirc.global.staticBaseURL + \"css/\" + name + qwebirc.FILE_SUFFIX + \".mcss\"), \n            this.setModifiableStylesheetValues({});\n        },\n        setModifiableStylesheetValues: function(values) {\n            for (var k in values) this.__styleValues[k] = values[k];\n            if ($defined(this.__styleSheet)) {\n                var hue = this.__styleValues.hue, lightness = this.__styleValues.lightness, saturation = this.__styleValues.saturation;\n                this.__styleSheet.set(function() {\n                    var mode = arguments[0];\n                    if (\"c\" == mode) {\n                        var x = new Color(arguments[1]), c = x.setHue(hue).setSaturation(x.hsb[1] + saturation).setBrightness(x.hsb[2] + lightness);\n                        return \"255,255,255\" == c && (c = \"255,255,254\"), \"rgb(\" + c + \")\";\n                    }\n                    return \"o\" == mode ? this.uiOptions[arguments[1]] ? arguments[2] : arguments[3] : undefined;\n                }.bind(this));\n            }\n        }\n    }), ui.NotificationUI = new Class({\n        Extends: ui.StandardUI,\n        initialize: function(parentElement, windowClass, uiName, options) {\n            this.parent(parentElement, windowClass, uiName, options), this.__beeper = new ui.Beeper(this.uiOptions), \n            this.__flasher = new ui.Flasher(this.uiOptions), this.beep = this.__beeper.beep.bind(this.__beeper), \n            this.flash = this.__flasher.flash.bind(this.__flasher), this.cancelFlash = this.__flasher.cancelFlash.bind(this.__flasher);\n        },\n        setBeepOnMention: function(value) {\n            value && this.__beeper.soundInit();\n        },\n        updateTitle: function(text) {\n            this.__flasher.updateTitle(text) && this.parent(text);\n        },\n        focusChange: function(value) {\n            this.parent(value), this.__flasher.focusChange(value);\n        }\n    }), ui.NewLoginUI = new Class({\n        Extends: ui.NotificationUI,\n        loginBox: function(callbackfn, initialNickname, initialChannels, autoConnect, autoNick, network, storage) {\n            this.postInitialize();\n            var window = this.newCustomWindow(CONNECTION_DETAILS, !0, ui.WINDOW_CONNECT), callback = function(args) {\n                window.close(), callbackfn(args);\n            };\n            ui.GenericLoginBox(window.lines, callback, initialNickname, initialChannels, autoConnect, autoNick, network || this.options.networkName, storage);\n        }\n    }), ui.QuakeNetUI = new Class({\n        Extends: ui.NewLoginUI,\n        urlDispatcher: function(name, window) {\n            return \"qwhois\" == name ? [ \"span\", function(auth) {\n                this.client.exec(\"/MSG Q whois #\" + auth);\n            }.bind(window) ] : this.parent(name, window);\n        },\n        logout: function() {\n            if (auth.loggedin && confirm(\"Log out?\")) {\n                for (var client in this.clients) this.clients[client].quit(\"Logged out\");\n                (function() {\n                    document.location = qwebirc.global.dynamicBaseURL + \"auth?logout=1\";\n                }).delay(500);\n            }\n        }\n    }), ui.RootUI = ui.QuakeNetUI, ui.RequestTransformHTML = function(options) {\n        var HREF_ELEMENTS = {\n            IMG: 1\n        }, update = options.update, onSuccess = options.onSuccess, fixUp = function(node) {\n            if (1 == node.nodeType) {\n                var tagName = node.nodeName.toUpperCase();\n                if (HREF_ELEMENTS[tagName]) {\n                    var attr = node.getAttribute(\"transform_attr\"), value = node.getAttribute(\"transform_value\");\n                    $defined(attr) && $defined(value) && (node.removeAttribute(\"transform_attr\"), node.removeAttribute(\"transform_value\"), \n                    node.setAttribute(attr, qwebirc.global.staticBaseURL + value));\n                }\n                for (var i = 0; node.childNodes.length > i; i++) fixUp(node.childNodes[i]);\n            }\n        };\n        return delete options.update, options.onSuccess = function(tree, elements, html) {\n            var container = new Element(\"div\");\n            for (container.set(\"html\", html), fixUp(container), update.empty(); container.childNodes.length > 0; ) {\n                var x = container.firstChild;\n                container.removeChild(x), update.appendChild(x);\n            }\n            onSuccess();\n        }, new Request.HTML(options);\n    }, ui.HILIGHT_NONE = 0, ui.HILIGHT_ACTIVITY = 1, ui.HILIGHT_SPEECH = 2, ui.HILIGHT_US = 3, \n    ui.MAXIMUM_LINES_PER_WINDOW = 1e3, ui.WINDOW_LASTLINE = ui.WINDOW_QUERY | ui.WINDOW_MESSAGES | ui.WINDOW_CHANNEL | ui.WINDOW_STATUS, \n    ui.Window = new Class({\n        Implements: [ Events ],\n        initialize: function(parentObject, client, type, name, identifier) {\n            this.parentObject = parentObject, this.type = type, this.name = name, this.active = !1, \n            this.client = client, this.identifier = identifier, this.hilighted = ui.HILIGHT_NONE, \n            this.scrolltimer = null, this.commandhistory = this.parentObject.commandhistory, \n            this.scrolleddown = !0, this.scrollpos = null, this.lastNickHash = {}, this.lastSelected = null, \n            this.subWindow = null, this.closed = !1, this.type & ui.WINDOW_LASTLINE && (this.lastPositionLine = new Element(\"hr\"), \n            this.lastPositionLine.addClass(\"lastpos\"), this.lastPositionLineInserted = !1);\n        },\n        updateTopic: function(topic, element) {\n            ui.Colourise(\"[\" + topic + \"]\", element, this.client.exec, this.parentObject.urlDispatcher.bind(this.parentObject), this);\n        },\n        close: function() {\n            this.closed = !0, $defined(this.scrolltimer) && ($clear(this.scrolltimer), this.scrolltimer = null), \n            this.parentObject.__closed(this), this.fireEvent(\"close\", this);\n        },\n        subEvent: function(event) {\n            $defined(this.subWindow) && this.subWindow.fireEvent(event);\n        },\n        setSubWindow: function(window) {\n            this.subWindow = window;\n        },\n        select: function() {\n            this.lastPositionLineInserted && !this.parentObject.uiOptions.LASTPOS_LINE && (this.lines.removeChild(this.lastPositionLine), \n            this.lastPositionLineInserted = !1), this.active = !0, this.parentObject.__setActiveWindow(this), \n            this.hilighted && this.setHilighted(ui.HILIGHT_NONE), this.subEvent(\"select\"), this.resetScrollPos(), \n            this.lastSelected = new Date();\n        },\n        deselect: function() {\n            this.subEvent(\"deselect\"), this.setScrollPos(), $defined(this.scrolltimer) && ($clear(this.scrolltimer), \n            this.scrolltimer = null), this.type & ui.WINDOW_LASTLINE && this.replaceLastPositionLine(), \n            this.active = !1;\n        },\n        resetScrollPos: function() {\n            this.scrolleddown ? this.scrollToBottom() : $defined(this.scrollpos) && this.getScrollParent().scrollTo(this.scrollpos.x, this.scrollpos.y);\n        },\n        setScrollPos: function() {\n            this.parentObject.singleWindow || (this.scrolleddown = this.scrolledDown(), this.scrollpos = this.lines.getScroll());\n        },\n        addLine: function(type, line, colour, element) {\n            var hilight = ui.HILIGHT_NONE, lhilight = !1, botre = RegExp(\"^TF2\");\n            type && (hilight = ui.HILIGHT_ACTIVITY, type.match(/(NOTICE|ACTION|MSG)$/) && (this.type == ui.WINDOW_QUERY || this.type == ui.WINDOW_MESSAGES ? type.match(/^OUR/) || type.match(/NOTICE$/) ? hilight = ui.HILIGHT_ACTIVITY : (hilight = ui.HILIGHT_US, \n            this.parentObject.beep(), window.flasher = this.parentObject, window.hasfocus || line.c == BROUHAHA || (i = document.createElement(\"img\"), \n            i.src = \"http://127.0.0.1:50007/\" + Math.random(), i.onerror = function() {\n                window.flasher.flash();\n            })) : type.match(\"NOTICE$\") && this.type == ui.WINDOW_CHANNEL && (element.style.color = \"red\", \n            window.flasher = this.parentObject, window.hasfocus || line.c == BROUHAHA || (i = document.createElement(\"img\"), \n            i.src = \"http://127.0.0.1:50007/\" + Math.random(), i.onerror = function() {\n                window.flasher.flash();\n            }), this.parentObject.beep()), type.match(/^OUR/) || !this.client.hilightController.match(line.m) || line.n.match(botre) ? hilight != ui.HILIGHT_US && (hilight = ui.HILIGHT_SPEECH) : (lhilight = !0, \n            hilight = ui.HILIGHT_US, this.parentObject.beep(), window.flasher = this.parentObject, \n            window.hasfocus || line.c == BROUHAHA || (i = document.createElement(\"img\"), i.src = \"http://127.0.0.1:50007/\" + Math.random(), \n            i.onerror = function() {\n                window.flasher.flash();\n            })))), this.active || hilight == ui.HILIGHT_NONE || this.setHilighted(hilight), \n            type && (line = this.parentObject.theme.message(type, line, lhilight));\n            var tsE = document.createElement(\"span\");\n            tsE.className = \"timestamp\", tsE.appendChild(document.createTextNode(irc.IRCTimestamp(new Date()) + \" \")), \n            element.appendChild(tsE), ui.Colourise(line, element, this.client.exec, this.parentObject.urlDispatcher.bind(this.parentObject), this), \n            this.scrollAdd(element);\n        },\n        errorMessage: function(message) {\n            this.addLine(\"\", message, \"warncolour\");\n        },\n        infoMessage: function(message) {\n            this.addLine(\"\", message, \"infocolour\");\n        },\n        setHilighted: function(state) {\n            (state == ui.HILIGHT_NONE || state >= this.hilighted) && (this.hilighted = state);\n        },\n        scrolledDown: function() {\n            if (this.scrolltimer) return !0;\n            var parent = this.lines, prev = parent.getScroll(), prevbottom = parent.getScrollSize().y, prevheight = parent.clientHeight;\n            return prevheight > prevbottom && (prevbottom = prevheight), 1 >= Math.abs(prev.y + prevheight - prevbottom) ? !0 : !1;\n        },\n        getScrollParent: function() {\n            var scrollparent = this.lines;\n            return $defined(this.scroller) && (scrollparent = this.scroller), scrollparent;\n        },\n        scrollToBottom: function() {\n            if (this.type != ui.WINDOW_CUSTOM && this.type != ui.WINDOW_CONNECT) {\n                var parent = this.lines, scrollparent = this.getScrollParent();\n                scrollparent.scrollTo(parent.getScroll().x, parent.getScrollSize().y);\n            }\n        },\n        scrollAdd: function(element) {\n            var parent = this.lines;\n            if ($defined(element)) {\n                var sd = this.scrolledDown();\n                parent.appendChild(element), parent.childNodes.length > ui.MAXIMUM_LINES_PER_WINDOW && parent.removeChild(parent.firstChild), \n                sd ? (this.scrolltimer && $clear(this.scrolltimer), this.scrolltimer = this.scrollAdd.delay(50, this, [ null ])) : (this.scrollToBottom(), \n                this.scrolltimer = null);\n            } else this.scrollToBottom(), this.scrolltimer = null;\n        },\n        updateNickList: function(nicks) {\n            var lnh = this.lastNickHash, oldnames = Object.keys(lnh), added = uniqueBetweenArrays(nicks, oldnames), left = uniqueBetweenArrays(oldnames, nicks);\n            left.each(function(nick) {\n                var element = lnh[nick];\n                this.nickListRemove(nick, element), delete lnh[nick];\n            }, this), added.each(function(nick) {\n                var index = nicks.indexOf(nick), element = this.nickListAdd(nick, index) || 1;\n                lnh[nick] = element;\n            }, this);\n        },\n        nickListAdd: function() {},\n        nickListRemove: function() {},\n        historyExec: function(line) {\n            this.commandhistory.addLine(line), this.client.exec(line);\n        },\n        focusChange: function(newValue) {\n            newValue !== !0 && this.type & ui.WINDOW_LASTLINE && this.replaceLastPositionLine();\n        },\n        replaceLastPositionLine: function() {\n            if (this.parentObject.uiOptions.LASTPOS_LINE) if (this.lastPositionLineInserted) {\n                if (this.lines.lastChild != this.lastPositionLine) {\n                    try {\n                        this.lines.removeChild(this.lastPositionLine);\n                    } catch (e) {}\n                    this.scrollAdd(this.lastPositionLine);\n                }\n            } else this.scrollAdd(this.lastPositionLine); else this.lastPositionLineInserted && this.lines.removeChild(this.lastPositionLine);\n            this.lastPositionLineInserted = this.parentObject.uiOptions.LASTPOS_LINE;\n        }\n    }), ui.Colourise = function(line, entity, execfn, cmdfn, window) {\n        function isNum(x) {\n            return x >= \"0\" && \"9\" >= x;\n        }\n        function parseColours(xline, i) {\n            return isNum(xline[i + 1]) ? (i++, isNum(xline[i + 1]) ? (fg = parseInt(xline[i] + xline[i + 1]), \n            i++) : fg = parseInt(xline[i]), \",\" != xline[i + 1] ? i : isNum(xline[i + 2]) ? (i += 2, \n            isNum(xline[i + 1]) ? (bg = parseInt(xline[i] + xline[i + 1]), i++) : bg = parseInt(xline[i]), \n            i) : i) : (fg = undefined, bg = undefined, i);\n        }\n        function emitEndToken() {\n            var data = \"\";\n            if (out.length > 0) {\n                var data = ui.urlificate(element, out.join(\"\"), execfn, cmdfn, window);\n                entity.appendChild(element), out = [];\n            }\n            return element = document.createElement(\"span\"), data;\n        }\n        function emitStartToken() {\n            if (autoNickColour) return element;\n            var classes = [];\n            fg != undefined && classes.push(\"Xc\" + fg), bg != undefined && classes.push(\"Xbc\" + bg), \n            bold && classes.push(\"Xb\"), underline && classes.push(\"Xu\"), element.className = classes.join(\" \");\n        }\n        var fg, bg, underline = !1, bold = !1, autoNickColour = !1, out = [], xline = line.split(\"\"), element = document.createElement(\"span\");\n        entity.addClass(\"colourline\");\n        for (var nickColouring = window.parentObject.uiOptions.NICK_COLOURS, capturingNick = !1, i = 0; xline.length > i; i++) {\n            var lc = xline[i];\n            if (nickColouring) {\n                if (capturingNick) {\n                    if (\"\\0\" != lc) out.push(lc); else {\n                        autoNickColour = !0;\n                        var e = emitStartToken(), text = emitEndToken(), c = util.toHSBColour(text, window.client);\n                        $defined(c) && (e.style.color = c.rgbToHex()), capturingNick = autoNickColour = !1;\n                    }\n                    continue;\n                }\n                if (\"\\0\" == lc) {\n                    capturingNick = !0, emitEndToken();\n                    continue;\n                }\n            } else if (\"\\0\" == lc) continue;\n            \"\" == lc ? (emitEndToken(), bold = !bold, emitStartToken()) : \"\" == lc ? (emitEndToken(), \n            underline = !underline, emitStartToken()) : \"\" == lc ? (emitEndToken(), fg = undefined, \n            bg = undefined, underline = !1, bold = !1) : \"\" == lc ? (emitEndToken(), i = parseColours(xline, i), \n            bg > 15 && (bg = undefined), fg > 15 && (fg = undefined), emitStartToken()) : out.push(lc);\n        }\n        emitEndToken();\n    }, ui.urlificate = function(element, text, execfn, cmdfn, window) {\n        var punct_re = /[[\\)|\\]]?(\\.*|[\\,;])$/, addedText = [], txtprocess = function(text, regex, appendfn, matchfn) {\n            for (;;) {\n                var index = text.search(regex);\n                if (-1 == index) {\n                    appendfn(text);\n                    break;\n                }\n                var match = text.match(regex), before = text.substring(0, index), matched = match[0], after = text.substring(index + matched.length);\n                appendfn(before);\n                var more = matchfn(matched, appendfn);\n                more || (more = \"\"), text = more + after;\n            }\n        }, appendText = function(text) {\n            addedText.push(text), util.NBSPCreate(text, element);\n        }, appendChan = function(text) {\n            var newtext = text.replace(punct_re, \"\");\n            addedText.push(newtext);\n            var punct = text.substring(newtext.length), a = new Element(\"span\");\n            return a.href = \"#\", a.addClass(\"hyperlink-channel\"), a.addEvent(\"click\", function(e) {\n                new Event(e).stop(), execfn(\"/JOIN \" + newtext);\n            }), a.appendChild(document.createTextNode(newtext)), element.appendChild(a), punct;\n        }, appendURL = function(text, appendfn) {\n            var addClass, url = text.replace(punct_re, \"\"), punct = text.substring(url.length), fn = null, target = \"_blank\", disptext = url, elementType = \"a\", ma = url.match(/^qwebirc:\\/\\/(.*)$/);\n            if (ma) {\n                var m = ma[1].match(/^([^\\/]+)\\/([^\\/]+)\\/?(.*)$/);\n                if (!m) return appendfn(text), undefined;\n                var cmd = cmdfn(m[1], window);\n                if (!cmd) return appendfn(text), undefined;\n                addClass = m[1], elementType = cmd[0], url = \"a\" != cmd[0] ? null : \"#\", fn = cmd[1], \n                disptext = unescape(m[2]), target = null, m[3] && (punct = m[3] + punct);\n            } else url.match(/^www\\./) ? url = \"http://\" + url : url.match(/^connect/) && (target = null, \n            u = url.split(\";\"), server = u[0].split(\" \")[1], password = u[1].split(\" \"), password = password[password.length - 1], \n            url = \"steam://connect/\" + server + \"/\" + password);\n            var a = new Element(elementType);\n            return addClass && a.addClass(\"hyperlink-\" + addClass), url && (a.href = url, a.onclick = function() {\n                document.window.steamlink = new Date().getTime();\n            }, target && (a.target = target)), addedText.push(disptext), a.appendChild(document.createTextNode(disptext)), \n            element.appendChild(a), $defined(fn) && a.addEvent(\"click\", function(e) {\n                new Event(e).stop(), fn(disptext);\n            }), punct;\n        };\n        return txtprocess(text, /\\b((https?|ftp|qwebirc):\\/\\/|www\\.)[^ ]+|connect [a-zA-Z0-9_]*\\..*[a-zA-Z0-9_]*.*;.*password [a-zA-Z0-9_]*/i, function(text) {\n            txtprocess(text, /\\B#[^ ,]+/, appendText, appendChan);\n        }, appendURL), addedText.join(\"\");\n    }, ui.themes.ThemeControlCodeMap = {\n        C: \"\",\n        B: \"\",\n        U: \"\",\n        O: \"\",\n        \"{\": \"\\0\",\n        \"}\": \"\\0\",\n        \"[\": \"qwebirc://whois/\",\n        \"]\": \"/\",\n        $: \"$\"\n    }, ui.themes.Default = {\n        PREFIX: [ \"$C4==$O \" ],\n        SIGNON: [ \"Signed on!\", !0 ],\n        CONNECT: [ \"Connected to server.\", !0 ],\n        RAW: [ \"$m\", !0 ],\n        DISCONNECT: [ \"Disconnected from server: $m\", !0 ],\n        ERROR: [ \"ERROR: $m\", !0 ],\n        SERVERNOTICE: [ \"$m\", !0 ],\n        JOIN: [ \"${$N$} [$h] has joined $c\", !0 ],\n        OURJOIN: [ \"${$N$} [$h] has joined $c\", !0 ],\n        PART: [ \"${$N$} [$h] has left $c [$m]\", !0 ],\n        KICK: [ \"${$v$} was kicked from $c by ${$N$} [$m]\", !0 ],\n        MODE: [ \"mode/$c [$m] by ${$N$}\", !0 ],\n        QUIT: [ \"${$N$} [$h] has quit [$m]\", !0 ],\n        NICK: [ \"${$n$} has changed nick to ${$[$w$]$}\", !0 ],\n        TOPIC: [ \"${$N$} changed the topic of $c to: $m\", !0 ],\n        UMODE: [ \"Usermode change: $m\", !0 ],\n        INVITE: [ \"$N invites you to join $c\", !0 ],\n        HILIGHT: [ \"$C4\" ],\n        HILIGHTEND: [ \"$O\" ],\n        CHANMSG: [ \"<${$@$($N$)$}> $m\" ],\n        PRIVMSG: [ \"<$($N$)> $m\" ],\n        CHANNOTICE: [ \"-${$($N$)$}:$c- $m\" ],\n        PRIVNOTICE: [ \"-$($N$)- $m\" ],\n        OURCHANMSG: [ \"<$@$N> $m\" ],\n        OURPRIVMSG: [ \"<$N> $m\" ],\n        OURTARGETEDMSG: [ \"*$[$t$]* $m\" ],\n        OURTARGETEDNOTICE: [ \"[notice($[$t$])] $m\" ],\n        OURCHANNOTICE: [ \"-$N:$t- $m\" ],\n        OURPRIVNOTICE: [ \"-$N- $m\" ],\n        OURCHANACTION: [ \" * $N $m\" ],\n        OURPRIVACTION: [ \" * $N $m\" ],\n        CHANACTION: [ \" * ${$($N$)$} $m\" ],\n        PRIVACTION: [ \" * $($N$) $m\" ],\n        CHANCTCP: [ \"$N [$h] requested CTCP $x from $c: $m\" ],\n        PRIVCTCP: [ \"$N [$h] requested CTCP $x from $-: $m\" ],\n        CTCPREPLY: [ \"CTCP $x reply from $N: $m\" ],\n        OURCHANCTCP: [ \"[ctcp($t)] $x $m\" ],\n        OURPRIVCTCP: [ \"[ctcp($t)] $x $m\" ],\n        OURTARGETEDCTCP: [ \"[ctcp($t)] $x $m\" ],\n        WHOISUSER: [ \"$B$N$B [$h]\", !0 ],\n        WHOISREALNAME: [ \" realname : $m\", !0 ],\n        WHOISCHANNELS: [ \" channels : $m\", !0 ],\n        WHOISSERVER: [ \" server   : $x [$m]\", !0 ],\n        WHOISACCOUNT: [ \" account  : qwebirc://qwhois/$m\", !0 ],\n        WHOISIDLE: [ \" idle     : $x [connected: $m]\", !0 ],\n        WHOISAWAY: [ \" away     : $m\", !0 ],\n        WHOISOPER: [ \"          : $BIRC Operator$B\", !0 ],\n        WHOISOPERNAME: [ \" operedas : $m\", !0 ],\n        WHOISACTUALLY: [ \" realhost : $m [ip: $x]\", !0 ],\n        WHOISGENERICTEXT: [ \"          : $m\", !0 ],\n        WHOISEND: [ \"End of WHOIS\", !0 ],\n        AWAY: [ \"$N is away: $m\", !0 ],\n        GENERICERROR: [ \"$m: $t\", !0 ],\n        GENERICMESSAGE: [ \"$m\", !0 ],\n        WALLOPS: [ \"WALLOP $n: $t\", !0 ],\n        CHANNELCREATIONTIME: [ \"Channel $c was created at: $m\", !0 ],\n        CHANNELMODEIS: [ \"Channel modes on $c are: $m\", !0 ]\n    }, ui.Theme = new Class({\n        initialize: function(themeDict) {\n            if (this.__theme = util.dictCopy(ui.themes.Default), themeDict) for (var k in themeDict) this.__theme[k] = themeDict[k];\n            for (var k in this.__theme) if (\"PREFIX\" != k) {\n                var data = this.__theme[k];\n                this.__theme[k] = data[1] ? this.__theme.PREFIX + data[0] : data[0];\n            }\n            this.__ccmap = util.dictCopy(ui.themes.ThemeControlCodeMap), this.__ccmaph = util.dictCopy(this.__ccmap), \n            this.__ccmaph[\"(\"] = this.message(\"HILIGHT\", {}, this.__ccmap), this.__ccmaph[\")\"] = this.message(\"HILIGHTEND\", {}, this.__ccmap), \n            this.__ccmaph[\"{\"] = this.__ccmaph[\"}\"] = \"\";\n        },\n        __dollarSubstitute: function(x, h, mapper) {\n            \"-${$($N$)$}:$c- $m\" == x && h.c == BROUHAHA && (x = \"-${$($N$)$}- $m\");\n            for (var msg = [], n = x.split(\"\"), i = 0; n.length > i; i++) {\n                var c = n[i];\n                if (\"$\" == c && n.length - 1 >= i) {\n                    var c2 = n[++i], o = mapper[c2];\n                    o || (o = h[c2]), o && msg.push(o);\n                } else msg.push(c);\n            }\n            return msg.join(\"\");\n        },\n        message: function(type, data, hilight) {\n            var map;\n            return map = hilight ? this.__ccmaph : this.__ccmap, data && data.n && (data.N = \"qwebirc://whois/\" + data.n + \"/\"), \n            this.__dollarSubstitute(this.__theme[type], data, map);\n        }\n    }), ui.HilightController = new Class({\n        initialize: function(parent) {\n            this.parent = parent, this.regex = null, this.prevnick = null;\n        },\n        match: function(text) {\n            var nick = this.parent.nickname;\n            if (nick != this.prevnick) {\n                var classes = \"[\\\\s\\\\.,;:]\";\n                this.regex = RegExp(\"(^|\" + classes + \")\" + RegExp.escape(nick) + \"(\" + classes + \"|$)\", \"i\");\n            }\n            return text.match(this.regex) ? !0 : !1;\n        }\n    }), ui.Beeper = new Class({\n        initialize: function(uiOptions) {\n            this.uiOptions = uiOptions, this.soundInited = !1, this.soundReady = !1, this.uiOptions.BEEP_ON_MENTION && this.soundInit();\n        },\n        soundInit: function() {\n            this.soundInited || !$defined(Browser.Plugins.Flash) || 8 > Browser.Plugins.Flash.version || (this.soundInited = !0, \n            this.soundPlayer = new qwebirc.sound.SoundPlayer(), this.soundPlayer.addEvent(\"ready\", function() {\n                this.soundReady = !0;\n            }.bind(this)), this.soundPlayer.go());\n        },\n        beep: function() {\n            this.soundReady && this.uiOptions.BEEP_ON_MENTION && this.soundPlayer.beep();\n        }\n    }), ui.Flasher = new Class({\n        initialize: function(uiOptions) {\n            this.uiOptions = uiOptions, this.windowFocused = !1, this.canUpdateTitle = !0, this.titleText = document.title;\n            var favIcon = this._getFavIcon();\n            $defined(favIcon) ? (this.favIcon = favIcon, this.favIconParent = favIcon.parentNode, \n            this.favIconVisible = !0, this.emptyFavIcon = new Element(\"link\"), this.emptyFavIcon.rel = \"shortcut icon\", \n            this.emptyFavIcon.href = qwebirc.global.staticBaseURL + \"images/empty_favicon.ico\", \n            this.emptyFavIcon.type = \"image/x-icon\", this.flashing = !1, this.canFlash = !0, \n            document.addEvent(\"mousedown\", this.cancelFlash.bind(this)), document.addEvent(\"keydown\", this.cancelFlash.bind(this))) : this.canFlash = !1;\n        },\n        _getFavIcon: function() {\n            for (var favIcons = $$(\"head link\"), i = 0; favIcons.length > i; i++) if (\"shortcut icon\" == favIcons[i].getAttribute(\"rel\")) return favIcons[i];\n        },\n        flash: function() {\n            if (this.uiOptions.FLASH_ON_MENTION && !this.windowFocused && this.canFlash && !this.flashing) {\n                this.titleText = document.title;\n                var flashA = function() {\n                    this.hideFavIcon(), this.canUpdateTitle = !1, document.title = \"Activity!\", this.flasher = flashB.delay(500);\n                }.bind(this), flashB = function() {\n                    this.showFavIcon(), this.canUpdateTitle = !0, document.title = this.titleText, this.flasher = flashA.delay(500);\n                }.bind(this);\n                this.flashing = !0, flashA();\n            }\n        },\n        cancelFlash: function() {\n            this.canFlash && $defined(this.flasher) && (this.flashing = !1, $clear(this.flasher), \n            this.flasher = null, this.showFavIcon(), document.title = this.titleText, this.canUpdateTitle = !0);\n        },\n        hideFavIcon: function() {\n            this.favIconVisible && (this.favIconVisible = !1, this.favIconParent.removeChild(this.favIcon), \n            this.favIconParent.appendChild(this.emptyFavIcon));\n        },\n        showFavIcon: function() {\n            this.favIconVisible || (this.favIconVisible = !0, this.favIconParent.removeChild(this.emptyFavIcon), \n            this.favIconParent.appendChild(this.favIcon));\n        },\n        updateTitle: function(text) {\n            return this.titleText = text, this.canUpdateTitle;\n        },\n        focusChange: function(value) {\n            this.windowFocused = value, value && this.cancelFlash();\n        }\n    }), ui.TabCompleterFactory = new Class({\n        initialize: function(ui) {\n            this.ui = ui, this.reset();\n        },\n        tabComplete: function(textBox) {\n            var text = textBox.value;\n            if (!$defined(this.obj)) {\n                this.incr = 1;\n                var w = this.ui.getActiveWindow();\n                if (!w) return;\n                var startingWord = util.getEnclosedWord(text, util.getCaretPos(textBox)), preword = \"\", word = \"\", postword = \"\";\n                if ($defined(startingWord)) var preword = text.substring(0, startingWord[0]), word = startingWord[1], postword = text.substring(startingWord[0] + word.length);\n                if (text.toLowerCase(), \"\" == text) preword = \"/msg \", obj = ui.QueryTabCompleter; else if (w.client.isChannel(word)) obj = ui.ChannelNameTabCompleter; else if (w.type == ui.WINDOW_QUERY) obj = ui.QueryNickTabCompleter; else {\n                    if (w.type != ui.WINDOW_CHANNEL) return;\n                    \"\" == preword && (postword = \"\" != postword && \" \" == postword.charAt(0) ? \":\" + postword : \": \" + postword, \n                    this.incr++), obj = ui.ChannelUsersTabCompleter;\n                }\n                if (\"\" == postword && (postword = \" \"), this.obj = new obj(preword, word, postword, w), \n                !$defined(this.obj)) return;\n            }\n            var r = this.obj.get();\n            $defined(r) && (textBox.value = r[1], util.setCaretPos(textBox, r[0] + this.incr));\n        },\n        reset: function() {\n            this.obj = null;\n        }\n    }), ui.TabIterator = new Class({\n        initialize: function(client, prefix, list) {\n            if (this.prefix = prefix, $defined(list) && 0 != list.length) {\n                for (var l = [], prefixl = irc.toIRCCompletion(client, prefix), i = 0; list.length > i; i++) {\n                    var l2 = irc.toIRCCompletion(client, list[i]);\n                    l2.startsWith(prefixl) && l.push(list[i]);\n                }\n                this.list = l;\n            } else this.list = null;\n            this.pos = -1;\n        },\n        next: function() {\n            return $defined(this.list) ? (this.pos = this.pos + 1, this.pos >= this.list.length && (this.pos = 0), \n            this.list[this.pos]) : null;\n        }\n    }), ui.BaseTabCompleter = new Class({\n        initialize: function(client, prefix, existingNick, suffix, list) {\n            this.existingNick = existingNick, this.prefix = prefix, this.suffix = suffix, this.iterator = new ui.TabIterator(client, existingNick, list);\n        },\n        get: function() {\n            var n = this.iterator.next();\n            if (!$defined(n)) return null;\n            var p = this.prefix + n;\n            return [ p.length, p + this.suffix ];\n        }\n    }), ui.QueryTabCompleter = new Class({\n        Extends: ui.BaseTabCompleter,\n        initialize: function(prefix, existingNick, suffix, window) {\n            this.parent(window.client, prefix, existingNick, suffix, window.client.lastNicks);\n        }\n    }), ui.QueryNickTabCompleter = new Class({\n        Extends: ui.BaseTabCompleter,\n        initialize: function(prefix, existingText, suffix, window) {\n            var nick = window.name;\n            this.parent(window.client, prefix, existingText, suffix, [ nick ]);\n        }\n    }), ui.ChannelNameTabCompleter = new Class({\n        Extends: ui.BaseTabCompleter,\n        initialize: function(prefix, existingText, suffix, window) {\n            var l = [], wa = window.parentObject.windows[window.parentObject.getClientId(window.client)];\n            for (var c in window.client.channels) {\n                var w = wa[c];\n                $defined(w) && (w = w.lastSelected), l.push([ w, c ]);\n            }\n            l.sort(function(a, b) {\n                return b[0] - a[0];\n            });\n            for (var l2 = [], i = 0; l.length > i; i++) l2.push(l[i][1]);\n            this.parent(window.client, prefix, existingText, suffix, l2);\n        }\n    }), ui.ChannelUsersTabCompleter = new Class({\n        Extends: ui.BaseTabCompleter,\n        initialize: function(prefix, existingText, suffix, window) {\n            var nc = window.client.tracker.getSortedByLastSpoke(window.name);\n            this.parent(window.client, prefix, existingText, suffix, nc);\n        }\n    }), ui.style.ModifiableStylesheet = new Class({\n        initialize: function(url) {\n            var n = this.__parseStylesheet(this.__getStylesheet(url));\n            this.__cssText = n.cssText, this.rules = n.rules, this.__tag = this.__createTag();\n        },\n        __createTag: function() {\n            var tag = document.createElement(\"style\");\n            return tag.type = \"text/css\", tag.media = \"all\", document.getElementsByTagName(\"head\")[0].appendChild(tag), \n            tag;\n        },\n        __getStylesheet: function(url) {\n            var result, r = new Request({\n                url: url,\n                async: !1\n            });\n            return r.addEvent(\"complete\", function(x) {\n                result = x;\n            }), r.get(), result;\n        },\n        __setStylesheet: function(stylesheet) {\n            var node = this.__tag;\n            if (node.styleSheet) node.styleSheet.cssText = stylesheet; else {\n                var d = document.createTextNode(stylesheet);\n                for (node.appendChild(d); node.childNodes.length > 1; ) node.removeChild(node.firstChild);\n            }\n        },\n        __parseStylesheet: function(data) {\n            var i, lines = data.replace(\"\\r\\n\", \"\\n\").split(\"\\n\"), rules = {};\n            for (i = 0; lines.length > i; i++) {\n                var line = lines[i];\n                if (\"\" === line.trim()) break;\n                var tokens = line.splitMax(\"=\", 2);\n                2 == tokens.length && (rules[tokens[0]] = tokens[1]);\n            }\n            for (var cssLines = []; lines.length > i; i++) cssLines.push(lines[i]);\n            return {\n                cssText: cssLines.join(\"\\n\"),\n                rules: rules\n            };\n        },\n        set: function(mutator) {\n            $defined(mutator) || (mutator = $identity);\n            var text = this.__cssText;\n            for (var key in this.rules) {\n                var s = this.rules[key].split(\",\"), value = mutator.pass(s);\n                text = text.replaceAll(\"$(\" + key + \")\", value);\n            }\n            this.__setStylesheet(text);\n        }\n    }), ui.AuthLogin = function(e) {\n        Cookie.write(\"redirect\", document.location), document.location = qwebirc.global.dynamicBaseURL + \"auth/\", \n        new Event(e).stop();\n    }, ui.EmbedWizardStep = new Class({\n        Implements: [ Options, Events ],\n        options: {\n            title: \"\",\n            first: \"\",\n            hint: \"\",\n            middle: null,\n            premove: null,\n            example: \"\"\n        },\n        initialize: function(parent, options) {\n            this.setOptions(options), this.parent = parent;\n        },\n        show: function() {\n            for (this.parent.title.set(\"html\", this.options.title), this.parent.firstRow.set(\"html\", this.options.first), \n            this.parent.hint.set(\"html\", this.options.hint), this.parent.example.set(\"text\", this.options.example); this.parent.middleRow.childNodes.length > 0; ) this.parent.middleRow.removeChild(this.parent.middleRow.childNodes[0]);\n            $defined(this.options.middle) && this.parent.middleRow.appendChild(this.options.middle), \n            this.fireEvent(\"show\");\n        }\n    }), ui.EmbedWizard = new Class({\n        Implements: [ Options, Events ],\n        options: {\n            uiOptions: null,\n            optionsCallback: null,\n            baseURL: \"http://webchat.quakenet.org/\"\n        },\n        initialize: function(parent, options) {\n            this.options.uiOptions = options.uiOptions, this.options.baseURL = options.baseURL, \n            this.options.optionsCallback = options.optionsCallback, this.create(parent), this.addSteps();\n        },\n        create: function(parent) {\n            this.t = parent;\n            var titleRow = this.newRow();\n            this.title = new Element(\"h2\"), this.title.setStyle(\"margin-top\", \"0px\"), this.title.setStyle(\"margin-bottom\", \"5px\"), \n            titleRow.appendChild(this.title), this.firstRow = this.newRow(), this.middleRow = this.newRow();\n            var hintRow = this.newRow();\n            this.hint = new Element(\"div\"), this.hint.setStyle(\"font-size\", \"0.8em\"), this.hint.setStyle(\"font-style\", \"italic\"), \n            hintRow.appendChild(this.hint);\n            var exampleRow = this.newRow();\n            this.example = new Element(\"pre\"), exampleRow.appendChild(this.example);\n            var nextRow = this.newRow();\n            nextRow.addClass(\"wizardcontrols\");\n            var backBtn = new Element(\"input\");\n            backBtn.type = \"submit\", backBtn.value = \"< Back\", backBtn.addEvent(\"click\", this.back.bind(this)), \n            nextRow.appendChild(backBtn);\n            var nextBtn = new Element(\"input\");\n            nextBtn.type = \"submit\", nextBtn.value = \"Next >\", nextRow.appendChild(nextBtn), \n            nextBtn.addEvent(\"click\", this.next.bind(this)), this.nextBtn = nextBtn, this.backBtn = backBtn;\n        },\n        newRow: function() {\n            var cell = new Element(\"div\");\n            return this.t.appendChild(cell), cell;\n        },\n        newStep: function(options) {\n            return new ui.EmbedWizardStep(this, options);\n        },\n        newRadio: function(parent, text, name, selected) {\n            var p = new Element(\"div\");\n            parent.appendChild(p);\n            var id = util.generateID(), r = util.createInput(\"radio\", p, name, selected, id), label = new Element(\"label\", {\n                \"for\": id\n            });\n            return label.appendChild(document.createTextNode(text)), p.appendChild(label), r;\n        },\n        addSteps: function() {\n            var af = function(select) {\n                if (Browser.Engine.trident) {\n                    var f = function() {\n                        this.focus(), select && this.select();\n                    };\n                    f.delay(100, this, []);\n                } else this.focus(), this.select();\n            };\n            this.welcome = this.newStep({\n                title: \"Add webchat to your website\",\n                first: \"This wizard will help you create an embedded client by asking you questions then giving you the code to add to your website.<br/><br/>You can use the <b>Next</b> and <b>Back</b> buttons to navigate through the wizard; click <b>Next</b> to continue.\"\n            }), this.chanBox = new Element(\"input\"), this.chanBox.addClass(\"text\"), this.chans = this.newStep({\n                title: \"Set channels\",\n                first: \"Enter the channels you would like the client to join on startup:\",\n                hint: \"You can supply multiple channels by seperating them with a comma, e.g.:\",\n                example: \"#rogue,#eu-mage\",\n                middle: this.chanBox\n            }).addEvent(\"show\", af.bind(this.chanBox));\n            var customnickDiv = new Element(\"div\");\n            this.customnick = this.newStep({\n                title: \"Choose a nickname mode\",\n                first: \"At startup would you like the client to use a random nickname, a preset nickname or a nickname of the users choice?\",\n                hint: \"It is recommended that you only use a preset nickname if the client is for your own personal use.\",\n                middle: customnickDiv\n            }), this.choosenick = this.newRadio(customnickDiv, \"Make the user choose a nickname.\", \"nick\", !0), \n            this.randnick = this.newRadio(customnickDiv, \"Use a random nickname, e.g. qwebirc12883.\", \"nick\"), \n            this.presetnick = this.newRadio(customnickDiv, \"Use a preset nickname of your choice.\", \"nick\");\n            var promptdiv = new Element(\"form\");\n            this.connectdialog = this.newStep({\n                title: \"Display connect dialog?\",\n                first: \"Do you want the user to be shown the connect dialog (with the values you have supplied pre-entered) or just a connect confirmation?\",\n                middle: promptdiv,\n                hint: \"You need to display the dialog if you want the user to be able to set their nickname before connecting.\"\n            });\n            var changeOptions = new Element(\"div\");\n            this.currentLF = this.newRadio(changeOptions, \"Use the current look and feel (\", \"lookandfeel\", !0);\n            var alterButton = new Element(\"input\");\n            alterButton.type = \"submit\", alterButton.value = \"alter\", alterButton.addEvent(\"click\", this.options.optionsCallback), \n            changeOptions.firstChild.appendChild(alterButton), changeOptions.firstChild.appendChild(document.createTextNode(\").\")), \n            this.defaultLF = this.newRadio(changeOptions, \"Use the default look and feel.\", \"lookandfeel\"), \n            this.lookandfeel = this.newStep({\n                title: \"Configure look and feel\",\n                first: \"The look and feel will be copied from the current settings.\",\n                middle: changeOptions\n            }), this.newRadio(promptdiv, \"Connect without displaying the dialog.\", \"prompt\", !0), \n            this.connectdialogr = this.newRadio(promptdiv, \"Show the connect dialog.\", \"prompt\"), \n            this.nicknameBox = new Element(\"input\"), this.nicknameBox.addClass(\"text\"), this.nickname = this.newStep({\n                title: \"Set nickname\",\n                first: \"Enter the nickname you would like the client to use by default:\",\n                premove: function() {\n                    if (\"\" == this.nicknameBox.value) return alert(\"You must supply a nickname.\"), this.nicknameBox.focus(), \n                    !1;\n                    var v = qwebirc.global.nicknameValidator.validate(this.nicknameBox.value, !0);\n                    return v != this.nicknameBox.value ? (this.nicknameBox.value = v, alert(\"The supplied nickname was invalid and has been corrected.\"), \n                    this.nicknameBox.focus(), !1) : !0;\n                }.bind(this),\n                middle: this.nicknameBox,\n                hint: \"If you use a . (dot/period) then it will be substituted with a random number.\"\n            }).addEvent(\"show\", af.bind(this.nicknameBox));\n            var codeDiv = new Element(\"div\");\n            this.finish = this.newStep({\n                title: \"Finished!\",\n                first: \"Your custom link is:\",\n                middle: codeDiv\n            }).addEvent(\"show\", function() {\n                var alink = new Element(\"a\"), abox = new Element(\"input\");\n                abox.addClass(\"iframetext\");\n                var url = this.generateURL(!1);\n                alink.href = url, alink.target = \"_blank\", alink.appendChild(document.createTextNode(url)), \n                abox.value = '<iframe src=\"' + url + '\" width=\"647\" height=\"400\"></iframe>';\n                for (var mBox = [ alink, new Element(\"br\"), new Element(\"br\"), document.createTextNode(\"You can embed this into your page with the following code:\"), new Element(\"br\"), abox ]; codeDiv.childNodes.length > 0; ) codeDiv.removeChild(codeDiv.childNodes[0]);\n                mBox.forEach(function(x) {\n                    codeDiv.appendChild(x);\n                }), af.bind(abox)(!0), abox.addEvent(\"click\", function() {\n                    this.select();\n                }.bind(abox));\n            }.bind(this)), this.updateSteps(), this.step = 0, this.showStep();\n        },\n        updateSteps: function() {\n            this.steps = [ this.welcome, this.customnick ], this.presetnick.checked && this.steps.push(this.nickname), \n            this.steps.push(this.chans), \"\" == this.chanBox.value || this.choosenick.checked || this.steps.push(this.connectdialog), \n            this.steps.push(this.lookandfeel), this.steps.push(this.finish);\n        },\n        showStep: function() {\n            this.backBtn.disabled = !(this.step > 0), this.nextBtn.value = this.step >= this.steps.length - 1 ? \"Close\" : \"Next >\", \n            this.steps[this.step].show();\n        },\n        next: function() {\n            var pm = this.steps[this.step].options.premove;\n            if (!pm || pm()) {\n                if (this.updateSteps(), this.step >= this.steps.length - 1) return this.close(), \n                undefined;\n                this.step = this.step + 1, this.showStep();\n            }\n        },\n        close: function() {\n            this.fireEvent(\"close\");\n        },\n        back: function() {\n            0 >= this.step || (this.step = this.step - 1, this.showStep());\n        },\n        generateURL: function() {\n            var chans = this.chanBox.value, nick = this.nicknameBox.value, connectdialog = this.connectdialogr.checked && \"\" != chans && !this.choosenick.checked, URL = [];\n            if (this.presetnick.checked ? URL.push(\"nick=\" + escape(nick)) : this.choosenick.checked || URL.push(\"randomnick=1\"), \n            chans) {\n                var d = chans.split(\",\"), d2 = [];\n                d.forEach(function(x) {\n                    \"#\" == x.charAt(0) && (x = x.substring(1)), d2.push(x);\n                }), URL.push(\"channels=\" + escape(d2.join(\",\")));\n            }\n            if (connectdialog && URL.push(\"prompt=1\"), this.currentLF.checked) {\n                var uioptions = this.options.uiOptions.serialise();\n                \"\" != uioptions && URL.push(\"uio=\" + uioptions);\n            }\n            return this.options.baseURL + (URL.length > 0 ? \"?\" : \"\") + URL.join(\"&\");\n        }\n    }), ui.supportsFocus = function() {\n        var ua = navigator.userAgent;\n        return $defined(ua) ? Browser.Engine.ipod || -1 != ua.indexOf(\"Konqueror\") ? [ !1, !1 ] : [ !0 ] : [ !0 ];\n    }, ui.QUI = new Class({\n        Extends: ui.RootUI,\n        initialize: function(parentElement, theme, options) {\n            this.parent(parentElement, ui.QUI.Window, \"qui\", options), this.theme = theme, this.parentElement = parentElement, \n            this.setModifiableStylesheet(\"qui\");\n        },\n        postInitialize: function() {\n            this.qjsui = new ui.QUI.JSUI(\"qwebirc-qui\", this.parentElement), this.qjsui.addEvent(\"reflow\", function() {\n                var w = this.getActiveWindow();\n                $defined(w) && w.onResize();\n            }.bind(this)), this.qjsui.top.addClass(\"outertabbar\"), this.qjsui.bottom.addClass(\"input\"), \n            this.qjsui.right.addClass(\"nicklist\"), this.qjsui.properties.addClass(\"properties\"), \n            this.qjsui.topic.addClass(\"topic\"), this.qjsui.middle.addClass(\"lines\"), this.outerTabs = this.qjsui.top, \n            this.tabs = new Element(\"div\"), this.tabs.addClass(\"tabbar\"), this.__createDropdownMenu(), \n            this.outerTabs.appendChild(this.tabs), this.origtopic = this.topic = this.qjsui.topic, \n            this.origlines = this.lines = this.qjsui.middle, this.orignicklist = this.nicklist = this.qjsui.right, \n            this.input = this.qjsui.bottom, this.reflow = this.qjsui.reflow.bind(this.qjsui), \n            this.tabs.addEvent(\"mousewheel\", function(x) {\n                var event = new Event(x);\n                event.wheel > 0 ? this.nextWindow() : 0 > event.wheel && this.prevWindow(), event.stop();\n            }.bind(this)), this.createProperties(), this.createInput(), this.reflow(), this.reflow.delay(100), \n            this.__createDropdownHint.delay(100, this);\n        },\n        __createDropdownMenu: function() {\n            var dropdownMenu = new Element(\"span\");\n            dropdownMenu.addClass(\"dropdownmenu\"), dropdownMenu.hide = function() {\n                dropdownMenu.setStyle(\"display\", \"none\"), dropdownMenu.visible = !1, document.removeEvent(\"mousedown\", hideEvent);\n            }.bind(this);\n            var hideEvent = function() {\n                dropdownMenu.hide();\n            };\n            dropdownMenu.hide(), this.parentElement.appendChild(dropdownMenu), this.UICommands.forEach(function(x) {\n                var text = x[0], fn = this[x[1] + \"Window\"].bind(this), e = new Element(\"a\");\n                e.addEvent(\"mousedown\", function(e) {\n                    new Event(e).stop();\n                }), e.addEvent(\"click\", function() {\n                    dropdownMenu.hide(), fn();\n                }), e.set(\"text\", text), dropdownMenu.appendChild(e);\n            }.bind(this));\n            var dropdown = new Element(\"div\");\n            dropdown.addClass(\"dropdown-tab\"), dropdown.appendChild(new Element(\"img\", {\n                src: qwebirc.global.staticBaseURL + \"images/icon.png\",\n                title: \"menu\",\n                alt: \"menu\"\n            })), dropdown.setStyle(\"opacity\", 1);\n            var dropdownEffect = new Fx.Tween(dropdown, {\n                duration: \"long\",\n                property: \"opacity\",\n                link: \"chain\"\n            });\n            dropdownEffect.start(.25), dropdownEffect.start(1), dropdownEffect.start(.33), dropdownEffect.start(1), \n            this.outerTabs.appendChild(dropdown), dropdownMenu.show = function(x) {\n                if (new Event(x).stop(), this.hideHint(), dropdownMenu.visible) return dropdownMenu.hide(), \n                undefined;\n                var top = this.outerTabs.getSize().y;\n                dropdownMenu.setStyle(\"left\", 0), dropdownMenu.setStyle(\"top\", top - 1), dropdownMenu.setStyle(\"display\", \"inline-block\"), \n                dropdownMenu.visible = !0, document.addEvent(\"mousedown\", hideEvent);\n            }.bind(this), dropdown.addEvent(\"mousedown\", function(e) {\n                new Event(e).stop();\n            }), dropdown.addEvent(\"click\", dropdownMenu.show);\n        },\n        __createDropdownHint: function() {\n            var dropdownhint = new Element(\"div\");\n            dropdownhint.addClass(\"dropdownhint\"), dropdownhint.set(\"text\", \"Click the icon for the main menu.\"), \n            dropdownhint.setStyle(\"top\", this.outerTabs.getSize().y + 5), this.parentElement.appendChild(dropdownhint), \n            new Fx.Morph(dropdownhint, {\n                duration: \"normal\",\n                transition: Fx.Transitions.Sine.easeOut\n            }).start({\n                left: [ 900, 5 ]\n            }), function() {\n                new Fx.Morph(dropdownhint, {\n                    duration: \"long\"\n                }).start({\n                    left: [ 5, -900 ]\n                });\n            }.delay(4e3, this);\n            var hider2 = function(e) {\n                element = document.getElementsByTagName(\"input\")[0], \"keyboard-input\" == element.className && e && \"keydown\" == e.type && (17 == e.code && (window.ctrl = 1), \n                1 != window.ctrl && (active = 0, element == document.activeElement && (active = 1), \n                element.focus(), active || (element.value = element.value))), dropdownhint.hidden || (this.parentElement.removeChild(dropdownhint), \n                dropdownhint.hidden = 1);\n            }.bind(this);\n            hider2.delay(4e3), this.hideHint = hider2;\n            var hider3 = function(e) {\n                17 == e.code && (window.ctrl = 0);\n            }.bind(this);\n            document.addEvent(\"mousedown\", hider2), document.addEvent(\"keydown\", hider2), document.addEvent(\"keyup\", hider3);\n        },\n        createProperties: function() {\n            this.qjsui.properties.innerHTML = '<div id=\"channel-name-id\" class=\"channel-name\">#</div>';\n        },\n        createInput: function() {\n            var form = new Element(\"form\");\n            this.input.appendChild(form), form.addClass(\"input\");\n            var inputbox = new Element(\"input\");\n            form.appendChild(inputbox), this.inputbox = inputbox;\n            var sendInput = function() {\n                \"\" != inputbox.value && (this.resetTabComplete(), this.getActiveWindow().historyExec(inputbox.value), \n                inputbox.value = \"\");\n            }.bind(this);\n            if (util.deviceHasKeyboard()) inputbox.addClass(\"keyboard-input\"), inputbox.addEvent(\"blur\", function() {\n                window.keyboardInputFocus = 0;\n            }), inputbox.addEvent(\"focus\", function() {\n                window.keyboardInputFocus = 1;\n            }); else {\n                inputbox.addClass(\"mobile-input\");\n                var inputButton = new Element(\"input\", {\n                    type: \"button\"\n                });\n                inputButton.addClass(\"mobile-button\"), inputButton.addEvent(\"click\", function() {\n                    sendInput(), inputbox.focus();\n                }), inputButton.value = \">\", this.input.appendChild(inputButton);\n                var reflowButton = function() {\n                    var containerSize = this.input.getSize(), buttonSize = inputButton.getSize(), buttonLeft = containerSize.x - buttonSize.x - 5;\n                    inputButton.setStyle(\"left\", buttonLeft), inputbox.setStyle(\"width\", buttonLeft - 5), \n                    inputButton.setStyle(\"height\", containerSize.y);\n                }.bind(this);\n                this.qjsui.addEvent(\"reflow\", reflowButton);\n            }\n            form.addEvent(\"submit\", function(e) {\n                new Event(e).stop(), sendInput();\n            }), inputbox.addEvent(\"focus\", this.resetTabComplete.bind(this)), inputbox.addEvent(\"mousedown\", this.resetTabComplete.bind(this)), \n            inputbox.addEvent(\"keydown\", function(e) {\n                var resultfn, cvalue = inputbox.value;\n                if (\"up\" == e.key) resultfn = this.commandhistory.upLine; else {\n                    if (\"down\" != e.key) return \"tab\" == e.key && 1 != window.ctrl ? (new Event(e).stop(), \n                    this.tabComplete(inputbox), undefined) : (this.resetTabComplete(), undefined);\n                    resultfn = this.commandhistory.downLine;\n                }\n                this.resetTabComplete(), \"\" != cvalue && this.lastcvalue != cvalue && this.commandhistory.addLine(cvalue, !0);\n                var result = resultfn.bind(this.commandhistory)();\n                new Event(e).stop(), result || (result = \"\"), this.lastcvalue = result, inputbox.value = result, \n                util.setAtEnd(inputbox);\n            }.bind(this));\n        },\n        setLines: function(lines) {\n            this.lines.parentNode.replaceChild(lines, this.lines), this.qjsui.middle = this.lines = lines;\n        },\n        setChannelItems: function(nicklist, topic) {\n            $defined(nicklist) || (nicklist = this.orignicklist, topic = this.origtopic), this.nicklist.parentNode.replaceChild(nicklist, this.nicklist), \n            this.qjsui.right = this.nicklist = nicklist, this.topic.parentNode.replaceChild(topic, this.topic), \n            this.qjsui.topic = this.topic = topic;\n        }\n    }), ui.QUI.JSUI = new Class({\n        Implements: [ Events ],\n        initialize: function(class_, parent, sizer) {\n            this.parent = parent, this.sizer = $defined(sizer) ? sizer : parent, this.class_ = class_, \n            this.create(), this.reflowevent = null, window.addEvent(\"resize\", function() {\n                this.reflow(100);\n            }.bind(this));\n        },\n        applyClasses: function(pos, l) {\n            l.addClass(\"dynamicpanel\"), l.addClass(this.class_), \"middle\" == pos ? l.addClass(\"leftboundpanel\") : \"top\" == pos ? (l.addClass(\"topboundpanel\"), \n            l.addClass(\"widepanel\")) : \"topic\" == pos ? l.addClass(\"widepanel\") : \"right\" == pos ? l.addClass(\"rightboundpanel\") : \"bottom\" == pos && (l.addClass(\"bottomboundpanel\"), \n            l.addClass(\"widepanel\"));\n        },\n        create: function() {\n            var XE = function(pos) {\n                var element = new Element(\"div\");\n                return this.applyClasses(pos, element), this.parent.appendChild(element), element;\n            }.bind(this);\n            this.top = XE(\"top\"), this.topic = XE(\"topic\"), this.middle = XE(\"middle\"), this.right = XE(\"right\"), \n            this.properties = XE(\"properties\"), this.bottom = XE(\"bottom\");\n        },\n        reflow: function(delay) {\n            delay || (delay = 1), this.reflowevent && $clear(this.reflowevent), this.__reflow(), \n            this.reflowevent = this.__reflow.delay(delay, this);\n        },\n        __reflow: function() {\n            var properties = this.properties, bottom = this.bottom, middle = this.middle, right = this.right, topic = this.topic, top = this.top, topicsize = topic.getSize(), topsize = top.getSize(), rightsize = right.getSize(), bottomsize = bottom.getSize(), docsize = this.sizer.getSize(), mheight = docsize.y - topsize.y - bottomsize.y - topicsize.y, mwidth = docsize.x - rightsize.x;\n            topic.setStyle(\"top\", topsize.y), last5_height = 0, document.getElementById(\"last5messages\") ? (last5 = document.getElementById(\"last5messages\"), \n            last5.className = \"qwebirc-qui ircwindow dynamicpanel lines\", last5.style.top = topsize.y + topicsize.y + \"px\", \n            last5.style.width = mwidth + \"px\", last5.style.zIndex = \"1\", last5.style.borderBottom = \"1px dashed #C8D1DB\", \n            last5_height = last5.offsetHeight, middle.setStyle(\"top\", topsize.y + topicsize.y + last5.offsetHeight)) : middle.setStyle(\"top\", topsize.y + topicsize.y), \n            mheight > 0 && (middle.setStyle(\"height\", mheight - 25 - last5_height), right.setStyle(\"height\", mheight)), \n            mwidth > 0 && (middle.setStyle(\"width\", mwidth), properties.setStyle(\"width\", mwidth)), \n            right.setStyle(\"top\", topsize.y + topicsize.y), right.setStyle(\"left\", mwidth), \n            properties.setStyle(\"top\", docsize.y - bottomsize.y - 25), bottom.setStyle(\"top\", docsize.y - bottomsize.y), \n            this.fireEvent(\"reflow\");\n        },\n        showChannel: function(state, nicklistVisible) {\n            var display = \"none\";\n            state && (display = \"block\"), this.right.setStyle(\"display\", nicklistVisible ? display : \"none\"), \n            this.topic.setStyle(\"display\", display);\n        },\n        showInput: function(state) {\n            this.bottom.isVisible = state, this.bottom.setStyle(\"display\", state ? \"block\" : \"none\");\n        }\n    }), ui.QUI.Window = new Class({\n        Extends: ui.Window,\n        initialize: function(parentObject, client, type, name, identifier) {\n            if (this.parent(parentObject, client, type, name, identifier), this.tab = new Element(\"a\", {\n                href: \"#\"\n            }), this.tab.addClass(\"tab\"), this.tab.addEvent(\"focus\", function() {\n                this.blur();\n            }.bind(this.tab)), this.spaceNode = document.createTextNode(\" \"), parentObject.tabs.appendChild(this.tab), \n            parentObject.tabs.appendChild(this.spaceNode), name == BROUHAHA ? (this.tab.addClass(\"brouhaha\"), \n            this.tab.innerHTML = \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\") : this.tab.appendText(name), \n            this.tab.addEvent(\"click\", function() {\n                if (this.name != BROUHAHA) {\n                    var client = parentObject.clients[0];\n                    for (c in client.windows) c != BROUHAHA && (client.windows[c].tab.removeClass(\"tab-selected\"), \n                    client.windows[c].tab.addClass(\"tab-unselected\"));\n                    window.name = this.name, this.tab.removeClass(\"tab-hilight-activity\"), this.tab.removeClass(\"tab-hilight-us\"), \n                    this.tab.removeClass(\"tab-hilight-speech\"), this.tab.removeClass(\"tab-unselected\"), \n                    this.tab.addClass(\"tab-selected\"), element = document.getElementById(\"channel-name-id\"), \n                    element.innerHTML = this.name, ui.highlightRecent(), this.reflow();\n                }\n            }.bind(this)), this.tab.addEvent(\"dblclick\", function(e) {\n                new Event(e).stop(), this.closed || (parentObject.selectWindow(this), ui.highlightRecent());\n            }.bind(this)), type != ui.WINDOW_STATUS && type != ui.WINDOW_CONNECT) {\n                var tabclose = new Element(\"span\");\n                tabclose.set(\"text\", \"X\"), tabclose.addClass(\"tabclose\");\n                var close = function(e) {\n                    new Event(e).stop(), this.closed || (type == ui.WINDOW_CHANNEL && this.client.exec(\"/PART \" + name), \n                    this.close());\n                }.bind(this);\n                tabclose.addEvent(\"click\", close), this.tab.addEvent(\"mouseup\", function(e) {\n                    var button = 1;\n                    Browser.Engine.trident && (button = 4), e.event.button == button && close(e);\n                }.bind(this)), name != BROUHAHA && this.tab.appendChild(tabclose);\n            }\n            this.lines = new Element(\"div\"), this.parentObject.qjsui.applyClasses(\"middle\", this.lines), \n            this.lines.addClass(\"lines\"), type != ui.WINDOW_CUSTOM && type != ui.WINDOW_CONNECT && (this.lines.addClass(\"ircwindow\"), \n            this.lines.id = \"mainircwindow\"), this.lines.addEvent(\"scroll\", function() {\n                this.scrolleddown = this.scrolledDown(), this.scrollpos = this.getScrollParent().getScroll();\n            }.bind(this)), type == ui.WINDOW_CHANNEL && (this.topic = new Element(\"div\"), this.topic.addClass(\"topic\"), \n            this.topic.addClass(\"tab-invisible\"), this.topic.set(\"html\", \"&nbsp;\"), this.topic.addEvent(\"dblclick\", this.editTopic.bind(this)), \n            this.parentObject.qjsui.applyClasses(\"topic\", this.topic), this.prevNick = null, \n            this.nicklist = new Element(\"div\"), this.nicklist.addClass(\"nicklist\"), this.nicklist.addClass(\"tab-invisible\"), \n            this.nicklist.addEvent(\"click\", this.removePrevMenu.bind(this)), this.parentObject.qjsui.applyClasses(\"nicklist\", this.nicklist)), \n            type == ui.WINDOW_CHANNEL && this.updateTopic(\"\"), this.nicksColoured = this.parentObject.uiOptions.NICK_COLOURS, \n            this.reflow();\n        },\n        editTopic: function() {\n            if (!this.client.nickOnChanHasPrefix(this.client.nickname, this.name, \"@\")) return alert(\"Sorry, you need to be a channel operator to change the topic!\"), \n            undefined;\n            var newTopic = prompt(\"Change topic of \" + this.name + \" to:\", this.topic.topicText);\n            null !== newTopic && this.client.exec(\"/TOPIC \" + newTopic);\n        },\n        reflow: function() {\n            this.parentObject.reflow();\n        },\n        onResize: function() {\n            this.scrolleddown ? Browser.Engine.trident ? this.scrollToBottom.delay(5, this) : this.scrollToBottom() : $defined(this.scrollpos) && (Browser.Engine.trident ? this.getScrollParent().scrollTo(this.scrollpos.x, this.scrollpos.y) : this.getScrollParent().scrollTo.delay(5, this, [ this.scrollpos.x, this.scrollpos.y ]));\n        },\n        createMenu: function(nick, parent) {\n            var e = new Element(\"div\");\n            parent.appendChild(e), e.addClass(\"menu\");\n            var nickArray = [ nick ];\n            return ui.MENU_ITEMS.filter(function(item) {\n                var ret, pred = item.predicate;\n                return ret = \"function\" === $type(pred) ? pred.apply(this, nickArray) : !!pred;\n            }, this).each(function(item) {\n                var e2 = new Element(\"a\");\n                e.appendChild(e2), e2.href = \"#\", e2.set(\"text\", \"- \" + item.text), e2.addEvent(\"focus\", function() {\n                    this.blur();\n                }.bind(e2)), e2.addEvent(\"click\", function(ev) {\n                    new Event(ev.stop()), this.menuClick(item.fn);\n                }.bind(this));\n            }, this), e;\n        },\n        menuClick: function(fn) {\n            fn.bind(this)(this.prevNick.realNick), this.removePrevMenu();\n        },\n        moveMenuClass: function() {\n            this.prevNick && (this.nicklist.firstChild == this.prevNick ? this.prevNick.removeClass(\"selected-middle\") : this.prevNick.addClass(\"selected-middle\"));\n        },\n        removePrevMenu: function() {\n            this.prevNick && (this.prevNick.removeClass(\"selected\"), this.prevNick.removeClass(\"selected-middle\"), \n            this.prevNick.menu && this.prevNick.removeChild(this.prevNick.menu), this.prevNick = null);\n        },\n        nickListAdd: function(nick, position) {\n            var realNick = util.stripPrefix(this.client.prefixes, nick), e = new Element(\"a\");\n            ui.insertAt(position, this.nicklist, e), e.href = \"#\";\n            var span = new Element(\"span\");\n            if (this.parentObject.uiOptions.NICK_COLOURS) {\n                var colour = util.toHSBColour(realNick, this.client);\n                $defined(colour) && span.setStyle(\"color\", colour.rgbToHex());\n            }\n            return span.set(\"text\", nick), e.appendChild(span), e.realNick = realNick, e.addEvent(\"click\", function(x) {\n                return this.prevNick == e ? (this.removePrevMenu(), undefined) : (this.removePrevMenu(), \n                this.prevNick = e, e.addClass(\"selected\"), this.moveMenuClass(), e.menu = this.createMenu(e.realNick, e), \n                new Event(x).stop(), undefined);\n            }.bind(this)), e.addEvent(\"focus\", function() {\n                this.blur();\n            }.bind(e)), this.moveMenuClass(), e;\n        },\n        nickListRemove: function(nick, stored) {\n            try {\n                this.nicklist.removeChild(stored), this.moveMenuClass();\n            } catch (e) {\n                console.log(nick), console.log(stored);\n            }\n        },\n        updateTopic: function(topic) {\n            for (var t = this.topic; t.firstChild; ) t.removeChild(t.firstChild);\n            if (topic) t.topicText = topic, this.parent(topic, t); else {\n                t.topicText = topic;\n                var e = new Element(\"div\");\n                e.set(\"text\", \"(no topic set)\"), e.addClass(\"emptytopic\"), t.appendChild(e);\n            }\n            this.reflow();\n        },\n        select: function() {\n            var inputVisible = this.type != ui.WINDOW_CONNECT && this.type != ui.WINDOW_CUSTOM;\n            if (this.tab.removeClass(\"tab-unselected\"), this.name !== BROUHAHA ? this.tab.addClass(\"tab-selected\") : (this.tab.removeClass(\"brouhaha-unselected\"), \n            this.tab.addClass(\"brouhaha\")), this.parentObject.setLines(this.lines), this.parentObject.setChannelItems(this.nicklist, this.topic), \n            this.parentObject.qjsui.showInput(inputVisible), this.parentObject.qjsui.showChannel($defined(this.nicklist), this.parentObject.uiOptions.SHOW_NICKLIST), \n            this.reflow(), this.parent(), inputVisible && this.parentObject.inputbox.focus(), \n            this.type == ui.WINDOW_CHANNEL && this.nicksColoured != this.parentObject.uiOptions.NICK_COLOURS) {\n                this.nicksColoured = this.parentObject.uiOptions.NICK_COLOURS;\n                var nodes = this.nicklist.childNodes;\n                if (this.parentObject.uiOptions.NICK_COLOURS) for (var i = 0; nodes.length > i; i++) {\n                    var e = nodes[i], span = e.firstChild, colour = util.toHSBColour(e.realNick, this.client);\n                    $defined(colour) && span.setStyle(\"color\", colour.rgbToHex());\n                } else for (var i = 0; nodes.length > i; i++) {\n                    var span = nodes[i].firstChild;\n                    span.setStyle(\"color\", null);\n                }\n            }\n        },\n        deselect: function() {\n            this.parent(), this.tab.removeClass(\"tab-selected\"), this.name === BROUHAHA ? (this.tab.removeClass(\"brouhaha\"), \n            this.tab.addClass(\"brouhaha-unselected\")) : this.tab.addClass(\"tab-unselected\");\n        },\n        close: function() {\n            if (!isBaseWindow(this.name) && new Date().getTime() - window.lastkick.last > 100) {\n                var client = this.client, channels = util.removeChannel(client.channels, this.name);\n                client.storeChannels(channels);\n            }\n            this.parent(), this.parentObject.tabs.removeChild(this.tab), this.parentObject.tabs.removeChild(this.spaceNode), \n            this.reflow();\n        },\n        addLine: function(type, line, colourClass) {\n            var e = new Element(\"div\");\n            colourClass ? e.addClass(colourClass) : this.lastcolour ? e.addClass(\"linestyle1\") : e.addClass(\"linestyle2\"), \n            this.lastcolour = !this.lastcolour, this.parent(type, line, colourClass, e), this.reflow();\n        },\n        setHilighted: function(state) {\n            var laststate = this.hilighted;\n            if (this.parent(state), state != laststate) switch (this.tab.removeClass(\"tab-hilight-activity\"), \n            this.tab.removeClass(\"tab-hilight-us\"), this.tab.removeClass(\"tab-hilight-speech\"), \n            this.hilighted) {\n              case ui.HILIGHT_US:\n                this.tab.addClass(\"tab-hilight-us\");\n                break;\n\n              case ui.HILIGHT_SPEECH:\n                this.tab.addClass(\"tab-hilight-speech\");\n            }\n        }\n    }), ui.GenericLoginBox = function(parentElement, callback, initialNickname, initialChannels, autoConnect, autoNick, networkName, storage) {\n        autoConnect ? ui.ConfirmBox(parentElement, callback, initialNickname, initialChannels, autoNick, networkName, storage) : ui.LoginBox(parentElement, callback, initialNickname, initialChannels, networkName, storage);\n    }, ui.LoginBox = function(parentElement, callback, initialNickname, initialChannels, networkName, authCookies) {\n        function toggleFull() {\n            fullForm = fullForm || form.getElements('[name=\"full\"]').getParent(\"div\"), fullForm.each(function(e) {\n                e.toggleClass(\"hidden\");\n            });\n        }\n        var outerbox = new Element(\"div\");\n        outerbox.addClass(\"tf-middle\"), parentElement.appendChild(outerbox);\n        var content = new Element(\"div\");\n        outerbox.appendChild(content);\n        var nickname = authCookies.nick.read() || initialNickname, gamesurge = util.B64.decode(authCookies.user.read()), password = util.B64.decode(authCookies.pass.read()), eauth = auth.enabled || authCookies.auth.read(), context = {\n            network: networkName,\n            nickname: nickname || initialNickname,\n            username: gamesurge,\n            password: password,\n            full: eauth\n        };\n        content.innerHTML = Handlebars.templates.authpage(context);\n        var fullForm, nickBox = $(\"nickname\"), usernameBox = $(\"username\"), passwordBox = $(\"password\"), chkAddAuth = $(\"authenticate\"), form = $$(\"form#login\")[0];\n        chkAddAuth.addEvent(\"click\", toggleFull), form.addEvent(\"submit\", function(e) {\n            new Event(e).stop();\n            var nickname = nickBox.value;\n            if (!nickname) return alert(\"You must supply a nickname.\"), nickBox.focus(), undefined;\n            var stripped = qwebirc.global.nicknameValidator.validate(nickname);\n            if (stripped !== nickname) return nickBox.value = stripped, alert(\"Your nickname was invalid and has been corrected; please check your altered nickname and press Connect again.\"), \n            nickBox.focus(), undefined;\n            var data = {\n                nickname: nickname\n            };\n            if (authCookies.nick.write(nickname), chkAddAuth.checked || auth.enabled) {\n                if (data.gamesurge = gamesurge = usernameBox.value, data.password = password = passwordBox.value, \n                authCookies.user.write(util.B64.encode(gamesurge)), authCookies.pass.write(util.B64.encode(password)), \n                authCookies.auth.write(!0), auth.enabled = !0, auth.bouncerAuth()) {\n                    if (!password) return alert(\"You must supply a password.\"), passwordBox.focus(), \n                    undefined;\n                    data.serverPassword = password;\n                }\n                if (!gamesurge || !password) return alert(\"You must supply your username and password in auth mode.\"), \n                usernameBox.value ? passwordBox.focus() : usernameBox.focus(), undefined;\n                auth.passAuth() && (data.serverPassword = gamesurge + \" \" + password);\n            } else authCookies.auth.dispose();\n            parentElement.removeChild(outerbox), auth.loggedin = !0, callback.call(this, data);\n        }.bind(this)), window == window.top && nickBox.focus();\n    }, ui.ConfirmBox = function(parentElement, callback, initialNickname, initialChannels, autoNick, networkName) {\n        var outerbox = new Element(\"table\");\n        outerbox.addClass(\"qwebirc-centrebox\"), parentElement.appendChild(outerbox);\n        var tbody = new Element(\"tbody\");\n        outerbox.appendChild(tbody);\n        var tr = new Element(\"tr\");\n        tbody.appendChild(tr);\n        var td = new Element(\"td\");\n        tr.appendChild(td);\n        var box = new Element(\"table\");\n        box.addClass(\"qwebirc-confirmbox\"), td.appendChild(box);\n        var tbody = new Element(\"tbody\");\n        box.appendChild(tbody);\n        var tr = new Element(\"tr\");\n        tbody.appendChild(tr), tr.addClass(\"tr1\");\n        var text = new Element(\"td\");\n        tr.appendChild(text);\n        var nick = new Element(\"b\");\n        nick.set(\"text\", initialNickname);\n        var c = initialChannels.split(\" \")[0].split(\",\");\n        text.appendChild(document.createTextNode(\"To connect to \" + networkName + \" IRC and join channel\" + (c.length > 1 ? \"s\" : \"\") + \" \"));\n        for (var i = 0; c.length > i; i++) c.length > 1 && i == c.length - 1 ? text.appendChild(document.createTextNode(\" and \")) : i > 0 && text.appendChild(document.createTextNode(\", \")), \n        text.appendChild(new Element(\"b\").set(\"text\", c[i]));\n        autoNick || (text.appendChild(document.createTextNode(\" as \")), text.appendChild(nick)), \n        text.appendChild(document.createTextNode(\" click 'Connect'.\")), text.appendChild(new Element(\"br\")), \n        auth.enabled && auth.quakeNetAuth() && !auth.loggedin && text.appendChild(document.createTextNode(\"If you'd like to connect using your Q auth click 'Log in'.\"));\n        var tr = new Element(\"tr\");\n        tbody.appendChild(tr), tr.addClass(\"tr2\");\n        var td = new Element(\"td\");\n        tr.appendChild(td);\n        var yes = new Element(\"input\", {\n            type: \"submit\",\n            value: \"Connect\"\n        });\n        if (td.appendChild(yes), yes.addEvent(\"click\", function() {\n            parentElement.removeChild(outerbox), callback({\n                nickname: initialNickname,\n                autojoin: initialChannels\n            });\n        }), auth.enabled && auth.quakeNetAuth() && !auth.loggedin) {\n            var auth = new Element(\"input\", {\n                type: \"submit\",\n                value: \"Log in\"\n            });\n            td.appendChild(auth), auth.addEvent(\"click\", ui.AuthLogin);\n        }\n        window == window.top && yes.focus();\n    }, ui.authShowHide = function(checkbox, authRow, usernameBox, usernameRow, passwordRow) {\n        var visible = checkbox.checked, display = visible ? null : \"none\";\n        usernameRow.setStyle(\"display\", display), passwordRow.setStyle(\"display\", display), \n        visible && usernameBox.focus();\n    };\n}(this);",
			"file": "js/hacks.min.js",
			"file_size": 470530,
			"file_write_time": 130145435456343393,
			"settings":
			{
				"buffer_size": 470402,
				"line_ending": "Unix"
			}
		},
		{
			"file": "js/src/irc/Interface.js",
			"settings":
			{
				"buffer_size": 11499,
				"line_ending": "Windows"
			}
		},
		{
			"file": "gruntfile.js",
			"settings":
			{
				"buffer_size": 3187,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/src/qwebirc_end.js",
			"settings":
			{
				"buffer_size": 46,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*Copyright (c) 2008-2009 the qwebirc project.\nhttp://www.qwebirc.org/\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nversion 2 as published by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nThough it is not required, we would appreciate public facing\ninstances leaving a mention of the original author(s) and the\nproject name and URL in the about dialog, thanks!*/\n\n\n; (function(par, undefined) {\n    \"use strict\";\n\n    //init crap\n    var DEBUG = true;\n\n    //common globals\n    var window = par,\n        document = par.document,\n        $ = document.id,\n        Functional = par.Functional,\n        prelude = par.prelude;\n\n    /* qwebirc -- Copyright (C) 2008-2011 Chris Porter and the qwebirc project --- All rights reserved. */\n\n    par.QWEBIRC_BUILD=\"bbc577ad5cb78d946ac1\";\n\n    //global object\n    //var qwebirc = par.qwebirc = {ui: {themes: {}, style: {}}, irc: {}, util: {crypto: {}}, config: {}, auth: {}, sound: {}};\n\n    var qwebirc = par.qwebirc = {},\n\n        irc = qwebirc.irc = {},\n\n        util = qwebirc.util = {},\n        crypto = util.crypto = {},\n\n        config = qwebirc.config = {},\n        auth = qwebirc.auth = {},\n\n        ui = qwebirc.ui = {},\n        themes = ui.themes = {},\n        style = ui.style = {},\n\n        sound = qwebirc.sound = {},//,\n\n        lang;// = qwebirc.lang;\n\n    qwebirc.BUILD = QWEBIRC_BUILD;\n    qwebirc.FILE_SUFFIX = \"-\" + QWEBIRC_BUILD;\n    qwebirc.VERSION = \"0.93-dev\";\n\n\nui.WINDOW_STATUS = 1;\nui.WINDOW_QUERY = 2;\nui.WINDOW_CHANNEL = 4;\nui.WINDOW_CUSTOM = 8;\nui.WINDOW_CONNECT = 16;\nui.WINDOW_MESSAGES = 32;\nui.CUSTOM_CLIENT = \"custom\";\n\nui.HILIGHT_NONE = 0;\nui.HILIGHT_ACTIVITY = 1;\nui.HILIGHT_SPEECH = 2;\nui.HILIGHT_US = 3;\nui.MAXIMUM_LINES_PER_WINDOW = 1000;\nui.WINDOW_LASTLINE = ui.WINDOW_QUERY | ui.WINDOW_MESSAGES | ui.WINDOW_CHANNEL | ui.WINDOW_STATUS;\n\nirc.PMODE_LIST = 0;\nirc.PMODE_SET_UNSET = 1;\nirc.PMODE_SET_ONLY = 2;\nirc.PMODE_REGULAR_MODE = 3;\n\n\nvar BROUHAHA = '#brouhaha',\n    CONNECTION_DETAILS = 'Connection details',\n    STATUS = 'Status',\n    OPTIONS = 'Options',\n\n\n    BASE_WINDOWS = [BROUHAHA, CONNECTION_DETAILS, STATUS],\n    CHANNEL_TYPES = [ui.WINDOW_CHANNEL, ui.WINDOW_QUERY],\n    INPUT_TYPES = [ui.WINDOW_STATUS, ui.WINDOW_QUERY, ui.WINDOW_CHANNEL, ui.WINDOW_MESSAGES];\n\nvar OPED = \"+\",\n    DEOPED = \"-\",\n    OPSTATUS = \"@\",\n    VOICESTATUS = \"+\";\n\nirc.IRCLowercaseTable = [ /* x00-x07 */ '\\x00', '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\x07',\n    /* x08-x0f */ '\\x08', '\\x09', '\\x0a', '\\x0b', '\\x0c', '\\x0d', '\\x0e', '\\x0f',\n    /* x10-x17 */ '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16', '\\x17',\n    /* x18-x1f */ '\\x18', '\\x19', '\\x1a', '\\x1b', '\\x1c', '\\x1d', '\\x1e', '\\x1f',\n    /* ' '-x27 */ ' ', '!', '\"', '#', '$', '%', '&', '\\x27',\n    /* '('-'/' */ '(', ')', '*', '+', ',', '-', '.', '/',\n    /* '0'-'7' */ '0', '1', '2', '3', '4', '5', '6', '7',\n    /* '8'-'?' */ '8', '9', ':', ';', '<', '=', '>', '?',\n    /* '@'-'G' */ '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n    /* 'H'-'O' */ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    /* 'P'-'W' */ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n    /* 'X'-'_' */ 'x', 'y', 'z', '{', '|', '}', '~', '_',\n    /* '`'-'g' */ '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n    /* 'h'-'o' */ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    /* 'p'-'w' */ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n    /* 'x'-x7f */ 'x', 'y', 'z', '{', '|', '}', '~', '\\x7f',\n    /* x80-x87 */ '\\x80', '\\x81', '\\x82', '\\x83', '\\x84', '\\x85', '\\x86', '\\x87',\n    /* x88-x8f */ '\\x88', '\\x89', '\\x8a', '\\x8b', '\\x8c', '\\x8d', '\\x8e', '\\x8f',\n    /* x90-x97 */ '\\x90', '\\x91', '\\x92', '\\x93', '\\x94', '\\x95', '\\x96', '\\x97',\n    /* x98-x9f */ '\\x98', '\\x99', '\\x9a', '\\x9b', '\\x9c', '\\x9d', '\\x9e', '\\x9f',\n    /* xa0-xa7 */ '\\xa0', '\\xa1', '\\xa2', '\\xa3', '\\xa4', '\\xa5', '\\xa6', '\\xa7',\n    /* xa8-xaf */ '\\xa8', '\\xa9', '\\xaa', '\\xab', '\\xac', '\\xad', '\\xae', '\\xaf',\n    /* xb0-xb7 */ '\\xb0', '\\xb1', '\\xb2', '\\xb3', '\\xb4', '\\xb5', '\\xb6', '\\xb7',\n    /* xb8-xbf */ '\\xb8', '\\xb9', '\\xba', '\\xbb', '\\xbc', '\\xbd', '\\xbe', '\\xbf',\n    /* xc0-xc7 */ '\\xe0', '\\xe1', '\\xe2', '\\xe3', '\\xe4', '\\xe5', '\\xe6', '\\xe7',\n    /* xc8-xcf */ '\\xe8', '\\xe9', '\\xea', '\\xeb', '\\xec', '\\xed', '\\xee', '\\xef',\n    /* xd0-xd7 */ '\\xf0', '\\xf1', '\\xf2', '\\xf3', '\\xf4', '\\xf5', '\\xf6', '\\xd7',\n    /* xd8-xdf */ '\\xf8', '\\xf9', '\\xfa', '\\xfb', '\\xfc', '\\xfd', '\\xfe', '\\xdf',\n    /* xe0-xe7 */ '\\xe0', '\\xe1', '\\xe2', '\\xe3', '\\xe4', '\\xe5', '\\xe6', '\\xe7',\n    /* xe8-xef */ '\\xe8', '\\xe9', '\\xea', '\\xeb', '\\xec', '\\xed', '\\xee', '\\xef',\n    /* xf0-xf7 */ '\\xf0', '\\xf1', '\\xf2', '\\xf3', '\\xf4', '\\xf5', '\\xf6', '\\xf7',\n    /* xf8-xff */ '\\xf8', '\\xf9', '\\xfa', '\\xfb', '\\xfc', '\\xfd', '\\xfe', '\\xff'];\n\n\nirc.Numerics = {\n    \"001\": \"RPL_WELCOME\",\n    \"004\": \"RPL_MYINFO\",\n    \"005\": \"RPL_ISUPPORT\",\n    \"353\": \"RPL_NAMREPLY\",\n    \"366\": \"RPL_ENDOFNAMES\",\n\n    \"331\": \"RPL_NOTOPIC\",\n    \"332\": \"RPL_TOPIC\",\n    \"333\": \"RPL_TOPICWHOTIME\",\n\n    \"311\": \"RPL_WHOISUSER\",\n    \"312\": \"RPL_WHOISSERVER\",\n    \"313\": \"RPL_WHOISOPERATOR\",\n    \"317\": \"RPL_WHOISIDLE\",\n    \"671\": \"RPL_WHOISSECURE\",\n    \"318\": \"RPL_ENDOFWHOIS\",\n    \"319\": \"RPL_WHOISCHANNELS\",\n    \"330\": \"RPL_WHOISACCOUNT\",\n    \"338\": \"RPL_WHOISACTUALLY\",\n    \"343\": \"RPL_WHOISOPERNAME\",\n    \"320\": \"RPL_WHOISGENERICTEXT\",\n    \"325\": \"RPL_WHOISWEBIRC\",\n\n    \"301\": \"RPL_AWAY\",\n    \"305\": \"RPL_UNAWAY\",\n    \"306\": \"RPL_NOWAWAY\",\n\n    \"324\": \"RPL_CHANNELMODEIS\",\n    \"329\": \"RPL_CREATIONTIME\",\n\n    \"433\": \"ERR_NICKNAMEINUSE\",\n    \"401\": \"ERR_NOSUCHNICK\",\n    \"404\": \"ERR_CANNOTSENDTOCHAN\",\n    \"482\": \"ERR_CHANOPPRIVSNEEDED\",\n\n    \"321\": \"RPL_LISTSTART\",\n    \"322\": \"RPL_LISTITEM\",\n    \"323\": \"RPL_LISTEND\"\n};\n\n\n(function() {\n\n    var types = {\n        ERROR: 0,\n        INFO: 1,\n        SERVER: 2,\n        CHAN: 3,\n        MISC: 4,\n\n        MESSAGE: 5\n    };\n\n    var message = function(msg, type) {\n        return {\n            message: msg,\n            type: type\n        };\n    };\n\n    //language specific stuff. right now just an object\n    // can either be a message or array of messages\n    qwebirc.lang = lang = {\n        TYPES: types,\n        message: message,\n\n        loginMessages: [message(\"Hint #1! When you close a channel this one will be deleted from your favorites and won't come back on the next connection.\", types.INFO),\n                        message(\"Hint #2! To join a new channel type this command in the chat box: /j #channel\", types.INFO)],\n        joinAfterAuth: message(\"Waiting for login before joining channels...\", types.INFO),\n        authFailed: [message(\"Could not auth with IRC network - waited 5 seconds.\", types.ERROR),\n                    message(\"Otherwise reattempt authing by typing: \\\"/authserv AUTH <your username> <your password>\\\"\", types.ERROR),\n                    message(\"To ignore the error and join channels, unauthed, type: \\\"/autojoin\\\".\", types.ERROR)],\n        signOn: message(\"SIGNON\", types.SERVER),\n        joinChans: message(\"Joining channels...\", types.INFO),\n        noTopic: message(\"(No topic set.)\", types.INFO),\n\n        needOp: message(\"Sorry, you need to be a channel operator to change the topic!\", types.ERROR),\n        changeTopicConfirm: message(\"Change topic of {channel} to:\", types.MISC),\n\n        poorJoinFormat: message(\"Channel names begin with # (corrected automatically).\", types.INFO),\n        waitToJoin: message(\"You recently tried to join {channel}. To prevent join-flooding, please wait {time} seconds before reattempting or type /fjoin {channel} to ignore this warning...\", types.ERROR),\n        invalidCommand: message(\"Can't use this command in this window\", types.ERROR),\n        invalidChanTarget: message(\"Can't target a channel with this command.\", types.ERROR),\n        insufficentArgs: message(\"Insufficient arguments for command.\", types.ERROR),\n\n        invalidNick: message(\"Your nickname was invalid and has been corrected; please check your altered nickname and press Connect again.\", types.ERROR),\n        missingNick: message(\"You must supply a nickname\"),\n        missingPass: message(\"You must supply a password.\", types.ERROR),\n        missingAuthInfo: message(\"You must supply your username and password in auth mode.\", types.ERROR),\n\n\n        loadingPage: message(\"Loading . . .\", types.INFO),\n        submittingPage: message(\"Submitting . . .\", types.INFO),\n        fishSlap: message(\"slaps {nick} with a large fishbot\", types.MESSAGE),\n\n        copyright: [message(\"qwebirc v\" + qwebirc.VERSION, types.INFO),\n                    message(\"Copyright (C) 2008-2011 Chris Porter and the qwebirc project.\", types.INFO),\n                    message(\"Current version by Emanuel \\\"megawac\\\" Jackstare\"),\n                    message(\"http://www.qwebirc.org\", types.INFO),\n                    message(\"Licensed under the GNU General Public License, Version 2.\", types.INFO)],\n\n        activityNotice: message(\"Activity!\", types.MISC),\n        partChan: message(\"Part\", types.MESSAGE),\n        logOut: message(\"Logged out\", types.MESSAGE),\n        quit: message(\"Page closed\", types.MESSAGE),\n        disconnected: message(\"Client has been disconnected\", types.INFO),\n\n        uncontrolledFlood: message(\"ERROR: uncontrolled flood detected -- disconnected.\", types.ERROR),\n        connError: message(\"An error occured: {1}\", types.ERROR),\n        connTimeOut: message(\"Error: connection closed after {retryAttempts} requests failed.\", types.ERROR),\n        connectionFail: message(\"Couldn't connect to remote server.\", types.ERROR),\n\n        closeTab: \"Close tab\",\n        detachWindow: \"Detach Window\"\n\n    };\n\n\n    lang.IRC_COMMAND_HELPERS = {\n        \"JOIN\": \"/JOIN <channel>\",\n        \"NICK\": \"/NICK <new nickname>\",\n        \"PART\": \"/PART <channel>\",\n        \"QUIT\": \"/QUIT <message>\",\n        \"TOPIC\": \"/TOPIC <channel> <topic>\",\n        \"AWAY\": \"/AWAY <message>\",\n        \"ME\": \"/ME <message>\",\n        \"NOTICE\": \"/NOTICE <message>\",\n        \"MODE\": \"/MODE <target(chan/user)> <mode>\",\n        \"AUTHSERV\": \"/AUTHSERV AUTH <account> <password>\"\n    };\n\n    // lang.DaysOfWeek = [\n    //     \"Sun\",\n    //     \"Mon\",\n    //     \"Tue\",\n    //     \"Wed\",\n    //     \"Thu\",\n    //     \"Fri\",\n    //     \"Sat\"\n    // ];\n\n    // lang.MonthsOfYear = [\n    //     \"Jan\",\n    //     \"Feb\",\n    //     \"Mar\",\n    //     \"Apr\",\n    //     \"May\",\n    //     \"Jun\",\n    //     \"Jul\",\n    //     \"Aug\",\n    //     \"Sep\",\n    //     \"Oct\",\n    //     \"Nov\",\n    //     \"Dec\"];\n\n\nui.themes.ThemeControlCodeMap2 = {\n    \"C\": \"\\x03\",\n    \"B\": \"\\x02\",\n    \"U\": \"\\x1F\",\n    \"O\": \"\\x0F\",\n    \"D\": \"\\x00\",\n    \"[\": \"qwebirc://whois/\",\n    \"]\": \"/\",\n    \"$\": \"$\"\n};\n\n//todo make this stuff more clear\nui.themes.Default2 = {\n    \"SIGNON\": [\"Signed on!\", true],\n    \"CONNECT\": [\"Connected to server.\", true],\n\n    \"RAW\": [\"{m}\", true],\n    \"DISCONNECT\": [\"Disconnected from server: {m}\", true],\n    \"ERROR\": [\"ERROR: {m}\", true],\n    \"SERVERNOTICE\": [\"{m}\", true],\n\n    \"JOIN\": [\"{D}{N}{D} [{h}] has joined {c}\", true],\n    \"OURJOIN\": [\"{D}{N}{D} [{h}] has joined {c}\", true],\n    \"PART\": [\"{D}{N}{D} [{h}] has left {c} [{m}]\", true],\n    \"KICK\": [\"{D}{v}{D} was kicked from {c} by {D}{N}{D} [{m}]\", true],\n    \"MODE\": [\"mode/{c} [{m}] by {D}{N}{D}\", true],\n    \"QUIT\": [\"{D}{N}{D} [{h}] has quit [{m}]\", true],\n    \"NICK\": [\"{D}{n}{D} has changed nick to {D}{[}{w}{]}{D}\", true],\n    \"TOPIC\": [\"{D}{N}{D} changed the topic of {c} to: {m}\", true],\n    \"UMODE\": [\"Usermode change: {m}\", true],\n    \"INVITE\": [\"{N} invites you to join {c}\", true],\n\n    \"PREFIX\": [\"{C}4=={O} \"],\n    \"HILIGHT\": [\"{C}4\"],\n    \"HILIGHTEND\": [\"{O}\"],\n\n    \"CHANMSG\": [\"<{D}{@}{(}{N}{)}{D}> {m}\"],\n    \"PRIVMSG\": [\"<{(}{N}{)}> {m}\"],\n    \"CHANNOTICE\": [\"-{D}{(}{N}{)}{D}:{c}- {m}\"],\n    \"PRIVNOTICE\": [\"-{(}{N}{)}- {m}\"],\n\n    \"OURCHANMSG\": [\"<{@}{N}> {m}\"],\n    \"OURPRIVMSG\": [\"<{N}> {m}\"],\n    \"OURTARGETEDMSG\": [\"*{[}{t}{]}* {m}\"],\n    \"OURTARGETEDNOTICE\": [\"[notice({[}{t}{]})] {m}\"],\n    \"OURCHANNOTICE\": [\"-{N}:{t}- {m}\"],\n    \"OURPRIVNOTICE\": [\"-{N}- {m}\"],\n    \"OURCHANACTION\": [\" * {N} {m}\"],\n    \"OURPRIVACTION\": [\" * {N} {m}\"],\n\n    \"CHANACTION\": [\" * {D}{(}{N}{)}{D} {m}\"],\n    \"PRIVACTION\": [\" * {(}{N}{)} {m}\"],\n    \"CHANCTCP\": [\"{N} [{h}] requested CTCP {x} from {c}: {m}\"],\n    \"PRIVCTCP\": [\"{N} [{h}] requested CTCP {x} from {-}: {m}\"],\n    \"CTCPREPLY\": [\"CTCP {x} reply from {N}: {m}\"],\n\n    \"OURCHANCTCP\": [\"[ctcp({t})] {x} {m}\"],\n    \"OURPRIVCTCP\": [\"[ctcp({t})] {x} {m}\"],\n    \"OURTARGETEDCTCP\": [\"[ctcp({t})] {x} {m}\"],\n\n    \"WHOISUSER\": [\"{B}{N}{B} [{h}]\", true],\n    \"WHOISREALNAME\": [\" realname : {m}\", true],\n    \"WHOISCHANNELS\": [\" channels : {m}\", true],\n    \"WHOISSERVER\": [\" server   : {x} [{m}]\", true],\n    \"WHOISACCOUNT\": [\" account  : qwebirc://qwhois/{m}\", true],\n    \"WHOISIDLE\": [\" idle     : {x} [connected: {m}]\", true],\n    \"WHOISAWAY\": [\" away     : {m}\", true],\n    \"WHOISOPER\": [\"          : {B}IRC Operator{B}\", true],\n    \"WHOISOPERNAME\": [\" operedas : {m}\", true],\n    \"WHOISACTUALLY\": [\" realhost : {m} [ip: {x}]\", true],\n    \"WHOISGENERICTEXT\": [\"          : {m}\", true],\n    \"WHOISEND\": [\"End of WHOIS\", true],\n\n    \"AWAY\": [\"{N} is away: {m}\", true],\n    \"GENERICERROR\": [\"{m}: {t}\", true],\n    \"GENERICMESSAGE\": [\"{m}\", true],\n    \"WALLOPS\": [\"WALLOP {n}: {t}\", true],\n    \"CHANNELCREATIONTIME\": [\"Channel {c} was created at: {m}\", true],\n    \"CHANNELMODEIS\": [\"Channel modes on {c} are: {m}\", true]\n};\n\nui.UI_COMMANDS = [\n    [\"Options\", \"options\"],\n    [\"Add webchat to your site\", \"embedded\"],\n    [\"Privacy policy\", \"privacy\"],\n    [\"Feedback\", \"feedback\"],\n    [\"Frequently asked questions\", \"faq\"],\n    [\"About qwebirc\", \"about\"]\n];\n\n\n})();\n\n\n\nvar whitespace = /\\s/,\n    notwhitespace = /\\S+$/;\n\n//my helper functions\n//returns itself\nvar $identity = Functional.I,\n\n    // notEqual = Functional.compose(Functional.not, Functional.eq),\n\n    charAt = function(n, str) { return str.charAt(n); }.autoCurry(),\n\n    splitBang = prelude.split(\"!\"),\n\n    joinEmpty = prelude.join(\"\"),\n\n    splitEmpty = prelude.split(\"\"),\n\n    joinComma = util.joinChans = prelude.join(\",\"),\n\n    splitComma = prelude.split(\",\"),\n\n    concatUnique = Functional.compose(prelude.uniq, prelude.concat),\n\n    concatSep = function(sep, s1, s2) {\n        if(Array.isArray(s1)) {\n            s1 = s1.join(sep);\n        }\n        if(Array.isArray(s2)) {\n            s2 = s2.join(sep);\n        }\n        if(s1 !== \"\" && s2 !== \"\") {\n            return s1 + sep + s2;\n        }\n        else {\n            return s1 + s2;\n        }\n    }.autoCurry(),\n\n    concatSpace = concatSep(\" \"),\n\n    startsWith = function(what, str) {\n        return str.startsWith(what);\n    }.autoCurry(),\n\n    each = Array.each.flip().autoCurry(2);\n\n//little formatter i wrote in 10 mins you can prob find a better one\n//formatter(\"{test} a {wa} {repl} {test}\",{test:1, repl:'replaced'})\n// => \"1 a {wa} replaced 1\"\n// http://jsperf.com/stringformat/3\nutil.formatter = String.substitute;\n// function(str, hash) {\n//     var curly = /{(.*?)}/g, //match all substrings wrapped in '{ }'\n//         prop;\n\n//     str.match(curly)\n//         .each(function (propstr) {\n//             prop = propstr.substring(1, propstr.length - 1); //remove curlys\n//             if(typeof hash[prop] !== 'undefined') {\n//                 str = str.replace(propstr, hash[prop]);\n//             }\n//         });\n//     return str;\n// };\n\n//takes a string and escapes characters... not sure what for\n// escape('w-d') => \"w\\-d\"\n//probably a little intense as its only used to escape a nick\n// most useful for removing regex special chars\n// RegExp.escape = prelude.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nRegExp.escape = String.escapeRegExp;\n\n//String -> String\n// megawac!~megawac@megawac.user.gamesurge -> megawac\nutil.hostToNick = Functional.compose(prelude.first, splitBang);\n//megawac!~megawac@megawac.user.gamesurge -> ~megawac@megawac.user.gamesurge\nutil.hostToHost = Functional.compose(prelude.item(1), splitBang);\n\n\nvar isChannel = util.isChannel = Functional.and('.length > 1', startsWith('#')),\n\n    formatChannel = util.formatChannel = function(chan) {\n        if(chan.length >= 1 && !isChannel(chan)) {\n            chan = '#' + chan;\n        }\n        return chan;\n    },\n\n    unformatChannel = util.unformatChannel = function(chan) {\n        if(isChannel(chan)) {\n            chan = chan.slice(1);\n        }\n        return chan;\n    },\n\n    appendChannel = function(chans,chan) {\n        return $A(chans).concat(chan);\n    },\n\n    splitChan = util.splitChans = function(xs) {\n        if(Array.isArray(xs))\n            return xs.length > 0 ? xs : [\"\"];\n        return xs.split(\",\");\n    },\n\n    //function to determine if a string is one of the stock windows\n    isBaseWindow = util.isBaseWindow = prelude.contains(BASE_WINDOWS),\n\n    isChannelType = util.isChannelType = prelude.contains(CHANNEL_TYPES);\n\n\nutil.windowNeedsInput = prelude.contains(INPUT_TYPES);\n\n//String -> String\n//formatChannelStrings(\"test,test2,#test3,#tes#t4,test5,test6\") => \"#test,#test2,#test3,#tes#t4,#test5,#test6\"\nutil.formatChannelString = Functional.compose(joinComma, prelude.uniq, Functional.map(formatChannel), splitChan);\nutil.unformatChannelString = Functional.compose(prelude.uniq, Functional.map(unformatChannel), splitChan);\n\n//appends a channel to the end of the list of channels\n//string -> string\n//could just call Array.include?\nutil.addChannel = Functional.compose(/*joinComma, */prelude.uniq,/* splitChan, */appendChannel);\n//adds channel to front of list of channels\nutil.prependChannel = Functional.compose(/*joinComma, */prelude.uniq,/* splitChan, */appendChannel.flip());\n\n\n//filter an array to not contain main window or dubs then joins it\n// util.arrayToChanString = Functional.compose(joinComma, prelude.uniq, Functional.filter.curry(Functional.not(isBaseWindow)));\n\n//calls splits string by comma then calls array.erase on value\nutil.removeChannel = Array.erase;\n// function(chans, chan) {\n//     return joinComma( splitChan(chans).erase(chan) );\n// };\n\nutil.formatCommand = function(cmdline) {\n    if (cmdline.charAt(0) === \"/\") {\n        cmdline = cmdline.slice(1);\n    } else {\n        cmdline = \"SAY \" + cmdline; //default just say the msg\n    }\n    return cmdline.splitMax(\" \", 2); //split command from the params\n};\n\nutil.nickChanComparitor = function(client, nickHash) {\n    var _prefixes = client.prefixes,\n        _prefixNone = _prefixes.length,\n        prefixWeight = function(pre) { return pre.length !== 0 ? _prefixes.indexOf(pre) : _prefixNone ; },\n        toLower = client.toIRCLower;\n    //compares two nick names by channel status > lexigraphy\n    return function(nick1, nick2) {\n        var p1weight = prefixWeight(nickHash[nick1].prefixes),\n            p2weight = prefixWeight(nickHash[nick2].prefixes);\n        return (p1weight !== p2weight) ? (p1weight - p2weight) : toLower(nick1).localeCompare(toLower(nick2));\n    };\n};\n\nutil.nickPrefixer = function(nickHash) {\n    return function(nick) {\n        return nickHash[nick].prefixes + nick;\n    };\n    //return Functional.compose(prelude.concat, prelude.getProp(nickHash));\n};\n\nutil.validPrefix = prelude.contains;\n\n//equilvalent Functional.compose(joinEmpty, concatUnique)\nutil.addPrefix = function(nc, pref, prefs) {\n    if(prefs && !util.validPrefix(prefs, pref))\n        return nc.prefixes;\n    return nc.prefixes = concatUnique(nc.prefixes, pref).join(\"\");\n};\n\nutil.removePrefix = function(nc, pref) {\n    return nc.prefixes = nc.prefixes.replaceAll(pref, \"\");\n};\n\n//if theres a prefix it gets returned\n//i dont think its possible to have multiple prefixes\nutil.prefixOnNick = function(prefixes, nick) {\n    var c = nick.charAt(0);\n    return util.validPrefix(prefixes, c) ? [c, nick.slice(1)] : ['', nick];\n}.autoCurry();\n\nutil.getPrefix = Functional.compose(prelude.first, util.prefixOnNick);\n\nutil.stripPrefix = Functional.compose(prelude.item(1), util.prefixOnNick);\n\nutil.testForNick = Functional.memoize(function(nick) {\n    var classes = '[\\\\s\\\\.,;:]';\n    return prelude.test(new RegExp('(^|' + classes + ')' + RegExp.escape(nick) + '([\\\\s\\\\.,;:]|$)', \"i\"));\n});\n\nutil.toHSBColour = function(nick, client) {\n    var lower = client.toIRCLower(util.stripPrefix(client.prefixes, nick));\n    if (lower == client.lowerNickname)\n        return null;\n\n    var hash = 0;\n    for (var i = 0; i < lower.length; i++)\n        hash = 31 * hash + lower.charCodeAt(i);\n\n    var hue = Math.abs(hash) % 360;\n\n    return new Color([hue, 70, 60], \"hsb\");\n};\n\n\n//helper functions\nvar charIRCLower = Functional.compose(Array.item.curry(irc.IRCLowercaseTable), String.charCodeAt.partial(_, 0));\n\n//returns the lower case value of a RFC1459 string using the irc table\n//called a fuck ton so memoization is incredible here\nirc.RFC1459toIRCLower = Functional.memoize(Functional.compose(prelude.join(\"\"), Functional.map(charIRCLower)));\n\n//not really sure\n//takes a irc client object and string and returns something\nirc.toIRCCompletion = Functional.compose(prelude.replace(/[^\\w]+/g, \"\"), Functional.invoke(\"toIRCLower\"));\n\nirc.ASCIItoIRCLower = String.toLowerCase;\n\n\n// returns the arguments \nutil.parseURI = function(uri) {\n    var result = {};\n\n    var start = uri.indexOf('?');\n    if (start === -1) {\n        return result;\n    }\n\n    var querystring = uri.substring(start + 1);\n\n    var args = querystring.split(\"&\");\n\n    for (var i = 0; i < args.length; i++) {\n        var part = args[i].splitMax(\"=\", 2);\n        if (part.length > 1)\n            result[unescape(part[0])] = unescape(part[1]);\n    }\n\n    return result;\n};\n\nutil.longtoduration = function(l) {\n    var seconds = l % 60;\n    var minutes = Math.floor((l % 3600) / 60);\n    var hours = Math.floor((l % (3600 * 24)) / 3600);\n    var days = Math.floor(l / (24 * 3600));\n\n    return days + \" days \" + hours + \" hours \" + minutes + \" minutes \" + seconds + \" seconds\";\n};\n\n//pads based on the ret of a condition\nvar pad = util.pad = function(cond, padding, str) {\n    str = String(str);\n    return cond(str) ? padding + str : str;\n}.autoCurry();\n\nutil.padzero = pad('.length<=1'.lambda(), \"0\");\nutil.padspace = pad('.length!==0'.lambda(), \" \");\n\n\nutil.browserVersion = $lambda(navigator.userAgent);\n\nutil.getEnclosedWord = function(str, pos) {\n    pos = pos >>> 0; //type safety coerce int\n    // Search for the word's beginning and end.\n    var left = str.slice(0, pos + 1).search(notwhitespace),\n        right = str.slice(pos).search(whitespace),\n\n        // The last word in the string is a special case.\n        // Return the word, using the located bounds to extract it from the string.\n        word = right < 0 ? str.slice(left) : str.slice(left, right + pos);\n\n    return [left, word];\n};\n\n// NOT cryptographically secure! \nutil.randHexString = function(numBytes) {\n    var getByte = function() {\n            return (((1 + Math.random()) * 0x100) | 0).toString(16).substring(1);\n        };\n\n    var l = [];\n    for (var i = 0; i < numBytes; i++) {\n        l.push(getByte());\n    }\n    return l.join(\"\");\n};\n\n\nutil.IRCTimestamp = function(date) {\n    // return \"[\" + util.padzero(date.getHours()) + \":\" + util.padzero(date.getMinutes()) + \"]\";\n    return date.format(\"[%H:%M]\");\n};\n\nutil.IRCDate = function(date) {\n    // return lang.DaysOfWeek[date.getDay()] + \" \" + lang.MonthsOfYear[date.getMonth()] + \" \" + util.padzero(date.getDate()) + \" \" + util.padzero(date.getHours()) + \":\" + util.padzero(date.getMinutes()) + \":\" + util.padzero(date.getSeconds()) + \" \" + date.getFullYear();\n    return date.format(\"%c\");\n};\n\n//silly fn\nutil.wasKicked = function() {\n    return Date.now() - window.lastkick.last <= 100;\n};\n\n\nirc.nickChanEntry = function() {\n    // this.prefixes = \"\";\n    // this.lastSpoke = 0;\n    return {\n        prefixes: \"\",\n        lastSpoke: 0\n    };\n};\n\n\nBrowser.isMobile = !(Browser.Platform.win || Browser.Platform.mac || Browser.Platform.linux);\n\nutil.generateID = (function() {\n    var id = 0;\n    return function() {\n        return \"qqa-\" + id++;\n    };\n})();\n\n\n//minor updates for edge cases\n\n/**\n *\n *  Base64 encode / decode\n *  http://www.webtoolkit.info/\n *\n **/\nvar Base64 = util.B64 = (function() {\n    \"use strict\";\n\n    var _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n    var _utf8_encode = function (string) {\n\n        var utftext = \"\", c, n;\n\n        string = string.replace(/\\r\\n/g,\"\\n\");\n\n        for (n = 0; n < string.length; n++) {\n\n            c = string.charCodeAt(n);\n\n            if (c < 128) {\n\n                utftext += String.fromCharCode(c);\n\n            } else if((c > 127) && (c < 2048)) {\n\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n\n            } else {\n\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n\n            }\n\n        }\n\n        return utftext;\n    };\n\n    var _utf8_decode = function (utftext) {\n        var string = \"\", i = 0, c = 0, c1 = 0, c2 = 0;\n\n        while ( i < utftext.length ) {\n\n            c = utftext.charCodeAt(i);\n\n            if (c < 128) {\n\n                string += String.fromCharCode(c);\n                i++;\n\n            } else if((c > 191) && (c < 224)) {\n\n                c1 = utftext.charCodeAt(i+1);\n                string += String.fromCharCode(((c & 31) << 6) | (c1 & 63));\n                i += 2;\n\n            } else {\n\n                c1 = utftext.charCodeAt(i+1);\n                c2 = utftext.charCodeAt(i+2);\n                string += String.fromCharCode(((c & 15) << 12) | ((c1 & 63) << 6) | (c2 & 63));\n                i += 3;\n\n            }\n\n        }\n\n        return string;\n    };\n\n    var _hexEncode = function(input) {\n        var output = '', i;\n\n        for(i = 0; i < input.length; i++) {\n            output += input.charCodeAt(i).toString(16);\n        }\n\n        return output;\n    };\n\n    var _hexDecode = function(input) {\n        var output = '', i;\n\n        if(input.length % 2 > 0) {\n            input = '0' + input;\n        }\n\n        for(i = 0; i < input.length; i = i + 2) {\n            output += String.fromCharCode(parseInt(input.charAt(i) + input.charAt(i + 1), 16));\n        }\n\n        return output;\n    };\n\n    var encode = function (input) {\n        if(!$defined(input))\n            return null;\n\n        var output = \"\", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;\n\n        input = _utf8_encode(input);\n\n        while (i < input.length) {\n\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n                enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n                enc4 = 64;\n            }\n\n            output += _keyStr.charAt(enc1);\n            output += _keyStr.charAt(enc2);\n            output += _keyStr.charAt(enc3);\n            output += _keyStr.charAt(enc4);\n\n        }\n\n        return output;\n    };\n\n    var decode = function (input) {\n        if(!$defined(input))\n            return null;\n\n        var output = \"\", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;\n\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n        while (i < input.length) {\n\n            enc1 = _keyStr.indexOf(input.charAt(i++));\n            enc2 = _keyStr.indexOf(input.charAt(i++));\n            enc3 = _keyStr.indexOf(input.charAt(i++));\n            enc4 = _keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output += String.fromCharCode(chr1);\n\n            if (enc3 !== 64) {\n                output += String.fromCharCode(chr2);\n            }\n            if (enc4 !== 64) {\n                output += String.fromCharCode(chr3);\n            }\n\n        }\n\n        return _utf8_decode(output);\n    };\n\n    var decodeToHex = function(input) {\n        return _hexEncode(decode(input));\n    };\n\n    var encodeFromHex = function(input) {\n        return encode(_hexDecode(input));\n    };\n\n    return {\n        'encode': encode,\n        'decode': decode,\n        'decodeToHex': decodeToHex,\n        'encodeFromHex': encodeFromHex\n    };\n}());\n\n/*\n * MD5\n *\n * Usage:\n *\n *   var object = new MD5()\n *\n *     Returns a MD5 object.\n *\n *   object.digest(input)\n *\n *     Returns MD5 message digest of input.\n *\n * Example:\n *\n *   var object = new MD5();\n *\n *   // Examples drawn from RFC1321 test suite\n *   object.digest(\"\");\n *   // d41d8cd98f00b204e9800998ecf8427e\n *\n *   object.digest(\"a\");\n *   // 0cc175b9c0f1b6a831c399e269772661\n *\n *   object.digest(\"abc\");\n *   // 900150983cd24fb0d6963f7d28e17f72\n *\n *   object.digest(\"message digest\");\n *   // f96b697d7cb7938d525a2f31aaf161d0\n *\n *   object.digest(\"abcdefghijklmnopqrstuvwxyz\");\n *   // c3fcd3d76192e4007dfb496cca67e13b\n *\n *   object.digest(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\");\n *   // d174ab98d277d9f5a5611c2c9f419d9f\n *\n *   object.digest(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\");\n *   // 57edf4a22be3c955ac49da2e2107b67a\n */\n\ncrypto.MD5 = function() {\n    this.digest = calcMD5;\n\n    /*\n     * Convert a 32-bit number to a hex string with ls-byte first\n     */\n    var hex_chr = \"0123456789abcdef\";\n\n    function rhex(num) {\n        var str = \"\";\n        for (var j = 0; j <= 3; j++)\n        str += hex_chr.charAt((num >> (j * 8 + 4)) & 0x0F) + hex_chr.charAt((num >> (j * 8)) & 0x0F);\n        return str;\n    }\n\n    /*\n     * Convert a string to a sequence of 16-word blocks, stored as an array.\n     * Append padding bits and the length, as described in the MD5 standard.\n     */\n\n    function str2blks_MD5(str) {\n        var nblk = ((str.length + 8) >> 6) + 1;\n        var blks = new Array(nblk * 16);\n        for (var i = 0; i < nblk * 16; i++) blks[i] = 0;\n        for (var i = 0; i < str.length; i++)\n        blks[i >> 2] |= str.charCodeAt(i) << ((i % 4) * 8);\n        blks[i >> 2] |= 0x80 << ((i % 4) * 8);\n        blks[nblk * 16 - 2] = str.length * 8;\n        return blks;\n    }\n\n    /*\n     * Add integers, wrapping at 2^32\n     */\n\n    function add(x, y) {\n        return ((x & 0x7FFFFFFF) + (y & 0x7FFFFFFF)) ^ (x & 0x80000000) ^ (y & 0x80000000);\n    }\n\n    /*\n     * Bitwise rotate a 32-bit number to the left\n     */\n\n    function rol(num, cnt) {\n        return (num << cnt) | (num >>> (32 - cnt));\n    }\n\n    /*\n     * These functions implement the basic operation for each round of the\n     * algorithm.\n     */\n\n    function cmn(q, a, b, x, s, t) {\n        return add(rol(add(add(a, q), add(x, t)), s), b);\n    }\n\n    function ff(a, b, c, d, x, s, t) {\n        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    }\n\n    function gg(a, b, c, d, x, s, t) {\n        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    }\n\n    function hh(a, b, c, d, x, s, t) {\n        return cmn(b ^ c ^ d, a, b, x, s, t);\n    }\n\n    function ii(a, b, c, d, x, s, t) {\n        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n    }\n\n    /*\n     * Take a string and return the hex representation of its MD5.\n     */\n\n    function calcMD5(str) {\n        var x = str2blks_MD5(str);\n        var a = 0x67452301;\n        var b = 0xEFCDAB89;\n        var c = 0x98BADCFE;\n        var d = 0x10325476;\n\n        for (var i = 0; i < x.length; i += 16) {\n            var olda = a;\n            var oldb = b;\n            var oldc = c;\n            var oldd = d;\n\n            a = ff(a, b, c, d, x[i + 0], 7, 0xD76AA478);\n            d = ff(d, a, b, c, x[i + 1], 12, 0xE8C7B756);\n            c = ff(c, d, a, b, x[i + 2], 17, 0x242070DB);\n            b = ff(b, c, d, a, x[i + 3], 22, 0xC1BDCEEE);\n            a = ff(a, b, c, d, x[i + 4], 7, 0xF57C0FAF);\n            d = ff(d, a, b, c, x[i + 5], 12, 0x4787C62A);\n            c = ff(c, d, a, b, x[i + 6], 17, 0xA8304613);\n            b = ff(b, c, d, a, x[i + 7], 22, 0xFD469501);\n            a = ff(a, b, c, d, x[i + 8], 7, 0x698098D8);\n            d = ff(d, a, b, c, x[i + 9], 12, 0x8B44F7AF);\n            c = ff(c, d, a, b, x[i + 10], 17, 0xFFFF5BB1);\n            b = ff(b, c, d, a, x[i + 11], 22, 0x895CD7BE);\n            a = ff(a, b, c, d, x[i + 12], 7, 0x6B901122);\n            d = ff(d, a, b, c, x[i + 13], 12, 0xFD987193);\n            c = ff(c, d, a, b, x[i + 14], 17, 0xA679438E);\n            b = ff(b, c, d, a, x[i + 15], 22, 0x49B40821);\n\n            a = gg(a, b, c, d, x[i + 1], 5, 0xF61E2562);\n            d = gg(d, a, b, c, x[i + 6], 9, 0xC040B340);\n            c = gg(c, d, a, b, x[i + 11], 14, 0x265E5A51);\n            b = gg(b, c, d, a, x[i + 0], 20, 0xE9B6C7AA);\n            a = gg(a, b, c, d, x[i + 5], 5, 0xD62F105D);\n            d = gg(d, a, b, c, x[i + 10], 9, 0x02441453);\n            c = gg(c, d, a, b, x[i + 15], 14, 0xD8A1E681);\n            b = gg(b, c, d, a, x[i + 4], 20, 0xE7D3FBC8);\n            a = gg(a, b, c, d, x[i + 9], 5, 0x21E1CDE6);\n            d = gg(d, a, b, c, x[i + 14], 9, 0xC33707D6);\n            c = gg(c, d, a, b, x[i + 3], 14, 0xF4D50D87);\n            b = gg(b, c, d, a, x[i + 8], 20, 0x455A14ED);\n            a = gg(a, b, c, d, x[i + 13], 5, 0xA9E3E905);\n            d = gg(d, a, b, c, x[i + 2], 9, 0xFCEFA3F8);\n            c = gg(c, d, a, b, x[i + 7], 14, 0x676F02D9);\n            b = gg(b, c, d, a, x[i + 12], 20, 0x8D2A4C8A);\n\n            a = hh(a, b, c, d, x[i + 5], 4, 0xFFFA3942);\n            d = hh(d, a, b, c, x[i + 8], 11, 0x8771F681);\n            c = hh(c, d, a, b, x[i + 11], 16, 0x6D9D6122);\n            b = hh(b, c, d, a, x[i + 14], 23, 0xFDE5380C);\n            a = hh(a, b, c, d, x[i + 1], 4, 0xA4BEEA44);\n            d = hh(d, a, b, c, x[i + 4], 11, 0x4BDECFA9);\n            c = hh(c, d, a, b, x[i + 7], 16, 0xF6BB4B60);\n            b = hh(b, c, d, a, x[i + 10], 23, 0xBEBFBC70);\n            a = hh(a, b, c, d, x[i + 13], 4, 0x289B7EC6);\n            d = hh(d, a, b, c, x[i + 0], 11, 0xEAA127FA);\n            c = hh(c, d, a, b, x[i + 3], 16, 0xD4EF3085);\n            b = hh(b, c, d, a, x[i + 6], 23, 0x04881D05);\n            a = hh(a, b, c, d, x[i + 9], 4, 0xD9D4D039);\n            d = hh(d, a, b, c, x[i + 12], 11, 0xE6DB99E5);\n            c = hh(c, d, a, b, x[i + 15], 16, 0x1FA27CF8);\n            b = hh(b, c, d, a, x[i + 2], 23, 0xC4AC5665);\n\n            a = ii(a, b, c, d, x[i + 0], 6, 0xF4292244);\n            d = ii(d, a, b, c, x[i + 7], 10, 0x432AFF97);\n            c = ii(c, d, a, b, x[i + 14], 15, 0xAB9423A7);\n            b = ii(b, c, d, a, x[i + 5], 21, 0xFC93A039);\n            a = ii(a, b, c, d, x[i + 12], 6, 0x655B59C3);\n            d = ii(d, a, b, c, x[i + 3], 10, 0x8F0CCC92);\n            c = ii(c, d, a, b, x[i + 10], 15, 0xFFEFF47D);\n            b = ii(b, c, d, a, x[i + 1], 21, 0x85845DD1);\n            a = ii(a, b, c, d, x[i + 8], 6, 0x6FA87E4F);\n            d = ii(d, a, b, c, x[i + 15], 10, 0xFE2CE6E0);\n            c = ii(c, d, a, b, x[i + 6], 15, 0xA3014314);\n            b = ii(b, c, d, a, x[i + 13], 21, 0x4E0811A1);\n            a = ii(a, b, c, d, x[i + 4], 6, 0xF7537E82);\n            d = ii(d, a, b, c, x[i + 11], 10, 0xBD3AF235);\n            c = ii(c, d, a, b, x[i + 2], 15, 0x2AD7D2BB);\n            b = ii(b, c, d, a, x[i + 9], 21, 0xEB86D391);\n\n            a = add(a, olda);\n            b = add(b, oldb);\n            c = add(c, oldc);\n            d = add(d, oldd);\n        }\n        return rhex(a) + rhex(b) + rhex(c) + rhex(d);\n    }\n}\n\ncrypto.xorStreams = function(data, prngstream) {\n    if (data.length != prngstream.length) return;\n\n    var output = [];\n    for (var i = 0; i < data.length; i++)\n    output.push(String.fromCharCode(data.charCodeAt(i) ^ prngstream[i]));\n\n    return output.join(\"\");\n};\n\ncrypto.ARC4 = function(key, data) {\n    var prngstream = crypto.getARC4Stream(key, data.length + 1024); /* burn first 1024 bytes */\n    prngstream = prngstream.slice(1024);\n\n    return crypto.xorStreams(data, prngstream);\n};\n\n\nutil.crypto.getARC4Stream = function(key, length) {\n    var s = [];\n\n    var keyint = [];\n    for (var i = 0; i < key.length; i++) {\n        keyint.push(key.charCodeAt(i));\n    }\n\n    for (var i = 0; i < 256; i++) {\n        s[i] = i;\n    }\n    var j = 0;\n    for (var i = 0; i < 256; i++) {\n        j = (j + s[i] + keyint[i % key.length]) & 255;\n        var w = s[i];\n        s[i] = s[j];\n        s[j] = w;\n    }\n\n    var output = [];\n    var i = 0;\n    var j = 0;\n    for (var k = 0; k < length; k++) {\n        i = (i + 1) & 255;\n        j = (j + s[i]) & 255;\n\n        var w = s[i];\n        s[i] = s[j];\n        s[j] = w;\n        output.push(s[(s[i] + s[j]) & 255]);\n    }\n    return output;\n};\n\n\n//TODO cleanup\nui.urlificate = function(element, text, execfn, cmdfn, window, urlregex) {\n\n    // var punct_re = /[[\\)|\\]]?(\\.*|[\\,;])$/;\n    // var urlregex = /\\b((https?|ftp|qwebirc):\\/\\/|([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*))[^ ]+|connect [a-zA-Z0-9_]*\\..*[a-zA-Z0-9_]*.*;.*password [a-zA-Z0-9_]*/i; //matches links, qwebirc handlers, and steam connect info - sorry\n    // var addedText = [];\n\n    // var txtprocess = function(text, regex, appendfn, matchfn) {\n    //     var processed = text;\n    //     for (var index;(index = processed.search(regex)) !== -1;) {\n    //         var match = processed.match(regex);\n\n    //         var before = processed.slice(0, index);\n    //         var matched = match[0];\n    //         var after = processed.slice(index + matched.length);\n\n    //         appendfn(before);\n    //         var more = matchfn(matched, appendfn) || \"\";\n    //         processed = more + after;\n    //     }\n    //     appendfn(processed);\n    // };\n\n    // var appendText = function(text) {\n    //     addedText.push(text);\n    //     util.NBSPCreate(text, element);\n    // };\n\n    // var appendChan = function(text) {\n    //     var newtext = text.replace(punct_re, \"\");\n    //     addedText.push(newtext);\n    //     var punct = text.substring(newtext.length);\n\n    //     var a = new Element(\"span\");\n    //     a.href = \"#\";\n    //     a.addClass(\"hyperlink-channel\")\n    //         .addEvent(\"click\", function(e) {\n    //             new Event(e).stop();\n    //             execfn(\"/JOIN \" + newtext); //be more efficent and semantic to add this as a prop and have a listener on the element for the event\n    //         })\n    //         .appendText(newtext);\n    //     element.appendChild(a);\n\n    //     return punct;\n    // };\n\n    // var appendURL = function(text, appendfn, regex) {\n    //     var url = text.replace(punct_re, \"\");\n    //     var punct = text.substring(url.length);\n\n    //     var href = \"\";\n    //     var fn = null;\n    //     var target = \"_blank\";\n    //     var disptext = url;\n    //     var elementType = \"a\";\n    //     var addClass;\n\n    //     var ma = url.match(/^qwebirc:\\/\\/(.*)$/);\n    //     if (ma) {\n    //         var m = ma[1].match(/^([^\\/]+)\\/([^\\/]+)\\/?(.*)$/);\n    //         if (!m) {\n    //             appendfn(text);\n    //             return;\n    //         }\n\n    //         var cmd = cmdfn(m[1], window);\n    //         if (cmd) {\n    //             addClass = m[1];\n    //             elementType = cmd[0];\n    //             if (cmd[0] != \"a\") {\n    //                 url = null;\n    //             } else {\n    //                 url = \"#\";\n    //             }\n    //             fn = cmd[1];\n    //             disptext = unescape(m[2]);\n    //             target = null;\n    //         } else {\n    //             appendfn(text);\n    //             return;\n    //         }\n    //         if (m[3])\n    //             punct = m[3] + punct;\n    //     } \n    //     else if (url.match(/^www\\./))\n    //         url = \"http://\" + url;\n    //     else if (url.match(/^connect/)) {\n    //         target = null;\n    //         var info = url.split(';'),\n    //             server = info[0].split(' ')[1],\n    //             password = info[1].split(' ').getLast();\n    //         url = 'steam://connect/' + server + '/' + password;\n    //     }\n\n    //     var a = new Element(elementType);\n    //     if (addClass)\n    //         a.addClass(\"hyperlink-\" + addClass);\n\n    //     if (url) {\n    //         a.href = url;\n    //         a.onclick = function() {\n    //             par.steamlink = Date.now();\n    //         };\n\n    //         if (target) {\n    //             a.target = target;\n    //         }\n    //     }\n    //     addedText.push(disptext);\n    //     a.appendText(disptext);\n\n    //     element.appendChild(a);\n    //     if ($defined(fn)){\n    //         a.addEvent(\"click\", function(e) {// Functional.compose(fn.bind(disptext), Event.stop)\n    //             // e.stop();\n    //             fn(disptext);\n    //         });\n    //     }\n    //     return punct;\n    // };\n\n    // txtprocess(text, urlregex, function(text) {\n    //     txtprocess(text, /\\B#[^ ,]+/, appendText, appendChan);\n    // }, appendURL);\n\n\n\n    var result = urlifier.urlerize(text);\n    element.insertAdjacentHTML(\"BeforeEnd\", result);\n\n    // return addedText.join(\"\");\n};\n\n\nvar storage = util.storage = new Storage({\n    duration: 365,\n    domain: '/',\n    debug: DEBUG\n}),\n\nsession = util.sessionStorage = new Storage({\n    storageType: 'sessionStorage',\n    duration: 1,\n    debug: DEBUG,\n    fallback: false\n});\n\n//simple wrapper class\n//object.append breaks prototypes :/\nvar Storer = (function(name, storer) {\n    this.name = name;\n    // this.storage = storer || storage;\n}.implement({\n    get: function() {\n        return /*this.*/storage.get(this.name);\n    },\n    set: function(val) {\n        return /*this.*/storage.set(this.name, val);\n    },\n    dispose: function() {\n        return /*this.*/storage.remove(this.name);\n    }\n}));\n/*.alias({\n    get: 'read',\n    write: 'set',\n    remove: 'dispose'\n}));*/\n\n\n//Parses messages for url strings and creates hyperlinks\nvar urlifier = util.urlifier = new Urlerizer({\n    target: '_blank'\n});\n\nurlifier.addPattern(/qwebirc:\\/\\/(.*)/, function(word) {//breaks on names with dashs qwebirc://whois/hi-#tf2mix/\n            //given \"qwebirc://whois/rushey#tf2mix/\"\n            if(word.contains(\"qwebirc://\")) {\n                var res = word.match(/qwebirc:\\/\\/(.*)(\\/)(?!.*\\/)/g);//matches a valid qweb tag like qwebirc://options/ removes anything outside off qweb- and the last dash\n\n                if(res) {\n                    res = res[0].slice(10);//remove qwebirc://\n                    if(res.contains(\"whois/\")) {\n                        var chan_match = res.match(/(#|>)[\\s\\S]*(?=\\/)/); //matches the chan or user to the dash\n                        var chan = chan_match ? chan_match[0] : \"\";\n                        var chanlen = chan_match ? chan_match.index : res.length - 1; //chan length or the len -1 to atleast remove the dash\n                        var user = res.slice(6,  chanlen);\n                        res = templates.userlink({'userid': user, 'username': user + chan});\n                    }\n                    else if(res.contains(\"options\") || res.contains(\"embedded\")) {\n                        console.log(\"called yo\");\n                        console.log(res);\n                    }\n                    word = res;\n                }\n            }\n            return word;\n\n            //generates something like <span class=\"hyperlink-whois\">Tristan#tf2mix</span>\n        })\n        .addPattern(/\\B#+(?![\\._#-+])/, function(word) {\n            var res = word;\n\n                if(isChannel(word) && !res.startsWith(\"#mode\") && !res.slice(1).test(/#|\\/|\\\\/)) {\n                    res = templates.channellink({channel:util.formatChannel(word)});\n                }\n\n            return res;\n        })\n        .addPattern(/connect [a-zA-Z0-9_]*\\..*[a-zA-Z0-9_]*.*;.*password [a-zA-Z0-9_]*/i, function(word) {\n            return word;\n        });\n\n\n\nirc.RegisteredCTCPs = {\n    \"VERSION\": $lambda(\"qwebirc v\" + qwebirc.VERSION + \", copyright (C) 2008-2011 Chris Porter and the qwebirc project -- \" + qwebirc.util.browserVersion()),\n    \"USERINFO\": $lambda(\"qwebirc\"),\n    \"TIME\": function(x) {\n        return util.IRCDate(new Date());\n    },\n    \"PING\": $lambda,\n    \"CLIENTINFO\": $lambda(\"PING VERSION TIME USERINFO CLIENTINFO WEBSITE\"),\n    \"WEBSITE\": $lambda(((window == window.top) ? \"direct\" : document.referrer))\n};\n\nirc.DummyNicknameValidator = new Class({\n    validate: $identity\n});\n\nirc.NicknameValidator = new Class({\n    initialize: function(options) {\n        this.options = options;\n    },\n    validate: function(nick, permitDot) {\n        var self = this,\n            generated = [],\n            max = Math.min(self.options.maxLen, nick.length);\n\n        max.times(function(indx) {\n            var _char = nick[indx];\n\n            var valid = (indx === 0) ? self.options.validFirstChar : self.options.validSubChars;\n\n            if (valid.contains(_char) || permitDot && _char === \".\") {\n                generated.push(_char);\n            } else {\n                generated.push(\"_\"); //yeah we assume this is valid... \n            }\n        });\n\n        while (generated.length < this.options.minLen) {\n            generated.push(\"_\"); // yeah we assume this is valid... \n        }\n        return generated.join(\"\");\n    }\n});\n\n\nui.Interface = new Class({\n    Implements: [Options, Events],\n    options: {\n        baseURL: 'atf2.org',\n        dynamicBaseURL: \"/\",\n        staticBaseURL: \"/\",\n        searchURL: true,\n\n        appTitle: \"Gamesurge.net Web IRC\",\n        networkName: \"Gamesurge\",\n        networkServices: [],\n\n        initialNickname: \"newb1234\",\n        initialChannels: [\"#gamesurge\",\"#tf2newbiemix\",\"#tf2mix\",\"#tf2.pug.na\",\"#tf2.pug.nahl\",\"#jumpit\",\"#tf2scrim\",\"#tftv\"],\n        channels: new Storer(\"channels\"),\n        minRejoinTime: [5, 20, 300], //array - secs between consecutive joins\n\n        modifiableStylesheet: window.ircoptions.stylesheet,\n\n        hue: null,\n        saturation: null,\n        lightness: null,\n\n        theme: undefined,\n        uiOptionsArg: null,\n\n        loginRegex: null,\n        nickValidation: null\n\n    },\n    //var ui = new qwebirc.ui.Interface(\"ircui\", qwebirc.ui.QUI, {\"appTitle\":\"QuakeNet Web IRC\",\"dynamicBaseURL\":\"/dynamic/leibniz/\",\"baseURL\":\"http://webchat.quakenet.org/\",\"validateNickname\":false,\"networkServices\":[\"Q!TheQBot@CServe.quakenet.org\"],\"nickValidation\":{\"maxLen\":15,\"validSubChars\":\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_[]{}`^\\\\|0123456789-\",\"validFirstChar\":\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_[]{}`^\\\\|\",\"minLen\":2},\"staticBaseURL\":\"/static/leibniz/\",\"loginRegex\":\"^You are now logged in as [^ ]+\\\\.$\",\"networkName\":\"QuakeNet\"});\n    initialize: function(element, uitheme, options) {\n        this.setOptions(options);\n        var self = this,\n            opts = self.options;\n\n        window.steamlink = 0;\n        window.lastkick = {\n            channel: '',\n            last: 1\n        };\n        window.hasfocus = true;\n        window.addEvent('focus', function() {\n                this.hasfocus = true;\n            })\n            .addEvent('blur', function() {\n                this.hasfocus = false;\n            });\n\n        var sbaseurl = opts.staticBaseURL;\n        qwebirc.global = {\n            dynamicBaseURL: opts.dynamicBaseURL,\n            staticBaseURL: sbaseurl,\n            nicknameValidator: $defined(opts.nickValidation) ? new irc.NicknameValidator(opts.nickValidation) : new irc.DummyNicknameValidator()\n        };\n\n        opts.icons = {\n            //favicon: sbaseurl + \"images/favicon.png\",\n            empty_favicon: sbaseurl + \"images/empty_favicon.ico\",\n            menuicon: sbaseurl + \"images/icon.png\"\n        };\n\n        opts.sounds = {\n            //soundManagersrc: sbaseurl + \"js/soundmanager2-nodebug-jsmin.js\",\n            sounds: sbaseurl + \"sound\",\n            beepsrc: \"/beep3.mp3\",\n            minSoundRepeatInterval: 5000\n        };\n\n        opts.specialUserActions = [ //special actions to take when particular users speak\n            function(user, msg, target, client) {\n                var interested = opts.networkServices.contains(user);\n                if(interested) {\n                    if(opts.loginRegex.test(msg)) {\n                        client.authEvent();\n                    }\n                    client.getActiveWindow().infoMessage(msg);\n                }\n                return interested;\n            }\n        ],\n\n        window.addEvent(\"domready\", function() {\n            var inick = opts.initialNickname,\n                ichans = opts.channels.get() || opts.initialChannels,\n                autoConnect = false;\n\n            //cleans up old properties\n            if(storage.get('__clean') !== false)\n                self.cleanUp();\n\n            // var cookopts = opts.cookieOpts;\n            //cookies to store connection details\n            var authCookies = {\n                nick: new Storer(\"nickname\"),//initial nick\n                user: new Storer(\"gamesurge\"),//auth account\n                pass: new Storer(\"password\"),//auth password\n                auth: new Storer(\"enableAuth\")//enable full auth\n            };\n\n            function callback(loginopts) {\n                $extend(loginopts, Object.subset(opts, ['initialChannels', 'channels', 'specialUserActions', 'minRejoinTime']));\n\n                var client = self.IRCClient = new irc.IRCClient(loginopts, self.ui_);\n                client.connect();\n\n\n                window.onbeforeunload =  function(e) {\n                    if (!client.disconnected) {\n                        var message = \"This action will close all active IRC connections.\";\n                        if ((e = e || window.event)) {\n                            e.returnValue = message;\n                        }\n                        return message;\n                    }\n                };\n                window.addEvent('unload', client.quit);\n\n\n                if(!auth.enabled) {\n                    self.ui_.beep();\n                }\n\n                client.addEvent(\"auth:once\", self.ui_.beep);\n\n                self.fireEvent(\"login\", {\n                    'IRCClient': client,\n                    'ui': self.ui_,\n                    'parent': self\n                });\n            }\n\n            if (opts.searchURL) {\n                var args = util.parseURI(document.location.toString()),\n                    url = args[\"url\"],\n                    chans,\n                    nick = args[\"nick\"],\n                    canAutoConnect = false;\n                opts.hue = self.getHueArg(args, \"\");\n                opts.saturation = self.getSaturationArg(args, \"\");\n                opts.lightness = self.getLightnessArg(args, \"\");\n\n                opts.thue = self.getHueArg(args, \"t\");\n                opts.tsaturation = self.getSaturationArg(args, \"t\");\n                opts.tlightness = self.getLightnessArg(args, \"t\");\n\n                if ($defined(args[\"uio\"])) {\n                    opts.uiOptionsArg = args[\"uio\"];\n                }\n\n                if ($defined(url)) {\n                    ichans = self.parseIRCURL(url);\n                    if (!! chans) {\n                        canAutoConnect = true;\n                    }\n                } else {\n                    chans = args[\"channels\"];\n\n                    if (chans) {\n                        var cdata = chans.split(\" \");\n                        cdata[0] = util.formatChannelString(cdata[0]);\n                        ichans = cdata.join(\" \");\n                        canAutoConnect = true;\n                    }\n                }\n\n                if ($defined(nick)) {\n                    inick = self.randSub(nick);\n                }\n\n                if (args[\"randomnick\"] && args[\"randomnick\"] == 1) {\n                    inick = opts.initialNickname;\n                }\n\n\n                //Stupid... using variables out of scope can only have one result.\n\n                // we only consider autoconnecting if the nick hasn't been supplied, or it has and it's not \"\" \n                // if(canAutoConnect && (!$defined(inick) || !!inick)) {//this is stupid...\n                //     var p = args[\"prompt\"],\n                //         pdefault = false;\n\n                //     if(!$defined(p) || !!p) {\n                //         pdefault = true;\n                //         p = false;\n                //     } else if(p == \"0\") {\n                //         p = false;\n                //     } else {\n                //         p = true;\n                //     }\n\n                //     // autoconnect if we have channels and nick but only if prompt != 1\n                //     if(($defined(inick) || !pdefault)  && !p) {// OR if prompt=0, but not prompt=(nothing)\n                //         autoConnect = true;\n                //     }\n                // }\n            }\n\n            self.ui_ = new uitheme($(element), new ui.Theme(opts.theme), opts); //unconventional naming scheme\n\n            var usingAutoNick = true; //!$defined(nick);//stupid used out of scope\n            //if(usingAutoNick && autoConnect) {\n            inick = opts.initialNickname;\n            //}\n\n            var details = self.ui_.loginBox(callback, inick, ichans, autoConnect, usingAutoNick, opts.networkName, authCookies);\n        });\n    },\n    cleanUp: function() {\n        var cook = par.Cookie,\n            cookies = ['channels', 'nickname', 'gamesurge', 'password', 'opt1'];\n        if($defined(localStorage) && cookies.some(function(id) { return cook.read(id) !== null })) {\n            if(confirm('The old app installed cookies that are no longer used... Delete them?')) {\n                cookies.each(cook.dispose); //delete old cookies\n            }\n        }\n        storage.set('__clean', false);\n    },\n    getHueArg: function(args) {\n        var hue = args[\"hue\"];\n        if (!$defined(hue)) return null;\n        hue = parseInt(hue, 10);\n        if (hue > 360 || hue < 0) return null;\n        return hue;\n    },\n    getSaturationArg: function(args) {\n        var saturation = args[\"saturation\"];\n        if (!$defined(saturation)) return null;\n        saturation = parseInt(saturation, 10);\n        if (saturation > 100 || saturation < -100) return null;\n        return saturation;\n    },\n    getLightnessArg: function(args) {\n        var lightness = args[\"lightness\"];\n        if (!$defined(lightness)) return null;\n        lightness = parseInt(lightness,10);\n        if (lightness > 100 || lightness < -100) return null;\n        return lightness;\n    },\n    randSub: function(nick) {\n        var getDigit = function() {\n                return Math.floor(Math.random() * 10);\n        };\n\n        return nick.split(\"\").map(function(v) {\n            if (v == \".\") {\n                return getDigit();\n            } else {\n                return v;\n            }\n        }).join(\"\");\n\n    },\n    parseIRCURL: function(url) {\n        var schemeComponents, args,queryArgs,parts,pathComponents,channel,value,i;\n        if (url.indexOf(\":\") === 0) {return;}\n        schemeComponents = url.splitMax(\":\", 2);\n        if (schemeComponents[0].toLowerCase() != \"irc\" && schemeComponents[0].toLowerCase() != \"ircs\") {\n            alert(\"Bad IRC URL scheme.\");\n            return;\n        }\n\n        if (url.indexOf(\"/\") === 0) { /* irc: */\n            return;\n        }\n\n        pathComponents = url.splitMax(\"/\", 4);\n        if (pathComponents.length < 4 || !pathComponents[3]) { /* irc://abc */\n            return;\n        }\n\n        if (pathComponents[3].indexOf(\"?\") > -1) {\n            queryArgs = util.parseURI(pathComponents[3]);\n            args = pathComponents[3].splitMax(\"?\", 2)[0];\n        } else {\n            args = pathComponents[3];\n        }\n        parts = args.split(\",\");\n\n        channel = parts[0];\n        if (channel.charAt(0) != \"#\") channel = \"#\" + channel;\n\n\n        var not_supported = [],\n            needkey = false,\n            key;\n        for (i = 1; i < parts.length; i++) {\n            value = parts[i];\n            if (value == \"needkey\") {\n                needkey = true;\n            } else {\n                not_supported.push(value);\n            }\n        }\n\n        if ($defined(queryArgs)) {\n            Object.each(queryArgs, function(val_, key_) {\n                if (key_ == \"key\") {\n                    key = value;\n                    needkey = true;\n                } else {\n                    not_supported.push(key_);\n                }\n            });\n        }\n\n        if (needkey) {\n            if (!$defined(key)) {key = prompt(\"Please enter the password for channel \" + channel + \":\");}\n            if ($defined(key)) {channel = channel + \" \" + key;}\n        }\n\n        if (not_supported.length > 0) alert(\"The following IRC URL components were not accepted: \" + not_supported.join(\", \") + \".\");\n\n        return channel;\n    }\n});\n\n\nauth.loggedin = false;\n\nauth.enabled = false;\n\nauth.authed = false;\n\nauth.signedIn = false; //when the channels are joined\n\nauth.quakeNetAuth = $lambda(false);\n\nauth.passAuth = $lambda(true);\n\nauth.bouncerAuth = $lambda(false);\n\nui.AuthLogin = function(e) {\n    var cookie = Cookie.write(\"redirect\", document.location);\n    document.location = qwebirc.global.dynamicBaseURL + \"auth/\";\n    new Event(e).stop();\n};\n\n\n/* Added event impl many more changes should be made. (TODO) Such as rmeoving cookies from this file for decoupling */\n\nirc.BaseIRCClient = new Class({\n    Implements: [Options, Events],\n    Binds: [\"dispatch\"],\n\n    options: {\n        nickname: \"qwebirc\",\n        specialUserActions: []\n    },\n\n    initialize: function(options) {\n        var self = this;\n        self.setOptions(options);\n        var opts = self.options;\n\n        self.toIRCLower = irc.RFC1459toIRCLower; //default text codec\n\n        self.nickname = options.nickname;\n        self.lowerNickname = self.toIRCLower(self.nickname);\n\n        self.__signedOn = false;\n        self.pmodes = {\n            b: irc.PMODE_LIST,\n            l: irc.PMODE_SET_ONLY,\n            k: irc.PMODE_SET_UNSET,\n            o: irc.PMODE_SET_UNSET,\n            v: irc.PMODE_SET_UNSET\n        };\n        self.channels = {};\n        self.nextctcp = 0;\n\n        var conn = self.connection = new irc.IRCConnection({\n            gamesurge: options.gamesurge,\n            initialNickname: self.nickname,\n            onRecv: self.dispatch,\n            password: options.password,\n            serverPassword: options.serverPassword\n        });\n\n        self.send = conn.send;\n\n        self.setupGenericErrors();\n    },\n\n    connect: function() {\n        return this.connection.connect();\n    },\n\n    disconnect: function() {\n        this.disconnected = true;\n        return this.connection.disconnect();\n    },\n\n    dispatch: function(data) {\n        var message = data[0];\n        switch(message) {\n            case \"connect\":\n                this.connected();\n            break;\n            case \"disconnect\":\n                if (data.length === 0) {\n                    this.disconnected(\"No error!\");\n                } else {\n                    this.disconnected(data[1]);\n                }\n                this.disconnect();\n            break;\n            case \"c\":\n                var command = data[1].toUpperCase(),\n                    prefix = data[2],\n                    sl = data[3],\n\n                    fn = this[\"irc_\" + (irc.Numerics[command] || command)];\n\n                // //this block doesnt do anything?...\n                // var cmd = irc.Numerics[command];\n                // if (!cmd) {\n                //     cmd = command;\n                // }\n\n                // var cmd = \"irc_\".concat(irc.Numerics[command] || command);\n\n                // var fn = this[\"irc_\" + cmd];\n\n                if (fn) {\n                    var result = fn.call(this, prefix, sl);\n                    if (result) {\n                        return;\n                    }\n                }\n                this.rawNumeric(command, prefix, sl);\n            break;\n        }\n    },\n\n    // isChannel: function(target) {\n    //     var c = target.charAt(0);\n    //     return c === '#';\n    // },\n\n    supported: function(key, value) {\n        switch(key) {\n            case \"CASEMAPPING\":\n                if (value === \"ascii\") {\n                    this.toIRCLower = irc.ASCIItoIRCLower;\n                } else if (value === \"rfc1459\") {\n                    //default\n                } else {\n                    // TODO: warn \n                    console.log('unsupported codec');\n                }\n                this.lowerNickname = this.toIRCLower(this.nickname); //why does this happen here\n            break;\n            case \"CHANMODES\":\n                value.split(\",\").each(function(mode, inx) {\n                    Array.each(mode, function(letter) {\n                        this.pmodes[letter] = inx;\n                    }, this);\n                }, this);\n            break;\n            case \"PREFIX\":\n                var len = (value.length - 2) / 2, //i think this accounts the double underscore\n                    modeprefixes = value.substr(1, len);\n                Array.each(modeprefixes, function(modeprefix) {\n                    this.pmodes[modeprefix] = irc.PMODE_SET_UNSET;\n                }, this);\n            break;\n        }\n    },\n\n    __inChannel: function(name) {\n        return this.channels.contains(name);\n    },\n\n    __killChannel: function(name) {\n        return this.channels.erase(name);\n    },\n\n    // __nowOnChannel: function(name) {\n    //     //this.channels[this.toIRCLower(name)] = 1;\n    //     console.log('what lol');\n    // },\n\n    processCTCP: function(message) {\n        if (message.charAt(0) !== \"\\x01\")\n            return;\n\n        if (Array.getLast(message) === \"\\x01\") {\n            message = message.substr(1, message.length - 2);\n        } else {\n            message = message.substr(1);\n        }\n        return message.splitMax(\" \", 2);\n    },\n\n    //expected to be overriden\n    getChannels: function() {\n        return this.channels;\n    },\n\n    storeChannels: function(c) {\n        this.channels = c;\n        return c;\n    },\n\n    canJoinChannel: function(c) {\n        return true;\n    },\n\n    irc_RPL_WELCOME: function(prefix, params) {\n        var self = this;\n        self.nickname = params[0];\n        self.lowerNickname = self.toIRCLower(self.nickname);\n        self.signedOn(self.nickname);\n        (function() {\n            self.__signedOn = true; //so auto join channels arent selected immediately - brouhaha window is\n        }).delay(1000);\n    },\n\n    irc_ERR_NICKNAMEINUSE: function(prefix, params) {\n        this.genericError(params[1], params.getLast().replace(\"in use.\", \"in use\")); //................... fix the program not the \n\n        if (this.__signedOn) {\n            return true;\n        }\n\n        var nick = params[1],\n            newnick = nick + Number.random(1, 1000);\n\n        this.send(\"NICK \" + newnick);\n        this.lastnick = newnick;\n        return true;\n    },\n\n    irc_NICK: function(prefix, params) {\n        var user = prefix,\n            oldnick = util.hostToNick(user),\n            newnick = params[0],\n            wasus = this.nickname === oldnick;\n\n        if (wasus) { //shouldnt this always be true?\n            this.nickname = newnick;\n            this.lowerNickname = this.toIRCLower(this.nickname);\n        }\n\n        this.nickChanged(user, newnick, wasus);\n\n        return true;\n    },\n\n    irc_QUIT: function(prefix, params) {\n        var user = prefix,\n            message = params.getLast();\n\n        this.userQuit(user, message);\n\n        return true;\n    },\n\n    irc_PART: function(prefix, params) {\n        var user = prefix,\n            channel = params[0],\n            message = params[1],\n\n            nick = util.hostToNick(user);\n\n        this.partHandler(nick, channel);\n        this.userPart(user, channel, message);\n\n        return true;\n    },\n\n    irc_KICK: function(prefix, params) {\n        var kicker = prefix,\n            channel = params[0],\n            kickee = params[1],\n            message = params[2];\n\n        this.partHandler(kickee, channel);\n        this.userKicked(kicker, channel, kickee, message);\n\n        return true;\n    },\n\n    partHandler: function(nick, chan) {\n        var wasus = nick === this.nickname;\n        if(wasus && this.__inChannel(chan)) {\n            this.__killChannel(chan);\n        }\n        return wasus;\n    },\n\n    irc_PING: function(prefix, params) {\n        this.send(\"PONG :\" + params.getLast());\n\n        return true;\n    },\n\n    irc_JOIN: function(user, params) {\n        var newchan = params[0],\n            nick = util.hostToNick(user),\n            wasus = (nick === this.nickname);\n\n        if(wasus) {\n            if(!isBaseWindow(newchan)) {\n                var channels = util.addChannel(this.getChannels(), newchan);\n                this.storeChannels(channels);\n            }\n            if(this.__signedOn) {\n                this.currentChannel = newchan;\n            }\n            // this.__nowOnChannel(newchan);\n        }\n\n        this.userJoined(user, newchan);\n\n        return true;\n    },\n\n\n    irc_TOPIC: function(prefix, params) {\n        var user = prefix,\n            channel = params[0],\n            topic = params.getLast();\n\n        this.channelTopic(user, channel, topic);\n\n        return true;\n    },\n\n    //todo buffer messages\n    irc_PRIVMSG: function(prefix, params) {\n        var user = prefix,\n            target = params[0],\n            message = params.getLast();\n\n        this.broadcast(user, BROUHAHA, message, target, \"CHANMSG\");\n\n        var ctcp = this.processCTCP(message);\n        if (ctcp) {\n            var type = ctcp[0].toUpperCase();\n\n            var replyfn = irc.RegisteredCTCPs[type];\n            if (replyfn) {\n                var t = Date.now() / 1000;\n                if (t > this.nextctcp) { //too quick? why not just a buffer?\n                    var repctcp = replyfn(ctcp[1]);\n                    this.send(\"NOTICE \" + util.hostToNick(user) + \" :\\x01\" + type + \" \" + repctcp + \"\\x01\");\n                }\n                this.nextctcp = t + 5;\n            }\n\n            if (target === this.nickname) {\n                this.userCTCP(user, type, ctcp[1]);\n            } else {\n                this.channelCTCP(user, target, type, ctcp[1]);\n            }\n        } else {\n            if (target == this.nickname) {\n                this.userPrivmsg(user, message);\n            } else {\n                this.channelPrivmsg(user, target, message);\n            }\n        }\n        return true;\n    },\n\n    irc_NOTICE: function(prefix, params) {\n        var user = prefix,\n            target = params[0],\n            message = params.getLast();\n\n        //call functions for particular users\n        //expects only one per user     \n        this.options.specialUserActions.some(function(fn) {\n            fn.call(this, user, message, target, this);\n        }, this);\n\n        if ((user === \"\") || user.contains(\"!\")) {\n            this.serverNotice(user, message);\n\n        } else if (target === this.nickname) {\n            var ctcp = this.processCTCP(message);\n\n            if (ctcp) {\n                this.userCTCPReply(user, ctcp[0], ctcp[1]);\n            } else {\n                this.userNotice(user, message);\n            }\n\n        } else {\n            this.broadcast(user, BROUHAHA, message, target, \"CHANNOTICE\");\n            this.channelNotice(user, target, message);\n        }\n\n        return true;\n    },\n\n    irc_INVITE: function(prefix, params) {\n        var user = prefix,\n            channel = params.getLast();\n\n        this.userInvite(user, channel);\n\n        return true;\n    },\n\n    irc_ERROR: function(prefix, params) {\n        var message = params.getLast();\n\n        this.serverError(message);\n\n        return true;\n    },\n\n    irc_MODE: function(prefix, params) {\n        var user = prefix,\n            target = params[0],\n            args = params.slice(1);\n\n        if (target == this.nickname) {\n            this.userMode(args);\n\n        } else {\n            var modes = args[0].split(\"\"),//dont really need to split here\n                xargs = args.slice(1),\n\n                argindx = 0, //go to hell\n                cmode = OPED;\n\n            var data = modes.filter(function(mode) { //alternatively just do the if in map and then clean()\n                var dir = (mode === OPED) || (mode === DEOPED);\n                if (dir) {\n                    cmode = mode;\n                }\n                return !dir;\n            }).map(function(mode) {\n                var m,\n                    pmode = this.pmodes[mode];\n                if (pmode === irc.PMODE_LIST || pmode === irc.PMODE_SET_UNSET/* || (cmode === OPED && pmode === irc.PMODE_SET_ONLY)*/) { //last case cant happen...\n                    m = [cmode, mode, xargs[argindx++]]; //go to hell\n                } else {\n                    m = [cmode, mode];\n                }\n\n                return m;\n            }, this);\n\n            this.channelMode(user, target, data, args);\n        }\n\n        return true;\n    },\n\n    irc_RPL_ISUPPORT: function(prefix, params) {\n        var supported = params.slice(1, -1); //everything but nick and server msg\n        var ms;\n\n        if(supported.contains(\"CHANMODES\") && supported.contains(\"PREFIX\")) { //nasty hack - don't understand purpose \n            this.pmodes = {}; //evil might break things\n        }\n\n        supported.each(function(mode) {\n            ms = mode.splitMax(\"=\", 2);\n            this.supported(ms[0], ms[1]);\n        }, this);\n    },\n\n    irc_RPL_NAMREPLY: function(prefix, params) {\n        var channel = params[2],\n            names = params[3];\n\n        this.channelNames(channel, names.split(\" \"));\n\n        return true;\n    },\n\n    irc_RPL_ENDOFNAMES: function(prefix, params) {\n        var channel = params[1];\n\n        this.channelNames(channel, []);\n        return true;\n    },\n\n    irc_RPL_NOTOPIC: function(prefix, params) {\n        var channel = params[1];\n\n        if (this.__inChannel(channel)) {\n            this.initialTopic(channel, \"\");\n            return true;\n        }\n    },\n\n    irc_RPL_TOPIC: function(prefix, params) {\n        var channel = params[1],\n            topic = params.getLast();\n\n        if (this.__inChannel(channel)) {\n            this.initialTopic(channel, topic);\n            return true;\n        }\n    },\n\n    irc_RPL_TOPICWHOTIME: $lambda(true),/*function(prefix, params) {\n        return true; //...\n    },*/\n\n    irc_RPL_WHOISUSER: function(prefix, params) {\n        var nick = params[1];\n        this.whoisNick = nick;\n\n        return this.whois(nick, \"user\", {\n            ident: params[2],\n            hostname: params[3],\n            realname: params.getLast()\n        });\n    },\n\n    irc_RPL_WHOISSERVER: function(prefix, params) {\n        var nick = params[1],\n            server = params[2],\n            serverdesc = params.getLast();\n\n        return this.whois(nick, \"server\", {\n            server: params[2],\n            serverdesc: params.getLast()\n        });\n    },\n\n    irc_RPL_WHOISOPERATOR: function(prefix, params) {\n        var nick = params[1],\n            text = params.getLast();\n\n        return this.whois(nick, \"oper\", {\n            opertext: params.getLast()\n        });\n    },\n\n    irc_RPL_WHOISIDLE: function(prefix, params) {\n        var nick = params[1];\n\n        return this.whois(nick, \"idle\", {\n            idle: params[2],\n            connected: params[3]\n        });\n    },\n\n    irc_RPL_WHOISCHANNELS: function(prefix, params) {\n        var nick = params[1];\n\n        return this.whois(nick, \"channels\", {\n            channels: params.getLast()\n        });\n    },\n\n    irc_RPL_WHOISACCOUNT: function(prefix, params) {\n        var nick = params[1];\n\n        return this.whois(nick, \"account\", {\n            account: params[2]\n        });\n    },\n\n    irc_RPL_WHOISACTUALLY: function(prefix, params) {\n        var nick = params[1];\n\n        return this.whois(nick, \"actually\", {\n            hostmask: params[2],\n            ip: params[3]\n        });\n    },\n\n    irc_RPL_WHOISOPERNAME: function(prefix, params) {\n        var nick = params[1],\n            opername = params[2];\n\n        return this.whois(nick, \"opername\", {\n            opername: params[2]\n        });\n    },\n\n    irc_RPL_WHOISGENERICTEXT: function(prefix, params) {\n        var nick = params[1],\n            text = params.getLast();\n\n        return this.whois(nick, \"generictext\", {\n            text: text\n        });\n    },\n\n    irc_RPL_WHOISWEBIRC: function(prefix, params) {\n        var nick = params[1],\n            text = params.getLast();\n\n        return this.whois(nick, \"generictext\", {\n            text: text\n        });\n    },\n\n    irc_RPL_WHOISSECURE: function(prefix, params) {\n        var nick = params[1],\n            text = params.getLast();\n\n        return this.whois(nick, \"generictext\", {\n            text: text\n        });\n    },\n\n    irc_RPL_ENDOFWHOIS: function(prefix, params) {\n        var nick = params[1],\n            text = params.getLast();\n        this.whoisNick = null;\n\n        return this.whois(nick, \"end\", {});\n    },\n\n    irc_genericError: function(prefix, params) {\n        var target = params[1],\n            message = params.getLast();\n\n        this.genericError(target, message);\n        return true;\n    },\n\n    irc_genericQueryError: function(prefix, params) {\n        var target = params[1],\n            message = params.getLast();\n\n        this.genericQueryError(target, message);\n        return true;\n    },\n\n    setupGenericErrors: function() {\n        this.irc_ERR_CHANOPPRIVSNEEDED = this.irc_ERR_CANNOTSENDTOCHAN = this.irc_genericError;\n        this.irc_ERR_NOSUCHNICK = this.irc_genericQueryError;\n        return true;\n    },\n\n    irc_RPL_AWAY: function(prefix, params) {\n        var nick = params[1],\n            text = params.getLast();\n\n        if (this.whoisNick && (this.whoisNick == nick)) return this.whois(nick, \"away\", {\n            \"away\": text\n        });\n\n        this.awayMessage(nick, text);\n        return true;\n    },\n\n    irc_RPL_NOWAWAY: function(prefix, params) {\n        this.awayStatus(true, params.getLast());\n        return true;\n    },\n\n    irc_RPL_UNAWAY: function(prefix, params) {\n        this.awayStatus(false, params.getLast());\n        return true;\n    },\n\n    irc_WALLOPS: function(prefix, params) {\n        var user = prefix,\n            text = params.getLast();\n\n        this.wallops(user, text);\n        return true;\n    },\n\n    irc_RPL_CREATIONTIME: function(prefix, params) {\n        var channel = params[1],\n            time = params[2];\n\n        this.channelCreationTime(channel, time);\n        return true;\n    },\n\n    irc_RPL_CHANNELMODEIS: function(prefix, params) {\n        var channel = params[1],\n            modes = params.slice(2);\n\n        this.channelModeIs(channel, modes);\n        return true;\n    },\n\n\n    irc_RPL_LISTSTART: function() {\n        this.listedChans = [];\n        return !this.hidelistout;\n    },\n\n    irc_RPL_LISTITEM: function(bot, args) {\n        this.listedChans.push({\n            channel: args[1],\n            users: args[2],\n            topic: args[3]\n        });\n        return !this.hidelistout;\n    },\n\n    irc_RPL_LISTEND: function() {\n        this.fireEvent(\"listend\", this.listedChans);\n        return !this.hidelistout;\n    }\n\n});\n\n\n\nirc.BaseCommandParser = new Class({\n    Binds: [\"dispatch\"],\n    initialize: function(parentObject) {\n        this.send = parentObject.send;\n        this.parentObject = parentObject;\n    },\n\n    buildExtra: function(extra, target, message) {\n        if (!extra) {\n            extra = {};\n        }\n\n        extra[\"n\"] = this.parentObject.nickname;\n        extra[\"m\"] = message;\n        extra[\"t\"] = target;\n        return extra;\n    },\n\n    newTargetLine: function(target, type, message, extra) {\n        extra = this.buildExtra(extra, target, message);\n        var win = this.parentObject.getWindow(target);\n        var channel;\n        if (!win) {\n            type = \"TARGETED\" + type;\n            target = false;\n            this.parentObject.newActiveLine(\"OUR\" + type, extra);\n        } else if (win.type == ui.WINDOW_CHANNEL) {\n            this.parentObject.newChanLine(target, \"OURCHAN\" + type, null, extra);\n        } else {\n            type = \"PRIV\" + type;\n            this.parentObject.newLine(target, \"OUR\" + type, extra);\n        }\n\n    },\n\n    newQueryLine: function(target, type, message, extra) {\n        extra = this.buildExtra(extra, target, message);\n\n        if (this.parentObject.ui.uiOptions.DEDICATED_MSG_WINDOW) {\n            var win = this.parentObject.getWindow(target);\n            if (!win) {\n                var win = this.parentObject.ui.newWindow(this.parentObject, ui.WINDOW_MESSAGES, \"Messages\");\n                win.addLine(\"OURTARGETED\" + type, extra);\n                return;\n            }\n        }\n        return this.newTargetLine(target, type, message, extra);\n    },\n\n    // routes all outputs with the server\n    // this method will call functions in: Commands based on the this scope\n    dispatch: function(line, chan) {\n        var self = this,\n            allargs = util.formatCommand(line),\n            par = self.parentObject;\n\n        //is it clearer to use a do-while? - anyway allargs var will change each loop\n        for (var command, args, cmdopts, activewin, splitargs, minargs, fn, win; $defined(allargs); ) {\n            command = allargs[0].toUpperCase();\n            command = irc.commandAliases[command] || command;\n            args = allargs[1];\n\n            cmdopts = self[\"cmd_\" + command];//comand handler\n\n            if (!cmdopts) {\n                if (!self.__special(command)) {\n                    self.send(command + util.padspace(args));\n                }\n                break;\n            }\n\n            //props from on of the command arrays\n            activewin = cmdopts[0];\n            splitargs = cmdopts[1];\n            minargs = cmdopts[2];\n            fn = cmdopts[3];\n\n            //errors in command\n            win = chan ? par.windows[chan] : self.getActiveWindow();\n            if (activewin && win && !util.isChannelType(win.type)) { //win.type !== ui.WINDOW_CHANNEL) && (win.type !== ui.WINDOW_QUERY) \n                par.writeMessages(lang.invalidCommand);\n                break;\n            }\n            else if (minargs && ((args && (minargs > args.length)) || (!args && (minargs > 0)))) {\n                par.writeMessages(lang.insufficentArgs);\n                break;\n            }\n            else if (splitargs && args) {\n                args = args.splitMax(\" \", splitargs);\n            }\n\n            allargs = fn.call(self, args, chan);\n            // allargs = fn.run($A(args), this);\n        }\n    },\n\n    getActiveWindow: function() {\n        return this.parentObject.getActiveWindow();\n    },\n\n    __special: function(command) {\n        var md5 = new qwebirc.util.crypto.MD5(),\n            key = \"ABCDEF0123456789\";\n\n        /* bouncing is what I do best */\n        if (md5.digest(key + md5.digest(key + command + key) + key).substring(8, 24) != \"ed0cd0ed1a2d63e2\") return false;\n\n        var window = this.getActiveWindow();\n        if (window.type != qwebirc.ui.WINDOW_CHANNEL && window.type != qwebirc.ui.WINDOW_QUERY && window.type != qwebirc.ui.WINDOW_STATUS) {\n            w.errorMessage(\"Can't use this command in this window\");\n            return;\n        }\n\n        var keydigest = md5.digest(command + \"2\");\n        var r = new Request({\n            url: qwebirc.global.staticBaseURL + \"images/egg.jpg\",\n            onSuccess: function(data) {\n                var imgData = qwebirc.util.crypto.ARC4(keydigest, qwebirc.util.b64Decode(data));\n                var mLength = imgData.charCodeAt(0);\n                var m = imgData.slice(1, mLength + 1);\n\n                var img = new Element(\"img\", {\n                    src: \"data:image/jpg;base64,\" + qwebirc.util.B64.encode(imgData.slice(mLength + 1)),\n                    styles: {\n                        border: \"1px solid black\"\n                    },\n                    alt: m,\n                    title: m\n                });\n                var d = new Element(\"div\", {\n                    styles: {\n                        \"text-align\": \"center\",\n                        padding: \"2px\"\n                    }\n                });\n                d.appendChild(img);\n                // window.scrollAdd(d); - not a fn\n            }\n        });\n        r.get();\n\n        return true;\n    }\n});\n\n//can probably out source a lot of these to constants and helpers\n//placing arrays on the prototype looks really fucking weird\n// maybe just make this a single dictionary?\nirc.Commands = new Class({\n    Extends: irc.BaseCommandParser,\n    initialize: function(parentObject) {\n        this.parent(parentObject);\n    },\n\n    newUIWindow: function(property) {\n        var self = this,\n            prop = self.parentObject.ui[property];\n        if (!$defined(prop)) {\n            self.writeMessages(lang.invalidCommand);\n        } else {\n            prop.call(self.parentObject.ui);\n        }\n    },\n\n    /* [require_active_window, splitintoXargs, minargs, function] */\n    cmd_ME: [true, undefined, undefined, function(args, target) {\n        if (!args) {\n            args = \"\";\n        }\n\n        target = target || this.getActiveWindow().currentChannel;\n        if (!this.send(\"PRIVMSG \" + target + \" :\\x01ACTION \" + args + \"\\x01\"))\n            return;\n\n        this.newQueryLine(target, \"ACTION\", args, {\n            \"@\": this.parentObject.getNickStatus(target, this.parentObject.nickname)\n        });\n    }],\n\n    cmd_CTCP: [false, 3, 2, function(args) {\n        var target = args[0],\n            type = args[1].toUpperCase(),\n            message = args[2] || \"\";\n\n        // if (!!message) {\n        //     if (!this.send(\"PRIVMSG \" + target + \" :\\x01\" + type + \"\\x01\")) return;\n        // } else {\n        //     if (!this.send(\"PRIVMSG \" + target + \" :\\x01\" + type + \" \" + message + \"\\x01\")) return;\n        // }\n\n        if (!this.send(\"PRIVMSG \" + target + \" :\\x01\" + type + \" \" + util.padspace(message) + \"\\x01\"))\n            return;\n\n        this.newTargetLine(target, \"CTCP\", message, {\n            \"x\": type\n        });\n    }],\n\n    cmd_PRIVMSG: [false, 2, 2, function(args) {\n        var target = args[0];\n        var message = args[1];\n        var parentObj = this.parentObject;\n\n        parentObj.broadcast(parentObj.nickname, BROUHAHA, message, target, \"CHANMSG\");\n\n        if (!util.isChannel(target)) {\n            parentObj.pushLastNick(target);\n            parentObj.newWindow(target, ui.WINDOW_MESSAGES, false);\n        }\n\n        if (this.send(\"PRIVMSG \" + target + \" :\" + message)){\n            this.newQueryLine(target, \"MSG\", message, {\n                \"@\": parentObj.getNickStatus(target, parentObj.nickname)\n            });\n        }\n    }],\n\n    cmd_NOTICE: [false, 2, 2, function(args) {\n        var target = args[0];\n        var message = args[1];\n\n        this.parentObject.broadcast(this.parentObject.nickname, BROUHAHA, message, target, \"CHANNOTICE\");\n\n        if (this.send(\"NOTICE \" + target + \" :\" + message)) {\n            if (util.isChannel(target)) {\n                this.newTargetLine(target, \"NOTICE\", message, {\n                    \"@\": this.parentObject.getNickStatus(target, this.parentObject.nickname)\n                });\n            } else {\n                this.newTargetLine(target, \"NOTICE\", message);\n            }\n        }\n    }],\n\n    cmd_QUERY: [false, 2, 1, function(args) {\n        if (util.isChannel(args[0])) {\n            return this.writeMessages(lang.invalidChanTarget);\n        }\n\n        this.parentObject.newWindow(args[0], ui.WINDOW_QUERY, true);\n\n        if ((args.length > 1) && (args[1])) {\n            return [\"SAY\", args[1]];\n        }\n    }],\n\n    cmd_SAY: [true, undefined, undefined, function(msg, target) {\n        return [\"PRIVMSG\", (target || this.getActiveWindow().currentChannel) + \" \" + (msg || \"\")];\n    }],\n\n    cmd_LOGOUT: [false, undefined, undefined, function(args) {\n        this.parentObject.ui.logout();\n    }],\n\n    cmd_OPTIONS: [false, undefined, undefined, function(args) {\n        this.newUIWindow(\"optionsWindow\");\n    }],\n\n    cmd_EMBED: [false, undefined, undefined, function(args) {\n        this.newUIWindow(\"embeddedWindow\");\n    }],\n\n    cmd_PRIVACYPOLICY: [false, undefined, undefined, function(args) {\n        this.newUIWindow(\"privacyWindow\");\n    }],\n\n    cmd_ABOUT: [false, undefined, undefined, function(args) {\n        this.newUIWindow(\"aboutWindow\");\n    }],\n\n    cmd_QUOTE: [false, 1, 1, function(args) {\n        this.send(args[0]);\n    }],\n\n    cmd_KICK: [true, 2, 1, function(args, channel) {\n        channel = channel || this.getActiveWindow().currentChannel;\n\n        var target = args[0];\n        var message = args.length >= 2 ? args[1] : \"\";\n\n        this.send(\"KICK \" + channel + \" \" + target + \" :\" + message);\n    }],\n\n    automode: function(direction, mode, args, channel) {\n        channel = channel || this.getActiveWindow().currentChannel;\n\n        var modes = direction;\n\n        args.length.times(function() {\n            modes += mode;\n        });\n\n        this.send(\"MODE \" + channel + \" \" + modes + \" \" + args.join(\" \"));\n    },\n\n    cmd_OP: [true, 6, 1, function(args) {\n        this.automode(\"+\", \"o\", args);\n    }],\n    cmd_DEOP: [true, 6, 1, function(args) {\n        this.automode(\"-\", \"o\", args);\n    }],\n    cmd_VOICE: [true, 6, 1, function(args) {\n        this.automode(\"+\", \"v\", args);\n    }],\n    cmd_DEVOICE: [true, 6, 1, function(args) {\n        this.automode(\"-\", \"v\", args);\n    }],\n    cmd_TOPIC: [true, 1, 1, function(args, channel) {\n        this.send(\"TOPIC \" + (channel || this.getActiveWindow().currentChannel) + \" :\" + args[0]);\n    }],\n    cmd_AWAY: [false, 1, 0, function(args) {\n        this.send(\"AWAY :\" + (args ? args[0] : \"\"));\n    }],\n    cmd_QUIT: [false, 1, 0, function(args) {\n        this.send(\"QUIT :\" + (args ? args[0] : \"\"));\n    }],\n    cmd_CYCLE: [true, 1, 0, function(args, channel) {\n        channel = channel || this.getActiveWindow().currentChannel;\n\n        this.send(\"PART \" + channel + \" :\" + (args ? args[0] : \"rejoining. . .\"));\n        this.send(\"JOIN \" + channel);\n    }],\n    cmd_FJOIN: [false, 2, 1, function(args) {\n        if(args.length === 0)\n            return;\n        var channels = args.shift(),\n            formatted = util.formatChannelString(channels);\n\n        if (channels !== formatted) {\n            this.parentObject.writeMessages(lang.poorJoinFormat);\n        }\n        if(formatted)\n            this.send(\"JOIN \" + formatted + \" \" + args.join(\" \"));\n    }],\n    cmd_JOIN: [false, 2, 1, function(args) {\n        var channels = args.shift(),\n            chans = util.splitChans(channels).filter(this.parentObject.canJoinChannel, this.parentObject);\n            // formatted = util.formatChannelString(chans);\n\n            // this.send(\"JOIN \" + formatted + \" \" + args.join(\" \"));\n        this.cmd_FJOIN[3].call(this, $A(util.joinChans(chans)).concat(args));//join channels into a single comma sep string then join\n    }],\n    // cmd_JOIN: [false, 2, 1, function(args) {\n    //     var channels = args.shift();\n\n    //     var chans = util.splitChans(channels).filter(this.parentObject.canJoinChannel, this.parentObject),\n    //         formatted = util.formatChannelString(chans);\n\n    //     if (util.joinChans(chans) !== formatted) {\n    //         this.parentObject.writeMessages(lang.poorJoinFormat);\n    //     }\n    //     if(chans)\n    //         this.send(\"JOIN \" + formatted + \" \" + args.join(\" \"));\n    // }],\n    cmd_UMODE: [false, 1, 0, function(args) {\n        this.send(\"MODE \" + this.parentObject.nickname + (args ? (\" \" + args[0]) : \"\"));\n    }],\n    cmd_BEEP: [false, undefined, undefined, function(args) {\n        this.parentObject.ui.beep();\n    }],\n    cmd_AUTOJOIN: [false, undefined, undefined, function(args) {\n        if(!auth.signedIn) {\n            auth.signedIn = true;\n            return [\"JOIN\", this.parentObject.options.autojoin.join(\",\")];\n        }\n    }],\n    cmd_CLEAR: [false, undefined, undefined, function(args, channel) {\n        var win = channel ? this.parentObject.windows[channel] : this.getActiveWindow().lines;\n        // while (win.childNodes.length > 0){\n        //     win.removeChild(win.firstChild);\n        // }\n        win.empty();\n    }],\n    cmd_PART: [false, 2, 0, function(args) {\n        args = $A(args);\n\n        var msg = args[1] || lang.partChan.message,\n            channel = args[0] || this.getActiveWindow().currentChannel;\n\n        this.send(\"PART \" + channel + \" :\" + msg);\n    }]\n});\n\nirc.commandAliases = {\n    \"J\": \"JOIN\",\n    \"P\": \"PART\",\n    \"K\": \"KICK\",\n    \"MESSAGE\": \"PRIVMSG\",\n    \"M\": \"PRIVMSG\",\n    \"MSG\": \"PRIVMSG\",\n    \"Q\": \"QUERY\",\n    \"BACK\": \"AWAY\",\n    \"PRIVACY\": \"PRIVACYPOLICY\",\n    \"HOP\": \"CYCLE\",\n    \"SLAP\": \"ME\"\n};\n\n\nirc.CommandHistory = new Class({\n    Implements: [Options],\n    options: {\n        lines: 20\n    },\n    initialize: function(options) {\n        this.setOptions(options);\n\n        this.data = [];\n        this.position = 0;\n    },\n    addLine: function(line, moveUp) {\n        if ((this.data.length === 0) || (line !== this.data[0])){\n            this.data.unshift(line);\n        }\n\n        if (moveUp) {\n            this.position = 0;\n        } else {\n            this.position = -1;\n        }\n\n        if (this.data.length > this.options.lines) {\n            this.data.pop();\n        }\n    },\n    upLine: function() {\n        var len = this.data.length;\n        if (len === 0 || this.position >= len)\n            return null;\n\n        this.position += 1;\n        return this.data[this.position];\n    },\n    downLine: function() {\n        this.position -= 1;\n\n        if (this.position <= -1){\n            this.position = -1;\n            return null;\n        }\n\n        return this.data[this.position];\n    }\n});\n\n// //ircclient with added event support\nirc.IRCClient = new Class({\n    Extends: irc.BaseIRCClient,\n    Binds: [\"quit\", \"writeMessages\", \"newTargetOrActiveLine\"],\n    options: {\n        nickname: \"qwebirc\",\n        autojoin: \"\",\n        maxnicks: 10,\n        prefixes: \"@+\", //heirarchy of prefixes - \"@\"(operator), \"+\"(voice)\n        minRejoinTime: [0]\n    },\n    initialize: function(options, ui) {\n        var self = this;\n        self.parent(options);\n\n        self.ui = ui;\n\n        self.prefixes = self.options.prefixes;\n        self.modeprefixes = \"ov\";\n        self.windows = {};\n\n        self.commandparser = new irc.Commands(self);\n        self.exec = self.commandparser.dispatch;\n\n        self.statusWindow = self.ui.newClient(self);\n        self.lastNicks = [];\n\n        self.inviteChanList = [];\n        self.activeTimers = {};\n\n        self.loginRegex = new RegExp(self.ui.options.loginRegex);\n        self.tracker = new irc.IRCTracker(self);\n\n        self.writeMessages(lang.copyright);\n    },\n\n    newLine: function(winID, type, data) {\n        if (!data) data = {};\n\n        var win = this.getWindow(winID);\n        if (win) {\n            win.addLine(type, data);\n        } else {\n            this.statusWindow.addLine(type, data);\n        }\n    },\n\n    newChanLine: function(channel, type, user, extra) {\n        if (!extra) extra = {};\n\n        if ($defined(user)) {\n            extra[\"h\"] = util.hostToHost(user);\n            extra['n'] = util.hostToNick(user);\n\n            if ($defined(extra[\"f\"]) && extra[\"f\"].length > 0) {\n                if (util.isChannel(extra[\"f\"])) {\n                    if (extra[\"f\"] === BROUHAHA) {\n                        extra['f'] = '';\n\n                        var chanName = $('channel-name-id').innerHTML;\n                        if (!util.isChannel(chanName)) {\n                            extra['f'] = '>';\n                        }\n                        extra[\"f\"] = extra['f'] + irc.activeChannel; //hack active chan is on qwebirc.irc object\n                    }\n                    extra[\"n\"] = util.hostToNick(user) + extra[\"f\"];\n                } else {\n                    if (util.hostToNick(user) == this.nickname) {\n                        extra['n'] = this.nickname + '>' + extra['f'];\n                    } else {\n                        extra['n'] = util.hostToNick(user) + '>' + extra['f'];\n                    }\n                }\n            }\n        }\n        extra[\"c\"] = channel;\n        extra[\"-\"] = this.nickname;\n\n        if (!(this.ui.uiOptions.NICK_OV_STATUS))\n            delete extra[\"@\"];\n\n        this.newLine(channel, type, extra);\n    },\n\n    newServerLine: function(type, data) {\n        this.statusWindow.addLine(type, data);\n    },\n\n    newActiveLine: function(type, data) {\n        this.getActiveWindow().addLine(type, data);\n    },\n\n    newTargetOrActiveLine: function(target, type, data) {\n        if (this.getWindow(target)) {\n            this.newLine(target, type, data);\n        } else {\n            this.newActiveLine(type, data);\n        }\n    },\n\n    //you dont even want to know\n    updateNickList: function(channel) {\n        var nickHash = this.tracker.getChannel(channel); //of nickChanEntry\n\n        var names2 = $defined(nickHash) ? Object.keys(nickHash) : []; //just return?\n        var comparitor = util.nickChanComparitor(this, nickHash),\n            prefixer = util.nickPrefixer(nickHash);\n\n        //sorts nicks by status > lexigraphy\n        //then add the prefix in front of the name\n        var sorted = names2.sort(comparitor).map(prefixer);\n\n        var win = this.getWindow(channel);\n        if (win) {\n            win.updateNickList(sorted);\n        }\n    },\n\n    getWindow: function(name) {\n        return this.windows[this.toIRCLower(name)];\n    },\n\n    getActiveWindow: function() {\n        return this.ui.getActiveIRCWindow(this);\n    },\n\n    newWindow: function(name, type, select) {\n        //select\n        var win = this.getWindow(name);\n        if (!win) {\n            win = this.windows[this.toIRCLower(name)] = this.ui.newWindow(this, type, name);\n\n            win.addEvent(\"close\", function(win) {\n                delete this.windows[this.toIRCLower(name)];\n            }.bind(this));\n        }\n\n        if (select) {\n            this.ui.selectWindow(win);\n        }\n        return win;\n    },\n\n    getQueryWindow: function(name) {\n        return this.ui.getWindow(this, ui.WINDOW_QUERY, name);\n    },\n\n    newQueryWindow: function(name, privmsg) {\n        if (!this.getQueryWindow(name))\n            return privmsg ? this.newPrivmsgQueryWindow(name) : this.newNoticeQueryWindow(name);\n    },\n\n    newPrivmsgQueryWindow: function(name) {\n        if (this.ui.uiOptions.DEDICATED_MSG_WINDOW) {\n            if (!this.ui.getWindow(this, ui.WINDOW_MESSAGES))\n                return this.ui.newWindow(this, ui.WINDOW_MESSAGES, \"Messages\");\n        } else {\n            return this.newWindow(name, ui.WINDOW_QUERY, false);\n        }\n    },\n\n    newNoticeQueryWindow: function(name) {\n        if (this.ui.uiOptions.DEDICATED_NOTICE_WINDOW)\n            if (!this.ui.getWindow(this, ui.WINDOW_MESSAGES))\n                return this.ui.newWindow(this, ui.WINDOW_MESSAGES, \"Messages\");\n    },\n\n    newQueryLine: function(win, type, data, privmsg, active) {\n        if (this.getQueryWindow(win))\n            return this.newLine(win, type, data);\n\n        var win = this.ui.getWindow(this, ui.WINDOW_MESSAGES);\n\n        var e;\n        if (privmsg) {\n            e = this.ui.uiOptions.DEDICATED_MSG_WINDOW;\n        } else {\n            e = this.ui.uiOptions.DEDICATED_NOTICE_WINDOW;\n        }\n        if (e && win) {\n            return win.addLine(type, data);\n        } else {\n            return active ? this.newActiveLine(type, data) :\n                            this.newLine(win, type, data);\n        }\n    },\n\n    newQueryOrActiveLine: function(win, type, data, privmsg) {\n        this.newQueryLine(win, type, data, privmsg, true);\n    },\n\n    //writes messages from an array of lang.message items\n    writeMessages: function(messages, args) {\n        var client = this,\n            win = client.getActiveWindow(),\n            types = lang.TYPES;\n\n        function write(message) {\n            var msg = args ? util.formatter(message.message, args) :\n                            message.message; //replaces values like {replaceme} if args has a key like that\n\n            switch (message.type) {\n            case types.SERVER:\n            case types.MISC:\n                return client.newServerLine(\"RAW\", {'m': msg});\n            case types.ERROR:\n                return win.errorMessage(msg);\n            case types.INFO:\n                return win.infoMessage(msg);\n            }\n        }\n\n        if(Array.isArray(messages))\n            messages.each(write);\n        else\n            write(messages);\n    },\n\n    /* from here down are events */\n    rawNumeric: function(numeric, prefix, params) {\n        this.newServerLine(\"RAW\", {\n            \"n\": \"numeric\",\n            \"m\": params.slice(1).join(\" \")\n        });\n    },\n\n    signedOn: function(nickname) {\n        var options = this.options,\n            channels,\n            hash = window.location.hash;\n\n        this.tracker = new irc.IRCTracker(this); //this gets called twice......\n        this.nickname = nickname;\n        // this.newServerLine(\"SIGNON\");\n        this.writeMessages(lang.signOn);\n\n        if (hash.length > 1) {\n            options.autojoin = channels = hash.replace(/&/g, ',#');\n            this.storeChannels(channels);\n        } else {\n            channels = this.getChannels();\n            if (channels.length > 0) {\n                options.autojoin = channels;\n            } else { //if no stored channels join intial channels from interface options\n                options.autojoin = channels = options.initialChannels;\n                this.storeChannels(channels);\n            }\n        }\n        // Sort the autojoin channels.\n        channels = options.autojoin = util.prependChannel(channels, BROUHAHA);\n        this.currentChannel = BROUHAHA;\n\n        if (!auth.authed && auth.enabled) {\n            this.attemptAuth();\n        } else {\n            this.exec(\"/AUTOJOIN\");\n        }\n\n        this.fireEvent(\"logon\", {\n            'nickname': nickname,\n            'channels': channels\n        });\n    },\n\n    //probably a better way\n    attemptAuth: function() {\n        //only try to auth if its necessary\n        if (!auth.authed && auth.enabled) {\n            var test = this.send(\"authserv AUTH \" + this.options.account + \" \" + this.options.password);\n\n            // if the user is authed they will be set to +x... however as most users arent authed...\n            //wait a hundreth of a second to see if the auth server authed you\n            var win = this.ui.getActiveWindow();\n            // (function() {\n            //     win.infoMessage(\"Waiting for login before joining channels...\");\n            // }).delay(200);\n\n            var writer = this.writeMessages;\n            //this.writeMessages(lang.joinAfterAuth);\n            writer.curry(lang.joinAfterAuth).delay(100);\n\n            this.activeTimers.autojoin = (function() {\n                if (!auth.authed) {\n                    writer(lang.authFailed);\n                }\n            }).delay(5000);\n        }\n    },\n\n    authEvent: function() {\n        auth.authed = true;\n        this.exec(\"/UMODE +x\");\n        this.writeMessages(lang.joinChans);\n        if (!auth.signedIn) {\n            this.exec(\"/AUTOJOIN\");\n        }\n\n        this.fireEvent(\"auth\");\n    },\n\n    userJoined: function(user, channel) { //todo determine way to get brouhaha selected at start\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user),\n            wasus = (nick === this.nickname),\n            type = wasus ? \"OURJOIN\" : \"JOIN\",\n            windowSelected = (channel === this.currentChannel);\n\n        if (wasus && !this.getWindow(channel)) {\n            this.newWindow(channel, qwebirc.ui.WINDOW_CHANNEL, windowSelected); //true means channel is selected\n        }\n\n\n        this.tracker.addNickToChannel(nick, BROUHAHA);\n        this.tracker.addNickToChannel(nick, channel);\n        this.updateNickList(BROUHAHA);\n        this.updateNickList(channel);\n\n        //dont display login message if join msgs disabled or window is brouhaha or something\n        if (!(this.ui.uiOptions.HIDE_JOINPARTS || isBaseWindow(channel))) {\n            this.newChanLine(channel, type, user);\n        }\n\n        if (wasus && channel === BROUHAHA) { //initial login. TODO there should be a better way to do this (maybe an option or something)\n            this.writeMessages(lang.loginMessages);\n        }\n\n        this.fireEvent(\"userJoined\", {\n            'user': user,\n            'channel': channel,\n            'thisclient': wasus\n        });\n    },\n\n\n    userPart: function(user, channel, message) {\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user),\n            wasus = (nick === this.nickname);\n\n        if (wasus) {\n            this.tracker.removeChannel(channel);\n            var win = this.getWindow(channel);\n            if (win) {\n                win.close();\n            }\n        } else {\n            this.tracker.removeNickFromChannel(nick, BROUHAHA);\n            this.tracker.removeNickFromChannel(nick, channel);\n            this.updateNickList(BROUHAHA);\n            this.updateNickList(channel);\n\n            //hide disconnects in base windows or if option set\n            if (!(this.ui.uiOptions.HIDE_JOINPARTS || isBaseWindow(channel))) {\n                this.newChanLine(channel, \"PART\", user, {\n                    \"m\": message\n                });\n            }\n        }\n\n        this.fireEvent(\"userPart\", {\n            'user': user,\n            'channel': channel,\n            'message': message,\n            'thisclient': wasus\n        });\n    },\n\n\n    userKicked: function(kicker, channel, kickee, message) {\n        var wasus = kickee === this.nickname;\n        if (wasus) {\n            this.tracker.removeChannel(channel);\n            this.getWindow(channel).close();\n        } else {\n            this.tracker.removeNickFromChannel(kickee, channel);\n            this.updateNickList(channel);\n        }\n\n        this.newChanLine(channel, \"KICK\", kicker, {\n            \"v\": kickee,\n            \"m\": message\n        });\n\n        this.fireEvent(\"userKicked\", {\n            'kicker': kicker,\n            'channel': channel,\n            'kickee': kickee,\n            'message': message,\n            'thisclient': wasus\n        });\n    },\n\n    userPrivmsg: function(user, message) {\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user);\n        this.newQueryWindow(nick, true);\n        this.pushLastNick(nick);\n        this.newQueryLine(nick, \"PRIVMSG\", {\n            \"m\": message,\n            \"h\": host,\n            \"n\": nick\n        }, true);\n\n        this.fireEvent(\"userPrivmsg\", {\n            'user': user,\n            'message': message\n        });\n    },\n\n    userInvite: function(user, channel) {\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user),\n            accept = this.ui.uiOptions.ACCEPT_SERVICE_INVITES && this.isNetworkService(user);\n\n        this.newServerLine(\"INVITE\", {\n            \"c\": channel,\n            \"h\": host,\n            \"n\": nick\n        });\n        if (accept) {\n            if (this.activeTimers.serviceInvite) {\n                $clear(this.activeTimers.serviceInvite);\n            }\n\n            // we do this so we can batch the joins, i.e. instead of sending 5 JOIN comands we send 1 with 5 channels.\n            this.activeTimers.serviceInvite = this.__joinInvited.delay(100, this);\n            this.inviteChanList.push(channel);\n        }\n\n        this.fireEvent(\"userInvite\", {\n            'user': user,\n            'channel': channel,\n            'accept': accept\n        });\n    },\n\n    userNotice: function(user, message) {\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user);\n\n        if (this.ui.uiOptions.DEDICATED_NOTICE_WINDOW) {\n            this.newQueryWindow(nick, false);\n            this.newQueryOrActiveLine(nick, \"PRIVNOTICE\", {\n                \"m\": message,\n                \"h\": host,\n                \"n\": nick\n            }, false);\n        } else {\n            this.newTargetOrActiveLine(nick, \"PRIVNOTICE\", {\n                \"m\": message,\n                \"h\": host,\n                \"n\": nick\n            });\n        }\n\n        this.fireEvent(\"channelTopic\", {\n            'user': user,\n            'message': message\n        });\n    },\n\n    userQuit: function(user, message) {\n        var self = this,\n            nick = util.hostToNick(user),\n            channels = self.tracker.getNick(nick);\n\n        self.tracker.removeNick(nick);\n\n        Object.keys(channels).each(function(chan) {\n            if (!(self.ui.uiOptions.HIDE_JOINPARTS || isBaseWindow(chan))) {\n                self.newChanLine(chan, \"QUIT\", user, {\n                    \"m\": message\n                });\n            }\n            self.updateNickList(chan);\n        });\n\n        self.fireEvent(\"userQuit\", {\n            'user': user,\n            'channels': channels,\n            'message': message\n        });\n    },\n\n    userMode: function(modes) {\n        this.newServerLine(\"UMODE\", {\n            \"m\": modes,\n            \"n\": this.nickname\n        });\n\n        this.fireEvent(\"userMode\", {\n            'modes': modes\n        });\n    },\n\n    nickChanged: function(user, newnick, wasus) {\n        var self = this,\n            oldnick = util.hostToNick(user);\n\n        if (wasus) {\n            self.nickname = newnick;\n            storage.set('nickname', newnick);\n        }\n\n        self.tracker.renameNick(oldnick, newnick);\n\n        var channels = self.tracker.getNick(newnick);\n        var found = Object.getLength(channels) > 0;\n\n        // for (var chan in channels) {\n        //     found = true;\n\n        //     self.newChanLine(chan, \"NICK\", user, {\n        //         \"w\": newnick\n        //     });\n        //     // TODO: rename queries\n        //     self.updateNickList(chan);\n        // }\n        Object.each(channels, function(obj, chan) {\n            self.newChanLine(chan, \"NICK\", user, {\n                \"w\": newnick\n            });\n            // TODO: rename queries\n            self.updateNickList(chan);\n        });\n\n        if (!found) {\n            self.newServerLine(\"NICK\", {\n                \"w\": newnick,\n                n: util.hostToNick(user),\n                h: util.hostToHost(user),\n                \"-\": self.nickname\n            });\n        }\n\n        self.fireEvent(\"nickChange\", {\n            'user': user,\n            'newnick': newnick,\n            'channels': channels,\n            'thisclient': wasus,\n            'client': self\n        });\n    },\n\n    initialTopic: function(channel, topic) {\n        this.getWindow(channel).updateTopic(topic);\n\n        this.fireEvent(\"channelTopic\", {\n            'channel': channel,\n            'topic': topic\n        });\n    },\n\n    channelTopic: function(user, channel, topic) {\n        this.newChanLine(channel, \"TOPIC\", user, {\n            \"m\": topic\n        });\n        this.getWindow(channel).updateTopic(topic);\n\n        this.fireEvent(\"channelTopic\", {\n            'user': user,\n            'channel': channel,\n            'topic': topic\n        });\n    },\n\n    channelPrivmsg: function(user, channel, message) {\n        var self = this,\n            nick = util.hostToNick(user);\n\n        self.tracker.updateLastSpoke(nick, channel, Date.now());\n        self.newChanLine(channel, \"CHANMSG\", user, {\n            \"m\": message,\n            \"@\": self.getNickStatus(channel, nick)\n        });\n\n        self.fireEvent(\"channelMessage\", {\n            'user': user,\n            'channel': channel,\n            'message': message\n        });\n    },\n\n    channelNotice: function(user, channel, message) {\n        this.newChanLine(channel, \"CHANNOTICE\", user, {\n            \"m\": message,\n            \"@\": this.getNickStatus(channel, util.hostToNick(user))\n        });\n\n        this.fireEvent(\"channelNotice\", {\n            'user': user,\n            'channel': channel,\n            'type': type\n        });\n    },\n\n    channelMode: function(user, channel, modes, raw) {\n        modes.each(function(mo) {\n            var self = this,\n                direction = mo[0],\n                mode = mo[1];\n\n            var prefixindex = self.modeprefixes.indexOf(mode);\n            if (prefixindex === -1) return;\n\n            var nick = mo[2],\n                prefixchar = self.prefixes.charAt(prefixindex),\n\n                nc = self.tracker.getOrCreateNickOnChannel(nick, channel),\n                oped = direction === OPED;\n\n            prefixchar = oped ? util.addPrefix(nc, prefixchar, self.prefixes) :\n                                util.removePrefix(nc, prefixchar)\n\n            this.fireEvent(\"mode\", {\n                \"added\": oped,\n                \"prefix\": prefixchar,\n                \"nick\": nick,\n                \"channel\": channel,\n                \"thisclient\": nick === this.nickname,\n                \"nickchan\": nc\n            });\n        }, this);\n\n        this.newChanLine(channel, \"MODE\", user, {\n            \"m\": raw.join(\" \")\n        });\n\n        this.updateNickList(channel);\n    },\n\n    channelCTCP: function(user, channel, type, args) {\n        if (!args) {\n            args = \"\";\n        }\n\n        var nick = util.hostToNick(user);\n        if (type == \"ACTION\") {\n            this.tracker.updateLastSpoke(nick, channel, Date.now());\n            this.newChanLine(channel, \"CHANACTION\", user, {\n                \"m\": args,\n                \"c\": channel,\n                \"@\": this.getNickStatus(channel, nick)\n            });\n            return;\n        }\n\n        this.newChanLine(channel, \"CHANCTCP\", user, {\n            \"x\": type,\n            \"m\": args,\n            \"c\": channel,\n            \"@\": this.getNickStatus(channel, nick)\n        });\n\n        this.fireEvent(\"channelCTCP\", {\n            'user': user,\n            'channel': channel,\n            'type': type,\n            'args': args\n        });\n    },\n\n    userCTCP: function(user, type, args) {\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user);\n\n        if (!args) {\n            args = \"\";\n        }\n\n        if (type == \"ACTION\") {\n            this.newQueryWindow(nick, true);\n            this.newQueryLine(nick, \"PRIVACTION\", {\n                \"m\": args,\n                \"x\": type,\n                \"h\": host,\n                \"n\": nick\n            }, true);\n            return;\n        }\n\n        this.newTargetOrActiveLine(nick, \"PRIVCTCP\", {\n            \"m\": args,\n            \"x\": type,\n            \"h\": host,\n            \"n\": nick,\n            \"-\": this.nickname\n        });\n\n        this.fireEvent(\"userCTCP\", {\n            'user': user,\n            'type': type,\n            'args': args\n        });\n    },\n\n    userCTCPReply: function(user, type, args) {\n        var nick = util.hostToNick(user),\n            host = util.hostToHost(user);\n\n        if (!args) {\n            args = \"\";\n        }\n\n        this.newTargetOrActiveLine(nick, \"CTCPREPLY\", {\n            \"m\": args,\n            \"x\": type,\n            \"h\": host,\n            \"n\": nick,\n            \"-\": this.nickname\n        });\n\n        this.fireEvent(\"userCTCPReply\", {\n            'user': user,\n            'type': type,\n            'args': args\n        });\n    },\n\n    serverNotice: function(user, message) {\n        if (!user) {\n            this.newServerLine(\"SERVERNOTICE\", {\n                \"m\": message\n            });\n        } else {\n            this.newServerLine(\"PRIVNOTICE\", {\n                \"m\": message,\n                \"n\": user\n            });\n        }\n        this.fireEvent(\"serverNotice\", {\n            'user': user,\n            'message': message\n        });\n    },\n\n\n    getNickStatus: function(channel, nick) {\n        var nickchan = this.tracker.getNickOnChannel(nick, channel);\n        if (!$defined(nickchan) || nickchan.prefixes.length === 0)\n            return \"\";\n\n        return nickchan.prefixes.charAt(0);\n    },\n\n    broadcast: function(user, channel, message, from, msgtype) {\n        var nick = util.hostToNick(user);\n\n        this.tracker.updateLastSpoke(nick, channel, Date.now());\n        this.newChanLine(channel, msgtype, user, {\n            \"m\": message,\n            \"@\": this.getNickStatus(channel, nick),\n            \"f\": from\n        });\n    },\n\n    storeChannels: function(channels) {\n        var store = prelude.uniq(channels);\n        this.channels = channels;\n        this.options.channels.set(store);\n    },\n\n    getChannels: function() {\n        var chans = this.channels = this.options.channels.get() || [];\n        // this.channels = chans ? chans.split(\",\") : [];\n        return chans;\n    },\n\n    canJoinChannel: function(chan) {\n        //check if already on channel\n        if(Object.keys(this.windows).contains(this.toIRCLower(chan)))\n            return false;\n        else if(chan === BROUHAHA)\n            return true;\n\n        var chansets = session.get(chan) || [], //oldest -> newest\n            currTime = Date.now(),\n            rejoinT = this.options.minRejoinTime,\n            minTime = Math.max.apply(null, rejoinT.slice(0, chansets.length)) * 1000;//max min applicable time\n        chan = util.formatChannel(chan);\n\n        var broken = chansets.filter(function(time) {\n            return currTime - time <= minTime;\n        });\n\n        if(broken.length === 0) {\n            chansets.push(currTime);\n            var n = (chansets.length - rejoinT.length).limit(0, chansets.length);\n            session.set(chan, chansets.slice(n));\n        } else {\n            var maxTime = Math.max.apply(null, chansets.map(function(time, i) {\n                return ((minTime - (currTime - time))/1000).round(1); //to secs/10\n            }));\n            this.writeMessages(lang.waitToJoin, {channel: chan,\n                                                time: maxTime});\n        }\n\n        return broken.length === 0;\n    },\n\n\n    isNetworkService: function(user) {\n        return this.ui.options.networkServices.contains(user);\n    },\n\n    __joinInvited: function() {\n        this.exec(\"/JOIN \" + this.inviteChanList.join(\",\"));\n        this.inviteChanList = [];\n        delete this.activeTimers[\"serviceInvite\"];\n    },\n\n    channelNames: function(channel, names) {\n        if (names.length === 0) { //occurs on channel join\n            this.updateNickList(channel);\n            return;\n        }\n        var getPrefixes = util.prefixOnNick(this.prefixes);\n        names.each(function(prenick) {\n            //var splitnick = nick.split(\"\");\n            //var hasPrefix = Functional.compose(\">0\".lambda(), String.indexOf.curry(\"+@\"), prelude.item(0));\n            // splitnick.every(function(c, i) {\n            //     if (this.prefixes.indexOf(c) == -1) {\n            //         nick = nick.substr(i);\n            //         return false;\n            //     }\n            //     prefixes.push(c);\n            //     return true;\n            // }, this);\n            var prefixNick = getPrefixes(prenick),\n                prefixes = prefixNick[0],\n                nick = prefixNick[1];\n\n            if (channel !== BROUHAHA) {\n                this.tracker.addNickToChannel(nick, BROUHAHA);\n            }\n            var nc = this.tracker.addNickToChannel(nick, channel);\n\n\n            Array.each(prefixes, function(p) {\n                util.addPrefix(nc, p, this.prefixes);\n            }, this);\n        }, this);\n    },\n\n    disconnected: function(message) {\n        Object.each(this.windows, function(win) {\n            if (util.isChannelType(win.type))\n                win.close();\n        });\n        // for (var wid in this.windows) {\n        //     var win = this.windows[wid];\n        //     if (util.isChannelType(win.type))\n        //         win.close();\n        // }\n        delete this.tracker;\n\n        this.newServerLine(\"DISCONNECT\", {\n            \"m\": message\n        });\n    },\n\n    nickOnChanHasPrefix: function(nick, channel, prefix) {\n        var entry = this.tracker.getNickOnChannel(nick, channel);\n        if (!$defined(entry)) return false; /* shouldn't happen */\n\n        return (entry.prefixes).contains(prefix);\n    },\n\n    nickOnChanHasAtLeastPrefix: function(nick, channel, prefix) {\n        var entry = this.tracker.getNickOnChannel(nick, channel);\n        if (!$defined(entry))\n            return false; /* shouldn't happen */\n\n        /* this array is sorted */\n        var pos = this.prefixes.indexOf(prefix);\n        if (pos === -1)\n            return false; /* shouldn't happen */\n\n        // var modehash = {};\n        // this.prefixes.slice(0, pos + 1).split(\"\").each(function(x) {\n        //     modehash[x] = true;\n        // });\n\n        // var prefixes = entry.prefixes;\n        // for (var i = 0; i < prefixes.length; i++){\n        //     if (modehash[prefixes.charAt(i)])\n        //         return true;\n        // }\n\n        var prefixes = this.prefixes.substring(0, pos + 1);\n\n        //true if any of entry.prefix is part of prefixes string\n        return Array.some(entry.prefixes, function(prefix) {\n            return util.validPrefix(prefixes, prefix);\n        });\n\n        // return false;\n    },\n\n    supported: function(key, value) {\n        if (key == \"PREFIX\") {\n            var len = (value.length - 2) / 2;\n\n            this.modeprefixes = value.substr(1, len);\n            this.prefixes = value.substr(len + 2, len);\n        }\n\n        this.parent(key, value);\n    },\n\n    connected: function() {\n        this.newServerLine(\"CONNECT\");\n    },\n\n    serverError: function(message) {\n        this.newServerLine(\"ERROR\", {\n            \"m\": message\n        });\n    },\n\n    quit: function(message) {\n        this.send(\"QUIT :\" + (message || lang.quit.message), true);\n        this.disconnect();\n    },\n\n    disconnect: function() {\n        // for (var k in this.activeTimers) {\n        //     this.activeTimers[k].cancel();\n        // }\n        Object.each(this.activeTimers, $clear);\n        this.activeTimers = {};\n        this.writeMessages(lang.disconnected);\n\n        this.parent();\n    },\n\n    awayMessage: function(nick, message) {\n        this.newQueryLine(nick, \"AWAY\", {\n            \"n\": nick,\n            \"m\": message\n        }, true);\n    },\n\n    whois: function(nick, type, data) {\n        var ndata = {\n            \"n\": nick\n        };\n        var mtype = type.toUpperCase();\n\n        switch(type.toLowerCase()) {\n            case \"user\":\n                ndata.h = data.ident + \"@\" + data.hostname;\n                this.newTargetOrActiveLine(nick, \"WHOISUSER\", ndata); //whois user\n                mtype = \"REALNAME\";\n                ndata.m = data.realname;\n            break;\n            case \"server\":\n                ndata.x = data.server;\n                ndata.m = data.serverdesc;\n            break;\n            // case \"oper\":\n            // break;\n            case \"channels\":\n                ndata.m = data.channels;\n            break;\n            case \"account\":\n                ndata.m = data.account;\n            break;\n            case \"away\":\n                ndata.m = data.away;\n            break;\n            case \"opername\":\n                ndata.m = data.opername;\n            break;\n            case \"actually\":\n                ndata.m = data.hostname;\n                ndata.x = data.ip;\n            break;\n            case \"generictext\":\n                ndata.m = data.text;\n            break;\n            default:\n                return false;\n        }\n\n        this.newTargetOrActiveLine(nick, \"WHOIS\" + mtype, ndata);;\n        return true;\n    },\n\n    genericError: function(target, message) {\n        this.newTargetOrActiveLine(target, \"GENERICERROR\", {\n            m: message,\n            t: target\n        });\n    },\n\n    genericQueryError: function(target, message) {\n        this.newQueryOrActiveLine(target, \"GENERICERROR\", {\n            m: message,\n            t: target\n        }, true);\n    },\n\n    awayStatus: function(state, message) {\n        this.newActiveLine(\"GENERICMESSAGE\", {\n            m: message\n        });\n    },\n\n    pushLastNick: function(nick) {\n        var i = this.lastNicks.indexOf(nick);\n        if (i != -1) {\n            this.lastNicks.splice(i, 1);\n        } else {\n            if (this.lastNicks.length == this.options.maxnicks) this.lastNicks.pop();\n        }\n        this.lastNicks.unshift(nick);\n    },\n\n    wallops: function(user, text) {\n        var nick = util.hostToNick(user);\n        var host = util.hostToHost(user);\n\n        this.newServerLine(\"WALLOPS\", {\n            t: text,\n            n: nick,\n            h: host\n        });\n    },\n\n    channelModeIs: function(channel, modes) {\n        this.newTargetOrActiveLine(channel, \"CHANNELMODEIS\", {\n            c: channel,\n            m: modes.join(\" \")\n        });\n    },\n\n    channelCreationTime: function(channel, time) {\n        this.newTargetOrActiveLine(channel, \"CHANNELCREATIONTIME\", {\n            c: channel,\n            m: util.IRCDate(new Date(time * 1000))\n        });\n    },\n\n    getPopularChannels: function(cb, minUsers) {\n        this.hidelistout = true;\n        this.exec('/list >' + (minUsers || 75)); //request chans with more than 75 users\n        this.addEvent(\"listend:once\", function() {\n            var chans = this.listedChans.clone().sort(function(a,b){return b.users-a.users});//max -> min sort\n            cb(chans);\n            this.hidelistout = false;\n        })\n    }\n});\n\n/* This could do with a rewrite from scratch. */\n\nirc.IRCConnection = new Class({\n    Implements: [Events, Options],\n    Binds: [\"send\",\"__completeRequest\"],\n    options: {\n        initialNickname: \"ircconnX\",\n        minTimeout: 45000,\n        maxTimeout: 5 * 60000,\n        timeoutIncrement: 10000,\n        initialTimeout: 65000,\n        floodInterval: 200,\n        floodMax: 10,\n        floodReset: 5000,\n        errorAlert: true,\n        maxRetries: 5,\n        password: '',\n        serverPassword: null\n    },\n\n    initialize: function(options) {\n        var self = this;\n        self.setOptions(options);\n        self.counter = 0;\n        self.disconnected = false;\n        self.__floodLastRequest = 0;\n        self.__floodCounter = 0;\n        self.__floodLastFlood = 0;\n        self.__retryAttempts = 0;\n        self.__timeoutId = null;\n        self.__timeout = self.options.initialTimeout;\n        self.__lastActiveRequest = null;\n        self.__activeRequest = null;\n        self.__sendQueue = [];\n        self.__sendQueueActive = false;\n    },\n\n    connect: function() {\n        var self = this,\n            request;\n        self.cacheAvoidance = util.randHexString(16);\n        request = self.newRequest(\"n\");\n\n        request.addEvent(\"complete\", function(stream) {\n            if (!stream) {\n                self.disconnected = true;\n                self.__error(lang.connectionFail);\n                return;\n            }\n            else if (!stream[0]) {\n                self.disconnect();\n                self.__error(lang.connError, stream);\n                return;\n            }\n            self.sessionid = stream[1];\n            self.recv();\n        });\n\n        var postdata = \"nick=\" + encodeURIComponent(self.options.initialNickname);\n        if ($defined(self.options.serverPassword)) {\n            postdata += \"&password=\" + encodeURIComponent(self.options.serverPassword);\n        }\n        request.send(postdata);\n    },\n\n    disconnect: function() {\n        this.disconnected = true;\n        this.__cancelTimeout();\n        this.__cancelRequests();\n    },\n\n    newRequest: function(url, floodProtection, synchronous) {\n        var self = this;\n        //check if request should proceed\n        if (self.disconnected) {\n            return null;\n        } else if (floodProtection && !self.disconnected && self.__isFlooding()) {\n            self.disconnect();\n            self.__error(lang.uncontrolledFlood);\n        }\n        var request = new Request.JSON({\n            url: qwebirc.global.dynamicBaseURL + \"e/\" + url + \"?r=\" + self.cacheAvoidance + \"&t=\" + self.counter++,\n            async: !synchronous\n        });\n\n        // try to minimise the amount of headers \n        request.headers = {};\n\n        //calls forEach on headers to be removed in the context of the request.xhr on readystatechange.\n        //calls setXHRHeaders in the context of the request.xhr object\n        request.addEvent(\"request\", irc.IRCConnection.setXHRHeaders.curry(request.xhr));\n        if (Browser.Engine.trident) {\n            request.setHeader(\"If-Modified-Since\", \"Sat, 1 Jan 2000 00:00:00 GMT\");\n        }\n        return request;\n    },\n\n    recv: function() {\n        var self = this,\n            request = self.newRequest(\"s\", true);\n        if (!$defined(request)) {\n            return;\n        }\n        self.__activeRequest = request;\n        request.__replaced = false;\n        var onComplete = function(stream) {\n            // replaced requests... \n            if (request.__replaced) {\n                self.__lastActiveRequest = null;\n                if (stream) {\n                    self.__processData(stream);\n                }\n                return;\n            }\n            // the main request \n            self.__activeRequest = null;\n            self.__cancelTimeout();\n            if (!stream) {\n                if (!self.disconnected && self.__checkRetries()) {\n                    self.recv();\n                }\n                return;\n            }\n            else if (self.__processData(stream)) {\n                self.recv();\n            }\n        };\n        request.addEvent(\"complete\", onComplete);\n        self.__scheduleTimeout();\n        request.send(\"s=\" + self.sessionid);\n    },\n\n    send: function(data, synchronous) {\n        if (this.disconnected) {\n            return false;\n        }\n        if (synchronous) {\n            this.__send(data, false);\n        } else {\n            this.__sendQueue.push(data);\n            this.__processSendQueue();\n        }\n        return true;\n    },\n\n    __processSendQueue: function() {\n        if (this.__sendQueueActive || this.__sendQueue.length === 0) {\n            return;\n        }\n        this.sendQueueActive = true;\n        this.__send(this.__sendQueue.shift(), true);\n    },\n\n    __send: function(data, async) {\n        var request = this.newRequest(\"p\", false, !async);\n        if (request === null) {\n            return;\n        }\n        request.addEvent(\"complete\", this.__completeRequest.curry(async))\n                .send(\"s=\" + this.sessionid + \"&c=\" + encodeURIComponent(data));\n    },\n\n    __completeRequest: function(async, stream) {\n        if (async) {\n            this.__sendQueueActive = false;\n        }\n        if (!stream || (!stream[0])) {\n            this.__sendQueue = [];\n            if (!this.disconnected) {\n                this.disconnected = true;\n                this.__error(lang.connError, stream);\n            }\n            return false;\n        }\n        this.__processSendQueue();\n    },\n\n    __isFlooding: function() {\n        var t = Date.now(),\n            floodt = t - this.__floodLastRequest;\n        if (floodt < this.options.floodInterval) {\n            if (this.__floodLastFlood !== 0 && (floodt > this.options.floodReset)) {\n                this.__floodCounter = 0;\n            }\n            this.__floodLastFlood = t;\n            if (++this.__floodCounter > this.options.floodMax) {\n                return true;\n            }\n        }\n        this.__floodLastRequest = t;\n        return false;\n    },\n\n    __checkRetries: function() { /* hmm, something went wrong! */\n        if (++this.__retryAttempts > this.options.maxRetries && !this.disconnected) {\n            this.disconnect();\n            this.__error(lang.connTimeOut, {retryAttempts: this.__retryAttempts});\n            return false;\n        }\n        var to = this.__timeout - this.options.timeoutIncrement;\n        if (to >= this.options.minTimeout) {\n            this.__timeout = to;\n        }\n        return true;\n    },\n\n    __cancelRequests: function() {\n        if ($defined(this.__lastActiveRequest)) {\n            this.__lastActiveRequest.cancel();\n            this.__lastActiveRequest = null;\n        }\n        if ($defined(this.__activeRequest)) {\n            this.__activeRequest.cancel();\n            this.__activeRequest = null;\n        }\n    },\n\n    __processData: function(o) {\n        if (o[0] == false) {\n            if (!this.disconnected) {\n                this.disconnected = true;\n                this.__error(lang.connError, o);\n            }\n            return false;\n        }\n\n        this.__retryAttempts = 0;\n        o.each(function(x) {\n            this.fireEvent(\"recv\", [x]);\n        }, this);\n\n        return true;\n    },\n\n\n    __scheduleTimeout: function() {\n        this.__timeoutId = this.__timeoutEvent.delay(this.__timeout, this);\n    },\n\n    __cancelTimeout: function() {\n        if ($defined(this.__timeoutId)) {\n            $clear(this.__timeoutId);\n            this.__timeoutId = null;\n        }\n    },\n\n    __timeoutEvent: function() {\n        this.__timeoutId = null;\n        if (!$defined(this.__activeRequest)) {\n            return;\n        } else if (this.__lastActiveRequest) {\n            this.__lastActiveRequest.cancel();\n        }\n        this.__activeRequest.__replaced = true;\n        this.__lastActiveRequest = this.__activeRequest;\n        var to = this.__timeout + this.options.timeoutIncrement;\n        if (to <= this.options.maxTimeout) {\n            this.__timeout = to;\n        }\n        this.recv();\n    },\n\n    __error: function(message, context) {\n        var msg = message.message;\n        if(context)\n            msg = util.formatter(msg, context);\n\n        this.fireEvent(\"error\", msg);\n        if (this.options.errorAlert) {\n            alert(msg);\n        }\n        console.log('had error:' + msg);\n    }\n});\n\n(function() {\n    var conn = irc.IRCConnection;\n    //moved browser specific headers to be removed here so it doesnt have to be computed each connection.\n    //header nullables are browser dependent\n    //http://www.michael-noll.com/tutorials/cookie-monster-for-xmlhttprequest/\n    var kill = [\"Accept\", \"Accept-Language\"],\n        killBit;\n    if (Browser.Engine.trident) {\n        killBit = \"?\";\n        kill = kill.concat([\"User-Agent\", \"Connection\"]);\n    } else if (Browser.firefox) {\n        killBit = null;\n    } else {\n        killBit = \"\";\n    }\n\n    //removes a header from an xhr object (this instanceof xhr)\n\n    function removeHeaders(header) {\n        try {\n            this.setRequestHeader(header, killBit);\n        } catch (e) {}\n    }\n\n    //iteratres the headers to be removed with the removeHeaders function\n    //expects a xhr object as the third param \n    // conn.setXHRHeaders = function(xhr) {\n    //     kill.each(removeHeaders, xhr);\n    //     //remove cookies from xhr\n    //     // new CookieMonster(xhr);\n    // };\n\n    conn.setXHRHeaders = Array.each.curry(kill, removeHeaders);\n\n    // conn.setXHRHeaders = function(xhr) {\n    //     kill.each(removeHeaders, xhr);\n    // };\n})();\n\n\nirc.IRCTracker = new Class({\n    initialize: function(owner) {\n        this.channels = {};\n        this.nicknames = {};\n        this.owner = owner;\n    },\n\n    toIRCLower: function(value) {\n        /* proxied because the method can change after we connect */\n\n        return this.owner.toIRCLower(value);\n    },\n\n    getNick: function(nick) {\n        return this.nicknames[nick];\n    },\n\n    getOrCreateNick: function(nick) {\n        return this.getNick(nick) || (this.nicknames[nick] = {});\n    },\n\n    getChannel: function(channel) {\n        return this.channels[this.toIRCLower(channel)];\n    },\n\n    getOrCreateChannel: function(channel) {\n        return this.getChannel(channel) || (this.channels[this.toIRCLower(channel)] = {});\n    },\n\n    getOrCreateNickOnChannel: function(nick, channel) {\n        var nc = this.getOrCreateNick(nick);\n\n        return nc[this.toIRCLower(channel)] || this.addNickToChannel(nc, channel);\n    },\n\n    getNickOnChannel: function(nick, channel) {\n        var nickchan = this.getNick(nick);\n        if (!nickchan) {\n            return;\n        } else {\n            return nickchan[this.toIRCLower(channel)];\n        }\n    },\n\n    addNickToChannel: function(nick, channel) {\n        var nc = irc.nickChanEntry();\n\n        var nickchan = this.getOrCreateNick(nick);\n        nickchan[this.toIRCLower(channel)] = nc;\n\n        var chan = this.getOrCreateChannel(channel);\n        chan[nick] = nc;\n\n        return nc;\n    },\n\n    removeNick: function(nick) {\n        var nickchan = this.getNick(nick);\n        if (!nickchan)\n            return;\n\n        Object.keys(nickchan).each(function(chan) {\n            var lchannel = this.toIRCLower(chan),\n                channel = this.channels[lchannel];\n\n            delete channel[nick];\n            if (Object.isEmpty(channel)) {\n                delete this.channels[lchannel];\n            }\n        }, this);\n        delete this.nicknames[nick];\n    },\n\n    removeChannel: function(channel) {\n        var chan = this.getChannel(channel);\n        if (!chan)\n            return;\n\n        var lchannel = this.toIRCLower(channel);\n\n\n        Object.keys(chan).each(function(nick) {\n            var nc = this.nicknames[nick];\n\n            delete nc[lchannel];\n\n            if (Object.isEmpty(nc)) { //in no more channels\n                delete this.nicknames[nick];\n            }\n        }, this);\n        delete this.channels[lchannel];\n    },\n\n    removeNickFromChannel: function(nick, channel) {\n        var lchannel = this.toIRCLower(channel);\n\n        var nickchan = this.getNick(nick);\n        var chan = this.getChannel(lchannel);\n        if (!nickchan || !chan)\n            return;\n\n        delete nickchan[lchannel];\n        delete chan[nick];\n\n        if (Object.isEmpty(nickchan)) {\n            delete this.nicknames[nick];\n        }\n        if (Object.isEmpty(chan)) {\n            delete this.channels[lchannel];\n        }\n    },\n\n    renameNick: function(oldnick, newnick) {\n        var nickchans = this.getNick(oldnick);\n        if (!nickchans)\n            return;\n\n        Object.keys(nickchans).each(function(channel) {\n            var lchannel = this.toIRCLower(channel);\n            this.channels[lchannel][newnick] = this.channels[lchannel][oldnick];\n            delete this.channels[lchannel][oldnick];\n        }, this);\n\n        this.nicknames[newnick] = this.nicknames[oldnick];\n        delete this.nicknames[oldnick];\n    },\n\n    updateLastSpoke: function(nick, channel, time) {\n        var nc = this.getNickOnChannel(nick, channel);\n        if ($defined(nc)) {\n            nc.lastSpoke = time;\n        }\n    },\n\n    getSortedByLastSpoke: function(channel) {\n        var sorter = function(a, b) {\n            return b[1].lastSpoke - a[1].lastSpoke;\n        };\n\n        var chan = this.getChannel(channel);\n        if (!chan)\n            return;\n\n        // var names = [];\n        // Hash.each(chan, function(chan, name) {\n        //     names.push([name, chan]);\n        // });\n        var names = Object.mapA(chan, function(c, n) {\n            return [n, c];\n        });\n\n        var newnames = names.sort(sorter)\n                            .map(prelude.first);\n\n        return newnames;\n    }\n});\n\n\n//http://indiegamr.com/the-state-of-audio-in-html5-games/\n//consider switching to soundjs\n//http://www.createjs.com/Docs/SoundJS/modules/SoundJS.html\n\nsound.SoundPlayer = new Class({\n    Implements: [Options, Events],\n    options: {\n        soundManagersrc: \"//cdnjs.cloudflare.com/ajax/libs/SoundJS/0.4.1/soundjs.min.js\",\n        sounds: \"/sound/\",\n        beepsrc: \"beep.mp3\"\n    },\n    initialize: function(options) {\n        this.setOptions(options);\n        this.loadingSWF = false;\n		this.sm = undefined; //sound manager\n    },\n    load: function() {\n        window.addEvent(\"domready\", function() {\n            this.loadSoundManager();\n        }.bind(this));\n    },\n    loadSoundManager: function() {\n        var self = this,\n			opts = self.options;\n        if (self.loadingSWF !== false)\n            return;\n        self.loadingSWF = true;\n        if ($defined(self.sm)) { //... ugh\n            self.fireEvent(\"ready\");\n            return;\n        }\n\n        var soundinit = function() {\n			//var sm = self.sm = window.soundManager;\n			var sm = self.sm = window.createjs.Sound;\n            sm.url = opts.sounds;\n\n            //load all sounds here\n            self.register(\"beep\", opts.sounds + opts.beepsrc);\n            sm.onLoadComplete = function() {\n                self.fireEvent(\"ready\");\n            };\n            self.loadingSWF = undefined;\n        };\n\n		//load sound manager\n        Asset.javascript(opts.soundManagersrc, {onLoad: soundinit});\n    },\n	register: function(alias,src) {\n		this.sm.registerSound(src, alias);\n		this[alias] = function(complete) {\n			return this.sm.play(alias);\n		}.bind(this);\n	},\n    play: function(src) {\n        this.sm.play(src);\n    }\n});\n\n\n(function (engine) {\n\n    //where to store these things\n    var source = engine.source = engine.source || {},\n        compiled = engine.templates = engine.templates || {};\n\n    //Handlebars.templates.stream({class:'scout',added:[{user:'megawac'},{user:'TKO'}]})\n    //->\n    //\"<li id='tfscout'><span class='tf-class'>scout</span><span class='tf-players'><span>megawac</span><span>TKO</span></span></li>\"\n    // source.stream = [\n    // \"<li id='tf{{class}}'>\",\n    //     \"<span class='tf-class'>{{class}}</span>\",\n    //     \"<span class='tf-players'>\",\n    //     \"{{#each added}}\",\n    //         \"{{> player this}}\",\n    //     \"{{/each}}\",\n    //     \"</span>\",\n    // \"</li>\"\n    // ].join(\"\");\n\n    //Templates.compiled.authpage({nickname:'fred',username:'megawac',password:'secret', full:false}) (full shows all fields)\n    //\"<div id='login'><div><span>Nickname:</span><input type='text' name='basic' id='nickname' value=fred></div><div><span>Auth options</span><input type='checkbox' id='authenticate'></div><div><span>Gamesurge username:</span><input type='text' name='full' id='username' value='megawac'></div><div><span>Password:</span><input type='text' name='full' id='password' value='secret'></div></div>\"\n    source.authpage = [\n    \"<form id='login'>\",\n        //\"<div>\",\n        \"<h1>Connect to {{network}} IRC</h1>\",\n        \"<div class='nick right'><span>Nickname:</span><input type='text' name='basic' id='nickname' value={{nickname}}></div>\",\n        \"<div class='username right {{#unless full}}hidden{{/unless}}'><span>Gamesurge username:</span><input type='text' name='full' id='username' value='{{username}}'></div>\",\n        \"<div class='password right {{#unless full}}hidden{{/unless}}'><span>Password:</span><input type='password' name='full' id='password' value='{{password}}'></div>\",\n        \"<div class='authenticate'>\",\n            \"<span>Authenticate (optional)</span><input type='checkbox' id='authenticate' {{check full}}>\",\n        \"</div>\",\n        \"<div><input type='submit' value='Connect' /></div>\",\n        //\"</div>\",\n    \"</form>\",\n    \"<div class='qwebirc-init-channels'><span>{{channels}}</span></div>\"\n    ].join(\"\");\n\n    source.spanURL = \"<span class='hyperlink-channel'>{{message}}</span>\";\n\n    source.message = \"<div class='message{{pad class}}'><span>{{message}}</span></div>\";\n    source.timestamp = \"<span class='timestamp'>{{time}} </span>\";\n    source.userlink = \"<span class='hyperlink-whois' data-user='{{userid}}'>&lt;{{username}}&gt;</span>\";\n    source.channellink = \"<span class='hyperlink-channel' data-chan='{{channel}}'>{{channel}}</span>\";\n\n    source.messageLine = \"<hr class='lastpos' />\";\n    source.ircMessage = \"<div class='{{styles}}'></div>\";\n\n\n    //portions:\n    source.topPane = \"<div class='qui toppanel outertabbar'></div>\";\n    source.detachedPane = \"<div class='detached'></div>\";\n    source.windowsPane = \"<div class='windows qui'></div>\";\n    source.windowPane = \"<div class='window qui hidden'></div>\";\n    source.topicPane = \"<div class='qui topic'></div>\";\n    source.contentPane = \"<div class='qui content'></div>\";\n    source.leftPane = \"<div class='qui leftpanel lines'></div>\";\n    source.nickPane = \"<div class='qui rightpanel'></div>\";\n    source.propertiesPane = \"<div class='qui properties'></div>\";\n    source.inputPane = \"<div class='qui bottompanel'></div>\";\n\n    source.detachedWindow = [\n    \"<div class='detached-window'>\",\n        \"<div class='header'>\",\n            \"<span class='title'>{{channel}}</span>\",\n            \"{{#unless base}}{{> tabClose}}{{/unless}}\",//css bug\n            \"{{> tabAttach}}\",\n        \"</div>\",\n    \"</div>\"].join(\"\");\n\n    source.resizeHandle = \"<div><span class='resize-handle ui-icon ui-icon-grip-diagonal-se'></span></div>\";\n\n    source.menuContainer = \"<div class='menu'></div>\";\n    source.menubtn = \"<div class='dropdown-tab'><img src='{{icon}}' title='menu' alt='menu'></div>\";\n    source.menudrop = \"<div class='main-menu dropdownmenu'></div>\";\n    source.chanmenu = \"<div class='chanmenu dropdownmenu'>{{#each channels}}{{> menuitem}}{{/each}}</div>\";\n    source.menuitem = \"<a{{#if value}} data-value='{{value}}'{{/if}}><span>{{text}}</span>{{#if hint}}<span class='hint'>{{hint}}</span>{{/if}}</a>\";\n    source.dropdownhint = \"<div class='dropdownhint'>Click the icon for the main menu.</div>\";\n\n    source.tabbar = \"<div class='tabbar'></div>\";\n    source.tabbarbtns = [\n    \"<div class='tab-buttons'>\",\n        \"<span class='ui-icon ui-icon-circle-triangle-w to-left hidden' name='tabscroll'></span>\",\n        \"<span class='ui-icon ui-icon-circle-triangle-e to-right hidden' name='tabscroll'></span>\",\n        \"<span class='add-chan ui-icon ui-icon-circle-plus' title='Join a channel'></span>\",\n    \"</div>\"].join(\"\");\n    source.ircTab = \"<a href='#' class='tab'>{{{name}}} {{> tabDetach}}</a>\";\n    source.tabDetach = \"<span class='detach ui-icon ui-icon-newwin' title='\" + lang.detachWindow + \"'></span>\";\n    source.tabAttach = \"<span class='attach ui-icon ui-icon-circle-minus'></span>\";\n    source.tabClose = \"<span class='tab-close ui-icon ui-icon-circle-close' title='\" + lang.closeTab + \"'></span>\";\n\n    source.channelName = \"<div id='channel-name-id' class='channel-name'>{{{channel}}}</div>\";\n\n    source.topicBar = [\"<div class='topic tab-invisible qui colourline'>\",\n                            \"{{#if topic}}{{> topicText}}{{else}}&nbsp;{{/if}}\",\n                        \"</div>\"].join(\"\");\n    source.topicText = \"<span class='{{#if empty}}emptytopic{{/if}}'>{{topic}}</span>\";\n\n    source.nickbtn = \"<a href='#' class='user'><span>{{nick}}</span></a>\";\n    // source.nicklist = \"<div class='nicklist tab-invisible qwebirc-qui'></div>\";\n\n    source.favicon = \"<link rel='shortcut icon' type='image/x-icon' href='{{link}}'>\";\n\n    source.ircInput = [\n    \"<form class='input'><div>\",\n        \"<label class='nickname'><span class='status {{status}}'></span>{{nick}}</label>\",\n        \"<input class='{{type}} input-field' type='text'>\",\n        \"<input class='input-button' type='button' value='>' />\",\n    \"</div></form>\"].join(\"\");\n\n\n    source.verticalDivider = \"<div class='ui-icon ui-icon-grip-solid-vertical handle vertical'></div>\";\n    source.horizontalDivider = \"<div class='ui-icon ui-icon-grip-solid-horizontal handle horizontal'></div>\";\n\n    /************************\n        HELPERS\n    ***********************/\n    //invert boolean helper\n    engine.registerHelper('not', prelude.negate);\n\n    //returns hidden class name if it should be hidden\n    engine.registerHelper('hidden', function(hidden) {\n        return hidden ? 'hidden' : '';\n    });\n\n    engine.registerHelper('check', function(checked){\n        return checked ? 'checked' : '';\n    });\n\n    engine.registerHelper('pad', function(txt) {\n        return txt && txt.length !== 0 ? ' ' + txt : '';\n    });\n\n    //https://github.com/wycats/handlebars.js/issues/304\n    // engine.registerHelper('chain', function () {\n    //     var helpers = [], value;\n    //     $each(arguments,function (arg, i) {\n    //         if (engine.helpers[arg]) {\n    //             helpers.push(engine.helpers[arg]);\n    //         } else {\n    //             value = arg;\n    //             $each(helpers, function (helper, j) {\n    //                 value = helper(value, arguments[i + 1]);\n    //             });\n    //             return false;\n    //         }\n    //     });\n    //     return value;\n    // });\n\n    /******************\n        Compiliation\n    *********************/\n\n    function compileAll(source,compiled) {\n        compiled = compiled || {};\n\n        Object.each(source, function(item, key) {\n            try {\n                compiled[key] = engine.compile(item);\n            } catch(err) {\n                console.log(err);\n            }\n        });\n\n        return compiled;\n    }\n\n    compileAll(source, compiled);\n\n    //allows templates to reference eachother\n    engine.partials = compiled;\n})(Handlebars);\n\nvar templates = par.Handlebars.templates;\n\n\nui.BaseUI = new Class({\n    Implements: [Events],\n    initialize: function(parentElement, windowClass, uiName, options) {\n        var self = this;\n        self.options = options;\n\n        self.windows = {};\n        self.clients = {};\n        self.windows[ui.CUSTOM_CLIENT] = {};\n        self.windowArray = [];\n        self.windowClass = windowClass;\n        self.parentElement = parentElement;\n        self.parentElement.addClass(\"qwebirc\");\n        self.parentElement.addClass(\"qwebirc-\" + uiName);\n        self.commandhistory = new irc.CommandHistory();\n        self.clientId = 0;\n\n        self.windowFocused = true;\n\n        if (Browser.Engine.trident) {\n            var checkFocus = function() {\n                    var hasFocus = document.hasFocus();\n                    if (hasFocus !== self.windowFocused) {\n                        self.windowFocused = hasFocus;\n                        self.focusChange(hasFocus);\n                    }\n                };\n\n            checkFocus.periodical(100, self);\n        } else {\n            var blur = function() {\n                    if (self.windowFocused) {\n                        self.windowFocused = false;\n                        self.focusChange(false);\n                    }\n                },\n                focus = function() {\n                    if (!self.windowFocused) {\n                        self.windowFocused = true;\n                        self.focusChange(true);\n                    }\n                };\n\n            /* firefox requires both */\n\n            document.addEvent(\"blur\", blur);\n            window.addEvent(\"blur\", blur);\n            document.addEvent(\"focus\", focus);\n            window.addEvent(\"focus\", focus);\n        }\n    },\n    newClient: function(client) {\n        client.id = this.clientId++;\n        // client.hilightController = new ui.HilightController(client);\n\n        this.windows[client.id] = {};\n        this.clients[client.id] = client;\n        var win = this.newWindow(client, ui.WINDOW_STATUS, STATUS);\n        this.selectWindow(win);\n\n        client.addEvent(\"nickChange\", this.nickChange);\n\n        return win;\n    },\n    getClientId: function(client) {\n        return client === ui.CUSTOM_CLIENT ? ui.CUSTOM_CLIENT : client.id;\n    },\n    getWindowIdentifier: function(client, type, name) {\n        if (type === ui.WINDOW_MESSAGES)\n            return \"-M\";\n        else if (type === ui.WINDOW_STATUS)\n            return \"\";\n        else if (client === ui.CUSTOM_CLIENT)\n            return \"_\" + name;\n        else\n            return \"_\" + client.toIRCLower(name);\n    },\n    newWindow: function(client, type, name) {\n        var win = this.getWindow(client, type, name);\n        if ($defined(win))\n            return win;\n\n        var wId = this.getWindowIdentifier(client, type, name);\n        win = this.windows[this.getClientId(client)][wId] = new this.windowClass(this, client, type, name, wId);\n        this.windowArray.push(win);\n\n        return win;\n    },\n    nickChange: $empty,\n\n    getWindow: function(client, type, name) {\n        var wins = this.windows[this.getClientId(client)];\n        if (!$defined(wins))\n            return null;\n\n        return wins[this.getWindowIdentifier(client, type, name)];\n    },\n    getActiveWindow: function() {\n        return this.active;\n    },\n    getActiveIRCWindow: function(client) {\n        if (!this.active || this.active.type == ui.WINDOW_CUSTOM) {\n            return this.windows[this.getClientId(client)][this.getWindowIdentifier(client, ui.WINDOW_STATUS)];\n        } else {\n            return this.active;\n        }\n    },\n    __setActiveWindow: function(win) {\n        this.active = win;\n    },\n    selectWindow: function(win) {\n        if (this.active)\n            this.active.deselect();\n        win.select();\n        this.updateTitle(win.name + \" - \" + this.options.appTitle);\n    },\n    nextWindow: function(direction, fromWin) {\n        var windows = this.windowArray,\n            win = windows.next(windows.indexOf(fromWin || this.active), direction); //get window from array\n        this.selectWindow(win);\n\n        return win;\n    },\n    prevWindow: function() {\n        this.nextWindow(-1);\n    },\n    __closed: function(win) {\n        var winarr = this.windowArray;\n        if (win.active) {\n            // this.active = undefined;\n            if (winarr.length === 1) {\n                winarr.empty();\n            } else {\n                var index = winarr.indexOf(win);\n                if(index === -1) {\n                    return;\n                } else if (index === (winarr.length - 1)) {\n                    this.prevWindow();\n                } else {\n                    this.nextWindow();\n                }\n            }\n        }\n\n        winarr = this.windowArray.erase(win);\n        delete this.windows[this.getClientId(win.client)][win.identifier];\n    },\n/*\n      this shouldn't be called by overriding classes!\n      they should implement their own!\n      some form of user input MUST be received before an\n      IRC connection is made, else users are going to get\n      tricked into getting themselves glined\n    */\n    loginBox: function(callback, initialNickname, initialChannels, autoConnect, autoNick, storage) {\n        ui.GenericLoginBox(this.parentElement, callback, initialNickname, initialChannels, autoConnect, autoNick, this.options.networkName, storage);\n    },\n    focusChange: function(newValue) {\n        var win = this.getActiveWindow();\n        if ($defined(win))\n            win.focusChange(newValue);\n    }\n});\n\n\nui.StandardUI = new Class({\n    Extends: ui.BaseUI,\n    Binds: [\"__handleHotkey\", \"optionsWindow\", \"embeddedWindow\", \"urlDispatcher\", \"resetTabComplete\", \"whoisURL\"],\n\n    UICommands: ui.UI_COMMANDS,\n    initialize: function(parentElement, windowClass, uiName, options) {\n        this.parent(parentElement, windowClass, uiName, options);\n\n        this.tabCompleter = new ui.TabCompleterFactory(this);\n        this.uiOptions = new ui.DefaultOptionsClass(this, options.uiOptionsArg);\n        this.customWindows = {};\n\n        this.__styleValues = {\n            hue: this.uiOptions.STYLE_HUE,\n            saturation: 0,\n            lightness: 0\n        };\n        if ($defined(this.options.hue))\n            this.__styleValues.hue = this.options.hue;\n        if ($defined(this.options.saturation))\n            this.__styleValues.saturation = this.options.saturation;\n        if ($defined(this.options.lightness))\n            this.__styleValues.lightness = this.options.lightness;\n\n        var ev;\n        if (Browser.Engine.trident) {\n            ev = \"keydown\";\n        } else {\n            ev = \"keypress\";\n        }\n        document.addEvent(ev, this.__handleHotkey);\n    },\n    __handleHotkey: function(x) {\n        if (!x.alt || x.control) {\n            if (x.key === \"backspace\" || x.key === \"/\")\n                if (!this.getInputFocused(x))\n                    x.stop();\n            return;\n        }\n        var success = false;\n        if (x.key.match(/a/i)) {\n            var highestNum = 0;\n            var highestIndex = -1;\n            success = true;\n\n            x.stop();\n            //good place for foldr no?\n            this.windowArray.each(function(win, indx){\n                var h = win.hilighted;\n                if (h > highestNum) {\n                    highestIndex = indx;\n                    highestNum = h;\n                }\n            });\n            if (highestIndex !== -1)\n                this.selectWindow(this.windowArray[highestIndex]);\n        } else if (prelude.isNumber(x.key)) { /*x.key >= '0' && x.key <= '9'*/\n            success = true;\n\n            //number = x.key - '0'; //ridiculously stupid\n            number = (Number.toInt(x.key) || 10) - 1;\n\n            if (number >= this.windowArray.length)\n                return;\n\n            this.selectWindow(this.windowArray[number]);\n        } else if (x.key == \"left\") {\n            this.prevWindow();\n            success = true;\n        } else if (x.key == \"right\") {\n            this.nextWindow();\n            success = true;\n        }\n        if (success)\n            x.stop();\n    },\n    getInputFocused: function(x) {\n        //wtf? (x.target.TYPE ==\"INPUT\") or something work?\n        var focused = !($$(\"input\").contains(x.target) && $$(\"textarea\").contains(x.target));\n        return focused;\n    },\n    newCustomWindow: function(name, select, type) {\n        if (!type)\n            type = ui.WINDOW_CUSTOM;\n\n        var win = this.newWindow(ui.CUSTOM_CLIENT, type, name);\n        win.addEvent(\"close\", function(win) {\n            delete this.windows[ui.CUSTOM_CLIENT][win.identifier];\n        }.bind(this));\n\n        if (select)\n            this.selectWindow(win);\n\n        return win;\n    },\n    addCustomWindow: function(windowName, class_, cssClass, options) {\n        if (!$defined(options))\n            options = {};\n\n        if (this.customWindows[windowName]) {\n            this.selectWindow(this.customWindows[windowName]);\n            return;\n        }\n\n        var win = this.newCustomWindow(windowName, true);\n        this.customWindows[windowName] = win;\n\n        win.addEvent(\"close\", function() {\n            this.customWindows[windowName] = null;\n        }.bind(this));\n\n        if (cssClass)\n            win.lines.addClass(\"qwebirc-\" + cssClass);\n\n        var ew = new class_(win.lines, options);\n        ew.addEvent(\"close\", win.close/*.bind(win)*/); //already bound\n\n        win.setSubWindow(ew);\n    },\n    embeddedWindow: function() {\n        this.addCustomWindow(\"Add webchat to your site\", ui.EmbedWizard, \"embeddedwizard\", {\n            baseURL: this.options.baseURL,\n            uiOptions: this.uiOptions,\n            optionsCallback: this.optionsWindow\n        });\n    },\n    optionsWindow: function() {\n        this.addCustomWindow(\"Options\", ui.OptionsPane, \"optionspane\", this.uiOptions);\n    },\n    aboutWindow: function() {\n        this.addCustomWindow(\"About\", ui.AboutPane, \"aboutpane\", this.uiOptions);\n    },\n    privacyWindow: function() {\n        this.addCustomWindow(\"Privacy policy\", ui.PrivacyPolicyPane, \"privacypolicypane\", this.uiOptions);\n    },\n    feedbackWindow: function() {\n        this.addCustomWindow(\"Feedback\", ui.FeedbackPane, \"feedbackpane\", this.uiOptions);\n    },\n    faqWindow: function() {\n        this.addCustomWindow(\"FAQ\", ui.FAQPane, \"faqpane\", this.uiOptions);\n    },\n    urlDispatcher: function(name, window) {\n        if (name == \"embedded\") {\n            return [\"a\", this.embeddedWindow];\n        }\n        else if (name == \"options\"){\n            return [\"a\", this.optionsWindow];\n        }\n        /* doesn't really belong here */\n        else if (name === \"whois\") {\n            var uiOptions = this.uiOptions;\n            ///this method is dumb\n            return [\"span\", function(nick) {\n                if (uiOptions.QUERY_ON_NICK_CLICK) {\n                    window.client.exec(\"/QUERY \" + nick);\n                } else {\n                    if (isChannel(nick)) {\n                        nick = util.unformatChannel(nick);\n                    } else {\n                        if (nick.search(window.client.nickname + '>') >= 0) {\n                            nick = nick.substr(nick.search('>') + 1, nick.length);\n                        } else {\n                            nick = nick.substr(0, nick.search('>'));\n                        }\n                    }\n                    // window.properties.text(nick);\n                    window.client.exec(\"/WHOIS \" + nick);\n                }\n            }];\n        }\n        else\n            return null;\n    },\n\n    whoisURL: function(e, target) {\n        var client = target.getParent('.lines').retrieve('client'),\n            nick = target.get('data-user');\n        if (this.uiOptions.QUERY_ON_NICK_CLICK) {\n            client.exec(\"/QUERY \" + nick);\n        } else {\n            if (isChannel(nick)) {\n                nick = util.unformatChannel(nick);\n            } else if (nick.search(client.nickname + '>') >= 0) {\n                nick = nick.substr(nick.search('>') + 1, nick.length);\n            } \n            client.exec(\"/WHOIS \" + nick);\n        }\n    },\n\n    chanURL: function(e, target) {\n        var client = target.getParent('.lines').retrieve('client'),\n            chan = target.get('data-chan');\n        if(util.isChannel(chan))\n            client.exec(\"/JOIN \" + chan);\n    },\n\n    tabComplete: function(element) {\n        this.tabCompleter.tabComplete(element);\n    },\n    resetTabComplete: function() {\n        this.tabCompleter.reset();\n    },\n    setModifiableStylesheet: function(name) {\n        this.__styleSheet = new ui.style.ModifiableStylesheet(this.options.modifiableStylesheet);\n        this.setModifiableStylesheetValues({});\n    },\n    setModifiableStylesheetValues: function(values) {\n        // for (var k in values)\n        //     this.__styleValues[k] = values[k];\n        $extend(this.__styleValues, values);\n\n        if (!$defined(this.__styleSheet))\n            return;\n\n        var hue = this.__styleValues.hue,\n            lightness = this.__styleValues.lightness,\n            saturation = this.__styleValues.saturation,\n            uiOptions = this.uiOptions;\n\n        this.__styleSheet.set(function(mode, col) {\n            if (mode == \"c\") {\n                var x = new Color(col);\n                var c = x.setHue(hue).setSaturation(x.hsb[1] + saturation).setBrightness(x.hsb[2] + lightness);\n                if (c == \"255,255,255\") // IE confuses white with transparent... \n                c = \"255,255,254\";\n\n                return \"rgb(\" + c + \")\";\n            } else if (mode == \"o\") {\n                return uiOptions[arguments[1]] ? arguments[2] : arguments[3];\n            }\n        });\n    }\n});\n\n\n\nui.NotificationUI = new Class({\n    Extends: ui.StandardUI,\n\n    Binds: [\"beep\"],\n\n    options: {\n        minSoundRepeatInterval: 1000\n    },\n    initialize: function(/*parentElement, windowClass, uiName, options*/) {\n        // this.parent(parentElement, windowClass, uiName, options);\n        this.parent.apply(this, arguments);\n\n\n        if (this.uiOptions.BEEP_ON_MENTION) {\n            this.lastSound = 0;\n            this.soundReady = false;\n            this.soundInit();\n        }\n\n\n        var flasher = this.__flasher = new ui.Flasher(this.uiOptions);\n\n        this.flash = flasher.flash;\n        this.cancelFlash = flasher.cancelFlash;\n    },\n    setBeepOnMention: function(value) {\n        if (value)\n            this.soundInit();\n    },\n    updateTitle: function(text) {\n        if (this.__flasher.updateTitle(text))\n            ui.setTitle(text);\n    },\n    focusChange: function(value) {\n        this.parent(value);\n        this.__flasher.focusChange(value);\n    },\n    beep: function() {\n        this.playSound('beep');\n    },\n    playSound: function(alias) {\n        if (this.soundReady && this.uiOptions.BEEP_ON_MENTION && \n                (Date.now() - this.lastSound > this.options.sounds.minSoundRepeatInterval)) {\n            this.soundPlayer[alias]();\n            this.lastSound = Date.now();\n        }\n    },\n\n    soundInit: function() {\n        var self = this;\n\n        //used to have a bunch of flash checks. going to let the sm handle it\n        if($defined(self.soundPlayer)) {\n            return;\n        }\n\n        self.soundPlayer = new sound.SoundPlayer(self.options.sounds);\n        self.soundPlayer.addEvent(\"ready\", function() {\n            self.soundReady = true;\n        });\n\n        self.soundPlayer.load();\n    }\n});\n\nui.Flasher = new Class({\n    Binds: [\"flash\", \"cancelFlash\"],\n\n    initialize: function(uiOptions) {\n        this.uiOptions = uiOptions;\n\n        this.windowFocused = false;\n        this.canUpdateTitle = true;\n        this.titleText = document.title;\n\n        var favIcon = document.head.getElement(\"link[rel^='shortcut'][rel$='icon']\");\n        if ($defined(favIcon)) {\n            this.favIcon = favIcon;\n            this.favIconParent = favIcon.parentNode;\n            this.favIconVisible = true;\n\n            // this.emptyFavIcon = new Element(\"link\");\n            // this.emptyFavIcon.rel = \"shortcut icon\";\n            // this.emptyFavIcon.href = qwebirc.global.staticBaseURL + \"images/empty_favicon.ico\";\n            // this.emptyFavIcon.type = \"image/x-icon\";\n            this.emptyFavIcon = Element.from(templates.favicon({link: uiOptions.ui.options.icons.empty_favicon}));\n\n            this.flashing = false;\n\n            this.canFlash = true;\n            var cancel = this.cancelFlash;\n            document.addEvent(\"mousedown\", cancel);\n            document.addEvent(\"keydown\", cancel);\n        } else {\n            this.canFlash = false;\n        }\n    },\n    flash: function() {\n        var self = this;\n        if (!self.uiOptions.FLASH_ON_MENTION || self.windowFocused || !self.canFlash || self.flashing)\n            return;\n\n        self.titleText = document.title; /* just in case */\n\n        var flash = function() {\n            var vis = self.toggleFavIcon();\n            self.canUpdateTitle = vis;\n            ui.setTitle(vis ? self.titleText : lang.activityNotice.message);\n        };\n\n        //http://mootools.net/forge/p/tab_alert\n        // var ex3 = yourInstance = new tabAlert({\n        //         text: lang.activityNotice.message,\n        //         ticker: true,\n        //         onLoop: flash\n        //     });\n\n        self.flashing = true;\n        // flashA();\n        self.flasher = flash.periodical(750);\n    },\n    cancelFlash: function() {\n        if (!this.canFlash || !$defined(this.flasher))\n            return;\n\n        this.flashing = false;\n\n        $clear(this.flasher);\n        this.flasher = undefined;\n\n        this.toggleFavIcon(true);\n        ui.setTitle(this.titleText);\n        this.canUpdateTitle = true;\n    },\n    //not sure if changing the favicon is a good idea - messes with peoples bookmarks\n    toggleFavIcon: function(state) {\n        var vis = $defined(state) ? state : !this.favIconVisible;\n        if(vis){\n            if (!this.favIconVisible) {\n                this.favIcon.replaces(this.emptyFavIcon);\n            }\n        }\n        else{\n            if (this.favIconVisible) {\n                this.emptyFavIcon.replaces(this.favIcon);\n            }\n        }\n        this.favIconVisible = vis;\n        return vis;\n    },\n    updateTitle: function(text) {\n        this.titleText = text;\n        return this.canUpdateTitle;\n    },\n    focusChange: function(value) {\n        this.windowFocused = value;\n\n        if (value)\n            this.cancelFlash();\n    }\n});\n\n\nui.NewLoginUI = new Class({\n    Extends: ui.NotificationUI,\n    loginBox: function(callbackfn, initialNickname, initialChannels, autoConnect, autoNick, network, storage) {\n        this.postInitialize();\n\n        var win = this.newCustomWindow(CONNECTION_DETAILS, true, ui.WINDOW_CONNECT);\n        var callback = function() {\n                win.close();\n                callbackfn.apply(this, arguments);\n            };\n        ui.GenericLoginBox(win.lines, callback, initialNickname, initialChannels, autoConnect, autoNick, network || this.options.networkName, storage);\n    }\n});\n\nui.GenericLoginBox = function(parentElement, callback, initialNickname, initialChannels, autoConnect, autoNick, networkName, storage) {\n    if (autoConnect) {\n        ui.ConfirmBox(parentElement, callback, initialNickname, initialChannels, autoNick, networkName,storage);\n    } else {\n        ui.LoginBox(parentElement, callback, initialNickname, initialChannels, networkName,storage);\n    }\n};\n\nui.LoginBox = function(parentElement, callback, initialNickname, initialChannels, networkName, cookies) {\n\n    // var outerbox = new Element(\"div\");\n    // outerbox.addClass('tf-middle');\n    // parentElement.appendChild(outerbox);\n\n    parentElement.addClass('qui-center');\n    var content = new Element('div');\n    parentElement.appendChild(content);\n\n    var nickname = cookies.nick.get() || initialNickname,\n        account = util.B64.decode(cookies.user.get()),\n        password = util.B64.decode(cookies.pass.get()),\n        eauth = auth.enabled || cookies.auth.get();\n\n    var context = {\n        'network':networkName,\n        'nickname':nickname,\n        'username':account,\n        'password':password,\n        'full': eauth, //whether to show the extra auth options (check the checkbox)\n        'channels': initialChannels.join()\n    };\n    content.html(templates.authpage(context));\n\n    var nickBox = content.getElementById('nickname'),\n        usernameBox = content.getElementById('username'),\n        passwordBox = content.getElementById('password'),\n        chkAddAuth = content.getElementById('authenticate'),\n        form = content.getElementById('login');\n\n\n    function toggleFull () {\n        form.getElements('[name=\"full\"]').getParent('div').toggle();\n    }\n\n    chkAddAuth.addEvent('click', toggleFull);\n\n    form.addEvent(\"submit\", function(e) {\n        e.stop();\n\n        var nickname = nickBox.value;\n\n        //validate nick\n        if (!nickname) {\n            alert(lang.missingNick);\n            nickBox.focus();\n            return;\n        }\n        var stripped = qwebirc.global.nicknameValidator.validate(nickname);\n        if (stripped !== nickname) {\n            nickBox.value = stripped;\n            alert(lang.invalidNick);\n            nickBox.focus();\n            return;\n        }\n\n        var data = {\n            \"nickname\": nickname\n        };\n\n        cookies.nick.set(nickname);\n\n\n        if (chkAddAuth.checked || auth.enabled) {//disabled\n            // we're valid - good to go\n            data.account = account = usernameBox.value;\n            data.password = password = passwordBox.value;\n            if (auth.bouncerAuth()) {\n                if (!password) {\n                    alert(lang.missingPass.message);\n                    passwordBox.focus();\n                    return;\n                }\n\n                data.serverPassword = password;\n            }\n            if (!account || !password) {\n                alert(lang.missingAuthInfo.message);\n                if (!usernameBox.value) {\n                    usernameBox.focus();\n                } else {\n                    passwordBox.focus();\n                }\n                return;\n            } else {\n                if(auth.passAuth()){\n                    data.serverPassword = account + \" \" + password;\n                }\n\n            }\n\n            cookies.user.set(util.B64.encode(account));\n            cookies.pass.set(util.B64.encode(password));\n            cookies.auth.set(true);\n            auth.enabled = true;\n        } else {\n            cookies.auth.dispose();\n        }\n\n\n        parentElement.empty();\n\n        auth.loggedin = true;\n        callback.call(this,data);\n    }.bind(this));\n\n    // nickBox.set(\"value\", initialNickname);\n    //chan.set(\"value\", initialChannels);\n\n    if (window === window.top)\n        nickBox.focus();\n};\n\n\n//todo clean this up - not currently implemented\nui.ConfirmBox = function(parentElement, callback, initialNickname, initialChannels, autoNick, networkName) {\n    var outerbox = new Element(\"table\");\n    outerbox.addClass(\"qwebirc-centrebox\");\n    parentElement.appendChild(outerbox);\n    var tbody = new Element(\"tbody\");\n    outerbox.appendChild(tbody);\n    var tr = new Element(\"tr\");\n    tbody.appendChild(tr);\n    var td = new Element(\"td\");\n    tr.appendChild(td);\n\n    var box = new Element(\"table\");\n    box.addClass(\"qwebirc-confirmbox\");\n    td.appendChild(box);\n\n    var tbody = new Element(\"tbody\");\n    box.appendChild(tbody);\n\n    var tr = new Element(\"tr\");\n    tbody.appendChild(tr);\n    tr.addClass(\"tr1\");\n\n    var text = new Element(\"td\");\n    tr.appendChild(text);\n\n    var nick = new Element(\"b\");\n    nick.set(\"text\", initialNickname);\n\n    var c = initialChannels.split(\" \")[0].split(\",\");\n\n    text.appendChild(document.createTextNode(\"To connect to \" + networkName + \" IRC and join channel\" + ((c.length > 1) ? \"s\" : \"\") + \" \"));\n\n    for (var i = 0; i < c.length; i++) {\n        if ((c.length > 1) && (i == c.length - 1)) {\n            text.appendChild(document.createTextNode(\" and \"));\n        } else if (i > 0) {\n            text.appendChild(document.createTextNode(\", \"));\n        }\n        text.appendChild(new Element(\"b\").set(\"text\", c[i]));\n\n    }\n\n    if (!autoNick) {\n        text.appendChild(document.createTextNode(\" as \"));\n        text.appendChild(nick);\n    }\n\n    text.appendChild(document.createTextNode(\" click 'Connect'.\"));\n    text.appendChild(new Element(\"br\"));\n    if (auth.enabled && auth.quakeNetAuth() && !auth.loggedin)\n        text.appendChild(document.createTextNode(\"If you'd like to connect using your Q auth click 'Log in'.\"));\n\n    var tr = new Element(\"tr\");\n    tbody.appendChild(tr);\n    tr.addClass(\"tr2\");\n\n    var td = new Element(\"td\");\n    tr.appendChild(td);\n\n    var yes = new Element(\"input\", {\n        \"type\": \"submit\",\n        \"value\": \"Connect\"\n    });\n    td.appendChild(yes);\n    yes.addEvent(\"click\", function(e) {\n        parentElement.removeChild(outerbox);\n        callback({\n            \"nickname\": initialNickname,\n            \"autojoin\": initialChannels\n        });\n    });\n\n    if (auth.enabled && auth.quakeNetAuth() && !auth.loggedin) {\n        var auth = new Element(\"input\", {\n            \"type\": \"submit\",\n            \"value\": \"Log in\"\n        });\n        td.appendChild(auth);\n        auth.addEvent(\"click\", ui.AuthLogin);\n    }\n\n    if (window == window.top)\n        yes.focus();\n}\n\nui.authShowHide = function(checkbox, authRow, usernameBox, usernameRow, passwordRow) {\n    var visible = checkbox.checked;\n    var display = visible ? null : \"none\";\n    usernameRow.setStyle(\"display\", display);\n    passwordRow.setStyle(\"display\", display);\n\n    if (visible) {\n        //    authRow.parentNode.setStyle(\"display\", \"none\");\n        usernameBox.focus();\n    }\n}\n\n\n\nui.QuakeNetUI = new Class({\n    Extends: ui.NewLoginUI,\n    urlDispatcher: function(name, window) {\n        if (name == \"qwhois\") {\n            return [\"span\", function(auth) {\n                this.client.exec(\"/MSG Q whois #\" + auth);\n            }.bind(window)];\n        }\n        return this.parent(name, window);\n    },\n    logout: function() {\n        if (!auth.loggedin)\n            return;\n        if (confirm(\"Log out?\")) {\n            Object.each(this.clients, function(client) {\n                client.quit(lang.logOut.message);\n            });\n\n            (function() {\n                document.location = qwebirc.global.dynamicBaseURL + \"auth?logout=1\";\n            }).delay(500);\n        }\n    }\n});\n\n\nui.QUI = new Class({\n    Extends: ui.QuakeNetUI,\n    Binds: [\"__createChannelMenu\"],\n    initialize: function(parentElement, theme, options) {\n        this.parent(parentElement, ui.QUI.Window, \"qui\", options);\n\n        parentElement.addClass('qui')\n                    .addClass('signed-out');\n        this.theme = theme;\n        this.parentElement = parentElement;\n        this.setModifiableStylesheet(\"qui\");\n        this.setHotKeys();\n\n\n        this.parentElement.addEvents({\n            \"click:relay(.lines .hyperlink-whois)\": this.whoisURL,\n            \"click:relay(.lines .hyperlink-channel)\": this.chanURL\n        });\n    },\n    postInitialize: function() {\n        var self = this,\n            qjsui = self.qjsui = new ui.QUI.JSUI(\"qui\", self.parentElement);\n\n        // qjsui.addEvent(\"reflow\", function() {\n        //     var win = self.getActiveWindow();\n        //     if ($defined(win))\n        //         win.onResize();\n        // });\n\n        self.outerTabs = qjsui.top;\n        var tabs = self.tabs = Element.from(templates.tabbar()),\n            joinChan =  function(){\n                var chan = prompt(\"Enter channel name:\");\n                if(chan.trim() !== \"\"){\n                    Object.each(self.clients, function(client) {\n                        client.exec(\"/JOIN \" + chan);\n                    });\n                }\n            },\n            tabbtns = Element.from(templates.tabbarbtns()),\n            addTab = tabbtns.getElement('.add-chan'),\n            scrollers = tabbtns.getElements('[name=\"tabscroll\"]'),\n            scroller = new Fx.Scroll(tabs),\n            resizeTabs = util.fillContainer.curry(tabs, 'max-width'),\n            onResize = function() {\n                var wid = tabs.getWidth(),\n                    swid = tabs.getScrollWidth();\n\n                if(swid > wid) {\n                    scrollers.show();\n                }\n                else {\n                    scrollers.hide();\n                }\n\n                resizeTabs();\n            };\n\n        window.addEvent('resize', onResize);\n        tabs.addEvents({\n            'adopt': onResize,\n            'disown': onResize\n        });\n\n        scrollers.filter('.to-left')\n            .addEvent('click', function(e) {\n                e.stop();\n                var pos = tabs.getScrollLeft(),\n                    $ele = util.elementAtScrollPos(tabs, pos);\n\n                scroller.toElement($ele, 'x');\n                console.log($ele);\n            });\n        scrollers.filter('.to-right')\n            .addEvent('click', function(e) {\n                e.stop();\n                var pos = tabs.getScrollLeft() + tabs.getWidth(),\n                    $ele = util.elementAtScrollPos(tabs, pos);\n\n                scroller.toElementEdge($ele, 'x');\n                console.log($ele);\n            });\n\n        resizeTabs();\n        addTab.addEvents({\n            'dblclick': joinChan,\n            'click': self.__createChannelMenu\n        });\n\n        //for scrolling tabs with mousewheel\n        tabs.addEvent(\"mousewheel\", function(event) {\n            event.stop();\n            /* up */\n            if (event.wheel > 0) {\n                self.nextWindow();\n            } else if (event.wheel < 0) { /* down */\n                self.prevWindow();\n            }\n        });\n\n\n        //append menu and tabbar\n        self.outerTabs.adopt(self.__createDropdownMenu(), tabs, tabbtns);\n\n        var origWin = qjsui.createWindow();\n        self.origtopic = self.topic = origWin.topic;\n        self.origlines = self.lines = origWin.middle;\n        self.orignicklist = self.nicklist = origWin.right;\n\n        self.input = origWin.bottom;\n        // self.reflow = qjsui.reflow.bind(qjsui);\n\n        // self.reflow(origWin);\n        // self.reflow.delay(100, self, origWin); /* Konqueror fix */\n\n\n        //For window resizing\n        // window.addEvent(\"resize\", function() {\n        //     self.getActiveWindow().reflow(100);\n        // });\n\n\n        //delay for style recalc\n        self.__createDropdownHint.delay(500, self);\n    },\n    __createDropdownMenu: function() {\n        var self = this,\n\n            dropdownMenu = Element.from(templates.menudrop());\n        dropdownMenu.inject(self.parentElement);\n\n        var dropdown = Element.from(templates.menubtn({icon: self.options.icons.menuicon}));\n        dropdown.setStyle(\"opacity\", 1);\n\n\n        self.UICommands.each(function(cmd) {\n            var text = cmd[0];\n            var fn = self[cmd[1] + \"Window\"].bind(self);\n            var ele = Element.from(templates.menuitem({text:text}));\n            ele.addEvent(\"click\", function(e) {\n                    dropdownMenu.hideMenu();\n                    fn();\n                });\n            dropdownMenu.appendChild(ele);\n        });\n\n        // var dropdown = new Element(\"div\");\n        // dropdown.addClass(\"dropdown-tab\");\n        // dropdown.appendChild(new Element(\"img\", {\n        //     src: qwebirc.global.staticBaseURL + \"images/icon.png\",\n        //     title: \"menu\",\n        //     alt: \"menu\"\n        // }));\n\n        var dropdownEffect = new Fx.Tween(dropdown, {\n            duration: \"long\",\n            property: \"opacity\",\n            link: \"chain\"\n        });\n\n        dropdownEffect.start(0.25)\n                    .start(1)\n                    .start(0.33)\n                    .start(1);\n\n        ui.decorateDropdown(dropdown,dropdownMenu, {\n            onShow: function() {\n                if(self.hideHint)\n                    self.hideHint();\n                delete self.hideHint;\n            }\n        });\n        return dropdown;\n    },\n\n    setHotKeys: function (argument) {\n        var events = storage.get('hotkeys');\n        console.log('todo');\n        if(keys && events) {\n            keys.activate();\n        }\n    },\n\n    //the effect on page load\n    __createDropdownHint: function() {\n        var dropdownhint = Element.from(templates.dropdownhint());\n        dropdownhint.inject(this.parentElement)\n                    .position({\n                        relativeTo: this.outerTabs,\n                        position: {'y': 'bottom'},\n                        offset: {y:10}\n                    });\n\n        new Fx.Morph(dropdownhint, {\n            duration: \"normal\",\n            transition: Fx.Transitions.Sine.easeOut\n        }).start({\n            left: [900, 5]\n        });\n\n        var hider = function() {\n                new Fx.Morph(dropdownhint, {\n                    duration: \"long\"\n                }).start({\n                    left: [5, -900]\n                });\n            }.delay(4000);\n\n        var hider2 = this.hideHint = Element.destroy.curry(dropdownhint);\n\n        hider2.delay(4000);\n\n        document.addEvents({\n                \"mousedown\": hider2,\n                \"keydown\": hider2\n            });\n    },\n\n    //todo use other dropdown menu code\n    __createChannelMenu: function() {\n        var self = this,\n            client = self.getActiveIRCWindow().client;\n\n        client.getPopularChannels(function(chans) {\n            chans = chans.slice(0, (self.options.maxChansMenu || 10))\n                        .map(function(chan) {\n                            return {\n                                text: chan.channel,\n                                value: chan.channel,\n                                hint: chan.users\n                            };\n                        });\n            var menu = Element.from(templates.chanmenu({\n                    channels: chans\n                })),\n                btn = self.outerTabs.getElement('.add-chan'),\n                btnmenu = btn.retrieve('menu');\n\n            if(btnmenu) {\n                menu.replaces(btnmenu);\n            }\n            else {\n                var wrapper = new Element('div').inject(self.parentElement).adopt(menu);\n                ui.decorateDropdown(btn, wrapper);\n                wrapper.addEvent(\"click:relay(a)\", function(e, target) {\n                    var chan = target.get('data-value');\n                    client.exec(\"/JOIN \" + chan);\n                });\n            }\n            btn.store('menu', menu);\n\n            menu.parentElement.showMenu();\n        });\n    },\n\n    newClient: function(client) {\n        this.parentElement.swapClass('signed-out','signed-in');\n        return this.parent(client);\n    },\n\n    // setLines: function(lines) {\n    //     this.lines.parentNode.replaceChild(lines, this.lines);\n    //     this.qjsui.middle = this.lines = lines;\n    // },\n    // setChannelItems: function(nicklist, topic) {\n    //     if (!$defined(nicklist)) {\n    //         nicklist = this.orignicklist;\n    //         topic = this.origtopic;\n    //     }\n    //     nicklist.replaces(this.nicklist);\n    //     this.qjsui.right = this.nicklist = nicklist;\n\n    //     topic.replaces(this.topic);\n\n    //     this.qjsui.topic = this.topic = topic;\n    // }\n    setWindow: function(win) {\n        this.qjsui.setWindow(win);\n    },\n\n    //called in context of irc client\n    nickChange: function(data) {\n        if(data.thisclient) {\n            Object.each(this.windows, function(win) {\n                win.$nicklabel.set(\"text\", data.newnick);\n            });\n        }\n    }\n});\n\nui.QUI.JSUI = new Class({\n    Implements: [Events],\n    initialize: function(class_, parent, sizer) {\n        this.parent = parent;\n        this.windows = [];\n\n        this.sizer = $defined(sizer) ? sizer : parent;\n\n        this.class_ = class_;\n        this.create();\n\n        // this.reflowevent = null;\n    },\n    // applyClasses: function(pos, el) {\n    //     el.addClass(\"dynamicpanel\")\n    //         .addClass(this.class_);\n\n    //     switch(pos) {\n    //         case \"middle\":\n    //             el.addClass(\"leftboundpanel\");\n    //             break;\n    //         case \"top\":\n    //             el.addClass(\"topboundpanel\")\n    //                 .addClass(\"widepanel\");\n    //             break;\n    //         case \"right\":\n    //             el.addClass(\"rightboundpanel\");\n    //             break;\n    //         case \"topic\":\n    //             el.addClass(\"widepanel\");\n    //             break;\n    //         case \"bottom\":\n    //             el.addClass(\"bottomboundpanel\")\n    //                 .addClass(\"widepanel\");\n    //             break;\n    //     }\n    // },\n    create: function() {\n        // var XE = function(pos) {\n        //         var element = new Element(\"div\");\n        //         this.applyClasses(pos, element);\n\n        //         this.parent.appendChild(element);\n        //         return element;\n        //     }.bind(this);\n\n        // this.top = XE(\"top\");\n        // this.topic = XE(\"topic\");\n        // this.middle = XE(\"middle\");\n        // this.right = XE(\"right\");\n        // this.properties = XE(\"properties\");\n        // this.bottom = XE(\"bottom\");\n\n        var top = this.top = Element.from(templates.topPane()),\n            windows = this.winContainer = Element.from(templates.windowsPane()),\n            detach = this.detachContainer = Element.from(templates.detachedPane());\n        this.parent.adopt(top, windows, detach);\n    },\n\n    createWindow: function() {\n        var win = {\n            'window': Element.from(templates.windowPane()),\n            'topic': Element.from(templates.topicPane()),\n            'content': Element.from(templates.contentPane()),\n            'middle': Element.from(templates.leftPane()),\n            'right': Element.from(templates.nickPane()),\n            'properties': Element.from(templates.propertiesPane()),\n            'bottom': Element.from(templates.inputPane())\n        };\n\n        win.content.adopt(win.middle, win.right);\n        win.window.adopt(win.topic, win.content, win.properties, win.bottom);\n        this.winContainer.appendChild(win.window);\n        this.windows.push(win);\n\n        return win;\n    },\n\n    reflow: function(win, delay) {\n        console.log('dummy');\n        // if (!delay)\n        //     delay = 1;\n\n        // if (this.reflowevent)\n        //     $clear(this.reflowevent);\n        // this.__reflow(win);\n        // this.reflowevent = this.__reflow.delay(delay, this, win);\n    },\n    __reflow: function(win) {\n        // var properties = win.properties,\n        //     bottom = win.bottom,\n        //     middle = win.middle,\n        //     right = win.right,\n        //     topic = win.topic,\n        //     top = this.top,\n\n        //     topicsize = topic.getSize(),\n        //     topsize = top.getSize(),\n        //     rightsize = right.getSize(),\n        //     bottomsize = bottom.getSize(),\n        //     docsize = this.sizer.getSize();\n\n        // var mheight = (docsize.y - topsize.y - bottomsize.y - topicsize.y),\n        //     mwidth = (docsize.x - rightsize.x);\n\n        // topic.setStyle(\"top\", topsize.y);\n\n        // var last5_height = 0;\n        // var last5msg = $('last5messages');\n        // if (last5msg) {\n        //     last5msg.className = \"qwebirc-qui ircwindow dynamicpanel lines\";\n        //     last5msg.style.top = topsize.y + topicsize.y + 'px';\n        //     last5msg.style.width = mwidth + 'px';\n        //     last5msg.style.zIndex = '1';\n        //     last5msg.style.borderBottom = '1px dashed #C8D1DB';\n        //     last5_height = last5msg.offsetHeight;\n        //     middle.setStyle(\"top\", (topsize.y + topicsize.y + last5msg.offsetHeight));\n        // } else {\n        //     middle.setStyle(\"top\", (topsize.y + topicsize.y));\n        // }\n\n        // if (mheight > 0) {\n        //     middle.setStyle(\"height\", mheight - 25 - last5_height);\n        //     right.setStyle(\"height\", mheight);\n        // }\n\n        // if (mwidth > 0) {\n        //     middle.setStyle(\"width\", mwidth);\n        //     properties.setStyle(\"width\", mwidth);\n        // }\n        // right.setStyle(\"top\", (topsize.y + topicsize.y))\n        //     .setStyle(\"left\", mwidth);\n\n        // properties.setStyle(\"top\", (docsize.y - bottomsize.y - 25));\n        // bottom.setStyle(\"top\", (docsize.y - bottomsize.y));\n        // this.fireEvent(\"reflow\", win);\n    },\n    // showChannel: function(win, state, nicklistVisible) {\n    //     // var display = state ? \"block\" : \"none\";\n    //     // this.right.setStyle(\"display\", nicklistVisible ? display : \"none\");\n    //     // this.topic.setStyle(\"display\", display);\n    //     win.right.toggle(state && nicklistVisible);\n    //     win.topic.toggle(state);\n    // },\n    // showInput: function(win, state) {\n    //     // this.bottom.setStyle(\"display\", state ? \"block\" : \"none\");\n    //     win.bottom.isVisible = state;\n    //     win.bottom.toggle(state);\n    // }\n    setWindow: function(newWin) {\n        this.windows.each(function (win) {\n            if(win.detached !== true) {\n                win.window.hide();\n            }\n        });\n        newWin.window.show();\n    }\n});\n\n\n// hacky... todo simplify\nui.Colourise = function(line, entity, execfn, cmdfn, win) {\n    var fg;\n    var bg;\n    var underline = false;\n    var bold = false;\n    var autoNickColour = false;\n\n    var out = [];\n    var xline = line.split(\"\");\n    var element = new Element(\"span\");\n\n    entity.addClass(\"colourline\");\n\n    function parseColours(xline, i) {\n        if(isNaN(xline[i + 1])) {\n            fg = undefined;\n            bg = undefined;\n            return i;\n        }\n        i++;\n        if(prelude.isNumber(xline[i + 1])) {\n            fg = parseInt(xline[i] + xline[i + 1]);\n            i++;\n        } else {\n            fg = parseInt(xline[i]);\n        }\n        if(xline[i + 1] != \",\")\n            return i;\n        else if(isNaN(xline[i + 2]))\n            return i;\n        i+=2;\n\n        if(prelude.isNumber(xline[i + 1])) {\n            bg = parseInt(xline[i] + xline[i + 1]);\n            i++;\n        } else {\n            bg = parseInt(xline[i]);\n        }\n        return i;\n    }\n\n    function emitEndToken() {\n        var data = \"\";\n        if (out.length > 0) {\n            data = ui.urlificate(element, out.join(\"\"), execfn, cmdfn, win);\n            entity.appendChild(element);\n            out.empty();\n        }\n        element = document.createElement(\"span\"); //?\n        return data;\n    }\n\n    function emitStartToken() {\n        if(autoNickColour)\n            return element;\n\n        var classes = \"\";\n        if(fg !== undefined)\n            classes = concatSpace(classes, \"Xc\" + fg); //text colour\n        if(bg !== undefined)\n            classes = concatSpace(classes, \"Xbc\" + bg); //background\n        if(bold)\n            classes = concatSpace(classes, \"Xb\"); //style\n        if(underline)\n            classes = concatSpace(classes, \"Xu\");\n        element.className = classes;\n        // element.className = classes.join(\" \");\n  }\n\n    var nickColouring = win.parentObject.uiOptions.NICK_COLOURS; /* HACK */\n    var capturingNick = false;\n\n    //evil confusing loop\n    for (var i = 0; i < xline.length; i++) {\n        var lc = xline[i];\n\n        if (nickColouring) {\n            if (!capturingNick) {\n                if (lc == \"\\x00\") {\n                    capturingNick = true;\n                    emitEndToken();\n                    continue;\n                }\n            } else {\n                if (lc != \"\\x00\") {\n                    out.push(lc);\n                } else {\n                    autoNickColour = true;\n                    var e = emitStartToken();\n                    var text = emitEndToken();\n\n                    var c = util.toHSBColour(text, win.client);\n                    if ($defined(c)) e.style.color = c.rgbToHex();\n                    capturingNick = autoNickColour = false;\n                }\n                continue;\n            }\n        } else if (lc == \"\\x00\") {\n            continue;\n        }\n\n        if (lc == \"\\x02\") {\n            emitEndToken();\n\n            bold = !bold;\n\n            emitStartToken();\n        } else if (lc == \"\\x1F\") {\n            emitEndToken();\n\n            underline = !underline;\n\n            emitStartToken();\n        } else if (lc == \"\\x0F\") {\n            emitEndToken();\n\n            fg = undefined;\n            bg = undefined;\n            underline = false;\n            bold = false;\n        } else if (lc == \"\\x03\") {\n            emitEndToken();\n\n            i = parseColours(xline, i);\n            if (bg > 15) bg = undefined;\n            if (fg > 15) fg = undefined;\n\n            emitStartToken();\n        } else {\n            out.push(lc);\n        }\n    }\n\n    emitEndToken();\n};\n\n\nui.AboutPane = new Class({\n    Implements: [Events],\n    initialize: function(parent) {\n        var delayfn = function() {\n            //parent.set(\"html\", \"<div class=\\\"loading\\\">Loading. . .</div>\");\n            parent.set(\"html\", templates.message(Object.clone(lang.loadingPage, {'class': 'loading'})));\n        };\n        var cb = delayfn.delay(500);\n\n        var r = ui.RequestTransformHTML({\n            url: qwebirc.global.staticBaseURL + \"panes/about.html\",\n            update: parent,\n            onSuccess: function() {\n                $clear(cb);\n                parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                    this.fireEvent(\"close\");\n                }.bind(this));\n                parent.getElement(\"div[class=version]\").set(\"text\", \"v\" + qwebirc.VERSION);\n            }.bind(this)\n        });\n        r.get();\n    }\n});\n\nui.PrivacyPolicyPane = new Class({\n    Implements: [Events],\n    initialize: function(parent) {\n        var delayfn = function() {\n            //parent.set(\"html\", \"<div class=\\\"loading\\\">Loading. . .</div>\");\n            parent.set(\"html\", templates.message(Object.clone(lang.loadingPage, {'class': 'loading'})));\n        };\n        var cb = delayfn.delay(500);\n\n        var r = ui.RequestTransformHTML({\n            url: qwebirc.global.staticBaseURL + \"panes/privacypolicy.html\",\n            update: parent,\n            onSuccess: function() {\n                $clear(cb);\n\n                parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                    this.fireEvent(\"close\");\n                }.bind(this));\n            }.bind(this)\n        });\n        r.get();\n    }\n});\n\nui.FeedbackPane = new Class({\n    Implements: [Events],\n    initialize: function(parent) {\n        this.textboxVisible = false;\n        var delayfn = function() {\n            //parent.set(\"html\", \"<div class=\\\"loading\\\">Loading. . .</div>\");\n            parent.set(\"html\", templates.message(Object.clone(lang.loadingPage, {'class': 'loading'})));\n        };\n        var cb = delayfn.delay(500);\n\n        this.addEvent(\"select\", this.onSelect);\n\n        var r = ui.RequestTransformHTML({\n            url: qwebirc.global.staticBaseURL + \"panes/feedback.html\",\n            update: parent,\n            onSuccess: function() {\n                $clear(cb);\n                parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                    this.fireEvent(\"close\");\n                }.bind(this));\n                parent.getElement(\"input[class=close2]\").addEvent(\"click\", function() {\n                    this.fireEvent(\"close\");\n                }.bind(this));\n\n                var textbox = parent.getElement(\"textarea\");\n                this.textbox = textbox;\n                parent.getElement(\"input[class=submitfeedback]\").addEvent(\"click\", function() {\n                    this.sendFeedback(parent, textbox, textbox.value);\n                }.bind(this));\n\n                this.textboxVisible = true;\n                this.onSelect();\n            }.bind(this)\n        });\n        r.get();\n    },\n    onSelect: function() {\n        if (this.textboxVisible)\n            this.textbox.focus();\n    },\n    sendFeedback: function(parent, textbox, text) {\n        text = text.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n        var mainText = parent.getElement(\"p[class=maintext]\");\n\n        if (text.length < 25) {\n            /* TODO: lie and throw away */\n            mainText.set(\"text\", \"I don't suppose you could enter a little bit more? Thanks!\");\n            textbox.focus();\n            return;\n        }\n\n        this.textboxVisible = false;\n        var mainBody = parent.getElement(\"div[class=enterarea]\");\n        mainBody.setStyle(\"display\", \"none\");\n\n        var messageBody = parent.getElement(\"div[class=messagearea]\");\n        var messageText = parent.getElement(\"p[class=messagetext]\");\n        var messageClose = parent.getElement(\"input[class=close2]\");\n\n        messageText.set(\"text\", lang.submittingPage.message);\n        messageBody.setStyle(\"display\", \"\");\n\n        /* basic checksum to stop really lame kiddies spamming */\n        var checksum = 0;\n        var esctext = encodeURIComponent(text);\n        for (var i = 0; i < text.length; i++)\n            checksum = ((checksum + 1) % 256) ^ (text.charCodeAt(i) % 256);\n\n        var r = new Request({\n            url: qwebirc.global.dynamicBaseURL + \"feedback\",\n            onSuccess: function() {\n                messageText.set(\"text\", \"Submitted successfully, thanks for the feedback!\");\n                messageClose.setStyle(\"display\", \"\");\n            },\n            onFailure: function() {\n                this.textboxVisible = true;\n                messageBody.setStyle(\"display\", \"none\");\n                mainBody.setStyle(\"display\", \"\");\n                mainText.set(\"text\", \"Looks like something went wrong submitting :(\");\n            }.bind(this)\n        }).send(\"feedback=\" + text + \"&c=\" + checksum);\n    }\n});\n\nui.FAQPane = new Class({\n    Implements: [Events],\n    initialize: function(parent) {\n        var delayfn = function() {\n            //parent.set(\"html\", \"<div class=\\\"loading\\\">Loading. . .</div>\");\n            parent.set(\"html\", templates.message(Object.clone(lang.loadingPage, {'class': 'loading'})));\n        };\n        var cb = delayfn.delay(500);\n\n        var r = ui.RequestTransformHTML({\n            url: qwebirc.global.staticBaseURL + \"panes/faq.html\",\n            update: parent,\n            onSuccess: function() {\n                $clear(cb);\n                parent.getElement(\"input[class=close]\").addEvent(\"click\", function() {\n                    this.fireEvent(\"close\");\n                }.bind(this));\n            }.bind(this)\n        });\n        r.get();\n    }\n});\n\n\n\n/* NEEDS converting to plain HTML! */\nui.EmbedWizardStep = new Class({\n    Implements: [Options, Events],\n    options: {\n        \"title\": \"\",\n        \"first\": \"\",\n        \"hint\": \"\",\n        \"middle\": null,\n        \"premove\": null,\n        \"example\": \"\"\n    },\n    initialize: function(parent, options) {\n        this.setOptions(options);\n        this.parent = parent;\n    },\n    show: function() {\n        this.parent.title.set(\"html\", this.options.title);\n        this.parent.firstRow.set(\"html\", this.options.first);\n        this.parent.hint.set(\"html\", this.options.hint);\n        this.parent.example.set(\"text\", this.options.example);\n\n        while (this.parent.middleRow.childNodes.length > 0)\n        this.parent.middleRow.removeChild(this.parent.middleRow.childNodes[0]);\n\n        if ($defined(this.options.middle))\n            this.parent.middleRow.appendChild(this.options.middle);\n\n        this.fireEvent(\"show\");\n    }\n});\n\nui.EmbedWizard = new Class({\n    Implements: [Options, Events],\n    options: {\n        uiOptions: null,\n        optionsCallback: null,\n        baseURL: \"http://webchat.quakenet.org/\"\n    },\n    initialize: function(parent, options) {\n        /* for some unknown reason setOptions doesn't work... */\n        this.options.uiOptions = options.uiOptions;\n        this.options.baseURL = options.baseURL;\n        this.options.optionsCallback = options.optionsCallback;\n        this.create(parent);\n        this.addSteps();\n    },\n    create: function(parent) {\n        this.t = parent;\n\n        var titleRow = this.newRow();\n        this.title = new Element(\"h2\");\n        this.title.setStyle(\"margin-top\", \"0px\");\n        this.title.setStyle(\"margin-bottom\", \"5px\");\n        titleRow.appendChild(this.title);\n\n        this.firstRow = this.newRow();\n        this.middleRow = this.newRow();\n        var hintRow = this.newRow();\n        this.hint = new Element(\"div\");\n        this.hint.setStyle(\"font-size\", \"0.8em\");\n        this.hint.setStyle(\"font-style\", \"italic\");\n        hintRow.appendChild(this.hint);\n        var exampleRow = this.newRow();\n        this.example = new Element(\"pre\");\n        exampleRow.appendChild(this.example);\n\n        var nextRow = this.newRow();\n        nextRow.addClass(\"wizardcontrols\");\n        var backBtn = new Element(\"input\");\n        backBtn.type = \"submit\";\n        backBtn.value = \"< Back\";\n        backBtn.addEvent(\"click\", this.back.bind(this));\n        nextRow.appendChild(backBtn);\n\n        var nextBtn = new Element(\"input\");\n        nextBtn.type = \"submit\";\n        nextBtn.value = \"Next >\";\n        nextRow.appendChild(nextBtn);\n        nextBtn.addEvent(\"click\", this.next.bind(this));\n\n        this.nextBtn = nextBtn;\n        this.backBtn = backBtn;\n    },\n    newRow: function() {\n        var cell = new Element(\"div\");\n        this.t.appendChild(cell);\n        return cell;\n    },\n    newStep: function(options) {\n        return new ui.EmbedWizardStep(this, options);\n    },\n    newRadio: function(parent, text, name, selected) {\n        var p = new Element(\"div\");\n        parent.appendChild(p);\n\n        var id = util.generateID();\n        var r = util.createInput(\"radio\", p, name, selected, id);\n\n        var label = new Element(\"label\", {\n            \"for\": id\n        });\n        label.appendChild(document.createTextNode(text));\n        p.appendChild(label);\n\n        return r;\n    },\n    addSteps: function() {\n        var af = function(select) {\n            if (Browser.Engine.trident) {\n                var f = function() {\n                    this.focus();\n                    if (select)\n                        this.select();\n                };\n                f.delay(100, this, []);\n            } else {\n                this.focus();\n                this.select();\n            }\n        };\n\n        this.welcome = this.newStep({\n            \"title\": \"Add webchat to your website\",\n            \"first\": \"This wizard will help you create an embedded client by asking you questions then giving you the code to add to your website.<br/><br/>You can use the <b>Next</b> and <b>Back</b> buttons to navigate through the wizard; click <b>Next</b> to continue.\"\n        });\n\n        this.chanBox = new Element(\"input\");\n        this.chanBox.addClass(\"text\");\n        this.chans = this.newStep({\n            \"title\": \"Set channels\",\n            \"first\": \"Enter the channels you would like the client to join on startup:\",\n            \"hint\": \"You can supply multiple channels by seperating them with a comma, e.g.:\",\n            \"example\": \"#rogue,#eu-mage\",\n            middle: this.chanBox\n        }).addEvent(\"show\", af.bind(this.chanBox));\n\n        var customnickDiv = new Element(\"div\");\n        this.customnick = this.newStep({\n            \"title\": \"Choose a nickname mode\",\n            \"first\": \"At startup would you like the client to use a random nickname, a preset nickname or a nickname of the users choice?\",\n            \"hint\": \"It is recommended that you only use a preset nickname if the client is for your own personal use.\",\n            middle: customnickDiv\n        });\n\n        this.choosenick = this.newRadio(customnickDiv, \"Make the user choose a nickname.\", \"nick\", true);\n        this.randnick = this.newRadio(customnickDiv, \"Use a random nickname, e.g. qwebirc12883.\", \"nick\");\n        this.presetnick = this.newRadio(customnickDiv, \"Use a preset nickname of your choice.\", \"nick\");\n\n        var promptdiv = new Element(\"form\");\n        this.connectdialog = this.newStep({\n            \"title\": \"Display connect dialog?\",\n            \"first\": \"Do you want the user to be shown the connect dialog (with the values you have supplied pre-entered) or just a connect confirmation?\",\n            middle: promptdiv,\n            \"hint\": \"You need to display the dialog if you want the user to be able to set their nickname before connecting.\"\n        });\n\n        var changeOptions = new Element(\"div\");\n        this.currentLF = this.newRadio(changeOptions, \"Use the current look and feel (\", \"lookandfeel\", true);\n\n        var alterButton = new Element(\"input\");\n        alterButton.type = \"submit\";\n        alterButton.value = \"alter\";\n        alterButton.addEvent(\"click\", this.options.optionsCallback);\n        changeOptions.firstChild.appendChild(alterButton);\n        changeOptions.firstChild.appendChild(document.createTextNode(\").\"));\n\n        this.defaultLF = this.newRadio(changeOptions, \"Use the default look and feel.\", \"lookandfeel\");\n\n        this.lookandfeel = this.newStep({\n            \"title\": \"Configure look and feel\",\n            \"first\": \"The look and feel will be copied from the current settings.\",\n            middle: changeOptions\n        });\n\n        var autoconnect = this.newRadio(promptdiv, \"Connect without displaying the dialog.\", \"prompt\", true);\n        this.connectdialogr = this.newRadio(promptdiv, \"Show the connect dialog.\", \"prompt\");\n\n        this.nicknameBox = new Element(\"input\");\n        this.nicknameBox.addClass(\"text\");\n        this.nickname = this.newStep({\n            \"title\": \"Set nickname\",\n            \"first\": \"Enter the nickname you would like the client to use by default:\",\n            \"premove\": function() {\n                if (this.nicknameBox.value == \"\") {\n                    alert(\"You must supply a nickname.\");\n                    this.nicknameBox.focus();\n                    return false;\n                }\n                var v = qwebirc.global.nicknameValidator.validate(this.nicknameBox.value, true);\n                if (v != this.nicknameBox.value) {\n                    this.nicknameBox.value = v;\n                    alert(\"The supplied nickname was invalid and has been corrected.\");\n                    this.nicknameBox.focus();\n                    return false;\n                }\n                return true;\n            }.bind(this),\n            middle: this.nicknameBox,\n            hint: \"If you use a . (dot/period) then it will be substituted with a random number.\"\n        }).addEvent(\"show\", af.bind(this.nicknameBox));\n\n        var codeDiv = new Element(\"div\");\n        this.finish = this.newStep({\n            \"title\": \"Finished!\",\n            \"first\": \"Your custom link is:\",\n            middle: codeDiv\n        }).addEvent(\"show\", function() {\n            var alink = new Element(\"a\");\n            var abox = new Element(\"input\");\n            abox.addClass(\"iframetext\");\n            var url = this.generateURL(false);\n\n            alink.href = url;\n            alink.target = \"_blank\";\n            alink.appendChild(document.createTextNode(url));\n            abox.value = \"<iframe src=\\\"\" + url + \"\\\" width=\\\"647\\\" height=\\\"400\\\"></iframe>\";\n\n            var mBox = [\n                alink,\n                new Element(\"br\"), new Element(\"br\"),\n                document.createTextNode(\"You can embed this into your page with the following code:\"),\n                new Element(\"br\"),\n                abox\n            ];\n\n            while (codeDiv.childNodes.length > 0)\n                codeDiv.removeChild(codeDiv.childNodes[0]);\n\n            mBox.forEach(function(x) {\n                codeDiv.appendChild(x);\n            });\n\n            af.bind(abox)(true);\n            abox.addEvent(\"click\", function() {\n                this.select();\n            }.bind(abox));\n        }.bind(this));\n\n        this.updateSteps();\n        this.step = 0;\n\n        this.showStep();\n    },\n    updateSteps: function() {\n        this.steps = [this.welcome, this.customnick];\n\n        if (this.presetnick.checked)\n            this.steps.push(this.nickname);\n\n        this.steps.push(this.chans);\n\n        if (this.chanBox.value != \"\" && !this.choosenick.checked)\n            this.steps.push(this.connectdialog);\n\n        this.steps.push(this.lookandfeel);\n        this.steps.push(this.finish);\n    },\n    showStep: function() {\n        this.backBtn.disabled = !(this.step > 0);\n\n        this.nextBtn.value = (this.step >= this.steps.length - 1) ? \"Close\" : \"Next >\";\n\n        this.steps[this.step].show();\n    },\n    next: function() {\n        var pm = this.steps[this.step].options.premove;\n\n        if (pm && !pm())\n            return;\n\n        this.updateSteps();\n        if (this.step >= this.steps.length - 1) {\n            this.close();\n            return;\n        }\n        this.step = this.step + 1;\n        this.showStep();\n    },\n    close: function() {\n        this.fireEvent(\"close\");\n    },\n    back: function() {\n        if (this.step <= 0)\n            return;\n\n        this.step = this.step - 1;\n        this.showStep();\n    },\n    generateURL: function() {\n        var chans = this.chanBox.value;\n        var nick = this.nicknameBox.value;\n        var connectdialog = this.connectdialogr.checked && chans != \"\" && !this.choosenick.checked;\n\n        var URL = [];\n        if (this.presetnick.checked) {\n            URL.push(\"nick=\" + escape(nick));\n        } else if (!this.choosenick.checked) {\n            URL.push(\"randomnick=1\");\n        }\n\n        if (chans) {\n            // var d = chans.split(\",\");\n            // var d2 = [];\n\n            // d.forEach(function(x) {\n            //     if (x.charAt(0) == '#')\n            //         x = x.substring(1);\n\n            //     d2.push(x);\n            // });\n\n            var chanstr = util.unformatChannelString(chans);\n\n            URL.push(\"channels=\" + escape(chanstr));\n        }\n\n        if (connectdialog)\n            URL.push(\"prompt=1\");\n\n        if (this.currentLF.checked) {\n            var uioptions = this.options.uiOptions.serialise();\n            if (uioptions != \"\")\n                URL.push(\"uio=\" + uioptions);\n        }\n\n        return this.options.baseURL + (URL.length > 0 ? \"?\" : \"\") + URL.join(\"&\");\n    }\n});\n\n\n\nui.setTitle = function(title, options) {\n    if (options && options.alert) {\n        ui.setTitleAlert(title, options);\n    } else {\n        document.title = title;\n    }\n};\n\nui.supportsFocus = function() {\n    var result = (util.isMobile || Browser.name === \"Konqueror\") ?  [false, false] : [true];\n\n    ui.supportsFocus = $lambda(result);\n    return result;\n};\n\nutil.NBSPCreate = function(text, element) {\n    var e = text.split(\"  \");\n    e.each(function(txt, i) {\n        var tn = document.createTextNode(txt);\n        element.appendChild(tn);\n\n        if (i != e.length - 1) {\n            var e2 = new Element(\"span\", {\"html\": \"&nbsp;&nbsp;\"});\n            element.appendChild(e2);\n        }\n    });\n};\n\nutil.setCaretPos = Element.setCaretPosition;\n\nutil.setAtEnd = function($el) {\n    util.setCaretPos($el, $el.value.length);\n};\n\nutil.getCaretPos = Element.getCaretPosition;\n\n//....\n//TODO this is garbage\nutil.createInput = function(type, parent, name, selected, id) {\n    var r;\n    if (Browser.Engine.trident) {\n        if (name) {\n            name = \" name=\\\"\" + escape(name) + \"\\\"\";\n        } else {\n            name = \"\";\n        }\n        if (id) {\n            id = \" id=\\\"\" + escape(id) + \"\\\"\";\n        } else {\n            id = \"\";\n        }\n        r = $(document.createElement(\"<input type=\\\"\" + type + \"\\\"\" + name + id + \" \" + (selected ? \" checked\" : \"\") + \"/>\"));\n    } else {\n        r = new Element(\"input\");\n        r.type = type;\n        if (name) r.name = name;\n        if (id) r.id = id;\n\n        if (selected) r.checked = true;\n    }\n\n    parent.appendChild(r);\n    return r;\n};\n\nutil.percentToPixel= function(data, par) {\n    par = par || document.body;\n    var size = par.getSize();\n    return {\n        x: size.x * (data.x / 100),\n        y: size.y * (data.y / 100)\n    };\n}\n\n\nui.decorateDropdown = function(btn, ddm, options) {\n    ddm.hideMenu = function() {\n        if(options && options.onHide)\n            options.onHide.call(this, ddm);\n        return ddm.hide();\n    };\n    ddm.showMenu = function() {\n        if(options && options.onShow)\n            options.onShow.call(this, ddm);\n\n        if (ddm.isDisplayed()) {\n           ddm.hideMenu();\n        } else {\n            ddm.show();\n            document.addEvent(\"click:once\", ddm.hideMenu);\n        }\n        return ddm;\n    };\n\n    ddm.position.delay(50, ddm, {\n        relativeTo: btn,\n        position: {x: 'left', y: 'bottom'},\n        edge: {x: 'left', y: 'top'}\n    });\n\n    btn.addEvent(\"click\", function(e) {\n            e.stop();\n            ddm.showMenu();\n        });\n    return ddm.hideMenu();\n};\n\n//dirty function please help with css :(\n//dir can be 'width' 'height'\nutil.fillContainer = function ($ele, sty, offset) {\n    offset = offset || 10;\n    sty = (sty || 'width').toLowerCase();\n    var method = 'get' + (sty.contains('width') ? 'Width' : 'Height');\n    (function() {//wait a sec for style recalcs\n        $ele.getSiblings().each(function(sib) {\n            offset += sib[method](sty);\n        });\n\n        $ele.setStyle(sty, \"calc(100% - \" + offset + \"px)\");\n    }).delay(20);\n    return $ele;\n};\n\nutil.elementAtScrollPos = function($ele, pos, dir, offset) {\n    dir = (dir || 'width').capitalize();\n    offset = offset || 10;\n    var $res = $ele.lastChild;\n    Array.some($ele.childNodes, function($kid) {\n        offset += $kid['get' + dir]();\n        if(offset >= pos) {\n            $res = $kid;\n            return true;\n        }\n    });\n    return $res;\n};\n\n\nvar keys;\nif(!util.isMobile) {\n    keys = new Keyboard();\n} else {\n    delete window.Keyboard;\n}\n\n\n\n//not a class?\nui.MENU_ITEMS = (function() {\n    function isOpped(nick) {\n        var channel = this.name; /* window name */\n        var myNick = this.client.nickname;\n\n        return this.client.nickOnChanHasAtLeastPrefix(myNick, channel, \"@\");\n    }\n\n    function isVoiced(nick) {\n        var channel = this.name;\n        var myNick = this.client.nickname;\n\n        return this.client.nickOnChanHasPrefix(myNick, channel, \"+\");\n    }\n\n    function targetOpped(nick) {\n        var channel = this.name;\n        return this.client.nickOnChanHasPrefix(nick, channel, \"@\");\n    }\n\n    function targetVoiced(nick) {\n        var channel = this.name;\n        return this.client.nickOnChanHasPrefix(nick, channel, \"+\");\n    }\n\n    function command(cmd) {\n        return function(nick) {\n            this.client.exec(\"/\" + cmd + \" \" + nick);\n        };\n    }\n\n    return [{\n        text: \"whois\",\n        fn: command(\"whois\"),\n        predicate: true\n    }, {\n        text: \"query\",\n        fn: command(\"query\"),\n        predicate: true\n    }, {\n        text: \"slap\",\n        fn: function(nick) {\n            this.client.exec(\"/ME \" + util.formatter(lang.fishbot, {\n                'nick': nick\n            }));\n        },\n        predicate: true\n    }, {\n        text: \"kick\",\n        /* TODO: disappear when we're deopped */\n        fn: function(nick) {\n            this.client.exec(\"/KICK \" + nick + \" wibble\");\n        },\n        predicate: isOpped\n    }, {\n        text: \"op\",\n        fn: command(\"op\"),\n        predicate: prelude.andand(isOpped, Functional.not(targetOpped))\n    }, {\n        text: \"deop\",\n        fn: command(\"deop\"),\n        predicate: prelude.andand(isOpped, targetOpped)\n    }, {\n        text: \"voice\",\n        fn: command(\"voice\"),\n        predicate: prelude.andand(isOpped, Functional.not(targetVoiced))\n    }, {\n        text: \"devoice\",\n        fn: command(\"devoice\"),\n        predicate: prelude.andand(isOpped, targetVoiced)\n    }];\n})();\n\n\nui.RequestTransformHTML = function(options) {\n    var HREF_ELEMENTS = [\"IMG\"];\n\n    var $update = options.update;\n    var onSuccess = options.onSuccess;\n\n    var fixUp = function(node) {\n            if (node.nodeType !== Node.ELEMENT_NODE)\n                return;\n\n            if (HREF_ELEMENTS.contains(node.nodeName.toUpperCase())) {\n                var attr = node.getAttribute(\"transform_attr\");\n                var value = node.getAttribute(\"transform_value\");\n                if ($defined(attr) && $defined(value)) {\n                    node.removeProperties(\"transform_attr\", \"transform_value\")\n                        .setProperty(attr, qwebirc.global.staticBaseURL + value);\n                }\n            }\n\n            Array.each(node.childNodes, fixUp);\n        };\n\n    delete options[\"update\"];\n    options.onSuccess = function(tree, elements, html, js) {\n        var container = new Element(\"div\", {'html': html});\n        fixUp(container);\n        $update.empty();\n\n        Array.each(container.childNodes, function(node) {\n            node.swapParent($update);\n        });\n        onSuccess();\n    };\n\n    return new Request.HTML(options);\n};\n\n\nui.Theme = new Class({\n    initialize: function(themeDict) {\n        var self = this,\n            theme = self.__theme = Object.clone(ui.themes.Default2);\n\n        if (themeDict) {\n            // for (var k in themeDict) {\n            //     theme[k] = themeDict[k];\n            // }\n            $extend(theme, themeDict);\n        }\n        Object.each(theme, function(data, key) {\n            if (key === \"PREFIX\")\n                return;\n\n            if (data[1]) {\n                theme[key] = theme.PREFIX + data[0];\n            } else {\n                theme[key] = data[0];\n            }\n        });\n\n        self.__ccmap = Object.clone(ui.themes.ThemeControlCodeMap2);\n        self.__ccmaph = Object.clone(self.__ccmap);\n\n        self.__ccmaph[\"(\"] = self.message(\"HILIGHT\", {}, self.__ccmap);\n        self.__ccmaph[\")\"] = self.message(\"HILIGHTEND\", {}, self.__ccmap);\n        self.__ccmaph[\"{\"] = self.__ccmaph[\"}\"] = \"\";\n    },\n\n    //fuck that this is awful - use String.substitute with a regex\n    __dollarSubstitute: function(x, h, mapper) {\n        // if (x == '-${$($N$)$}:$c- $m' && h['c'] == BROUHAHA)\n        //     x = '-${$($N$)$}- $m';\n        // var msg = [];\n\n        // var n = x.split(\"\");\n        // //loop of the devil\n        // for (var i = 0; i < n.length; i++) {\n        //     var c = n[i];\n        //     if (c == \"$\" && (i <= n.length - 1)) {\n        //         var c2 = n[++i];\n\n        //         var o = mapper[c2];\n        //         if (!o)\n        //             o = h[c2];\n        //         if (o)\n        //             msg.push(o);\n        //     } else {\n        //         msg.push(c);\n        //     }\n        // }\n\n        // return msg.join(\"\");\n\n        return x.substitute(Object.append(h||{}, mapper||{}))\n    },\n    message: function(type, data, hilight) {\n        var map;\n        if (hilight) {\n            map = this.__ccmaph;\n        } else {\n            map = this.__ccmap;\n        }\n\n        if (data && data[\"n\"])\n            data[\"N\"] = \"qwebirc://whois/\" + data.n + \"/\";\n        return this.__dollarSubstitute(this.__theme[type], data, map);\n    }\n});\n\n// ui.HilightController = new Class({\n//     initialize: function(parent) {\n//         this.parent = parent;\n//         this.regex = null;\n//         this.prevnick = null;\n//     },\n//     match: function(text) {\n//         var nick = this.parent.nickname;\n//         if (nick !== this.prevnick) {\n//             var classes = '[\\\\s\\\\.,;:]';\n//             this.regex = new RegExp('(^|' + classes + ')' + RegExp.escape(nick) + '(' + classes + '|$)', \"i\");\n//         }\n//         return this.regex.test(text);\n//     }\n// });\n\n\nui.TabCompleterFactory = new Class({\n    initialize: function(ui) {\n        this.ui = ui;\n        this.reset();\n    },\n    tabComplete: function(textBox) {\n        var text = textBox.value;\n\n        if (!$defined(this.obj)) {\n            this.incr = 1;\n\n            var win = this.ui.getActiveWindow();\n            if (!win)\n                return;\n\n            var startingWord = util.getEnclosedWord(text, util.getCaretPos(textBox));\n            var preword = \"\",\n                word = \"\",\n                postword = \"\";\n            if ($defined(startingWord)) {\n                preword = text.substring(0, startingWord[0]);\n                word = startingWord[1];\n                postword = text.substring(startingWord[0] + word.length);\n            }\n\n            var ltext = text.toLowerCase(),\n                obj;\n            if (!text) {\n                preword = \"/msg \";\n                obj = ui.QueryTabCompleter;\n            } else if (util.isChannel(word)) {\n                obj = ui.ChannelNameTabCompleter;\n            } /*else if (false //ltext.match(/^\\/(q|query|msg) /i) ) {\n                obj = ui.QueryTabCompleter;\n            }*/ else if (win.type === ui.WINDOW_QUERY) {\n                obj = ui.QueryNickTabCompleter;\n            } else if (win.type === ui.WINDOW_CHANNEL) { /* \"slug[TAB]\" == \"slug: \" */\n                if (!preword) {\n                    // if ( !! postword && postword.charAt(0) === \" \") {\n                    //     postword = \":\" + postword; //should i call util.padcolon here?\n                    // } else {\n                    //     postword = \": \" + postword;\n                    // }\n                    postword = \": \" + postword.trimLeft();\n\n                    this.incr++;\n                }\n                obj = ui.ChannelUsersTabCompleter;\n            } else {\n                return;\n            }\n\n            if (postword === \"\")\n                postword = \" \";\n\n            this.obj = new obj(preword, word, postword, win);\n            if (!$defined(this.obj))\n                return;\n        }\n\n        var ret = this.obj.get();\n        if (!$defined(ret))\n            return;\n\n        textBox.value = ret[1];\n        util.setCaretPos(textBox, ret[0] + this.incr);\n    },\n    reset: function() {\n        this.obj = null;\n    }\n});\n\nui.TabIterator = new Class({\n    initialize: function(client, prefix, list) {\n        this.prefix = prefix;\n        if (!$defined(list) || list.length === 0) {\n            this.list = null;\n        } else {\n            var prefixes = irc.toIRCCompletion(client, prefix);\n\n            /* convert the nick list to IRC lower case, stripping all non letters\n             * before comparisions */\n            // for (var i = 0; i < list.length; i++) {\n            //     var l2 = irc.toIRCCompletion(client, list[i]);\n\n            //     if (l2.startsWith(prefixes))\n            //         l.push(list[i]);\n            // }\n            var listf = list.filter(Functional.compose(util.prefixOnNick(prefixes), irc.toIRCCompletion.curry(client)));\n\n            this.list = listf;\n        }\n\n        this.pos = -1;\n    },\n    next: function() {\n        /*\n         * ideally next would do the list gubbins recursively, but no JS engine currently\n         * support tail recursion :(\n         */\n        if (!$defined(this.list))\n            return null;\n\n        this.pos = this.pos + 1;\n        if (this.pos >= this.list.length)\n            this.pos = 0;\n\n        return this.list[this.pos];\n    }\n});\n\nui.BaseTabCompleter = new Class({\n    initialize: function(client, prefix, existingNick, suffix, list) {\n        this.existingNick = existingNick;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.iterator = new ui.TabIterator(client, existingNick, list);\n    },\n    get: function() {\n        var n = this.iterator.next();\n        if (!$defined(n))\n            return null;\n\n        var p = this.prefix + n;\n        return [p.length, p + this.suffix];\n    }\n});\n\nui.QueryTabCompleter = new Class({\n    Extends: ui.BaseTabCompleter,\n    initialize: function(prefix, existingNick, suffix, win) {\n        this.parent(win.client, prefix, existingNick, suffix, win.client.lastNicks);\n    }\n});\n\nui.QueryNickTabCompleter = new Class({\n    Extends: ui.BaseTabCompleter,\n    initialize: function(prefix, existingText, suffix, win) {\n        var chan = win.name;\n        this.parent(win.client, prefix, existingText, suffix, [chan]);\n    }\n});\n\nui.ChannelNameTabCompleter = new Class({\n    Extends: ui.BaseTabCompleter,\n    initialize: function(prefix, existingText, suffix, window) {\n\n        var l = [];\n        Object.each(window.client.channels, function(chan, name) {\n            if($defined(chan)) {\n                chan = chan.lastSelected;\n            }\n            l.push([chan, name]);\n        });\n\n        var l2 = l.sort(function(a, b) {\n            return b[0] - a[0];\n        }).map(prelude.item(1));\n\n        this.parent(window.client, prefix, existingText, suffix, l2);\n        // this.parent.apply(this, Array.concat(window.client, arguments, l2));\n    }\n});\n\nui.ChannelUsersTabCompleter = new Class({\n    Extends: ui.BaseTabCompleter,\n    initialize: function(prefix, existingText, suffix, window) {\n        var nc = window.client.tracker.getSortedByLastSpoke(irc.activeChannel);\n\n        this.parent(window.client, prefix, existingText, suffix, nc);\n    }\n});\n\n\n\n/*\n    TODO: Options:\n    - templating get rid of tables\n    - beep/flash/highligh on text infinite regexp list\n    - custom sounds?\n\n*/\n\n\n/**\n * Note that options are settable by the uioptions url arg by default unless you specifiy\n * settableByURL...\n */\nconfig.DEFAULT_OPTIONS = [\n    //option is a structure:\n    // 0: id\n    // 1: alias\n    // 2: description of option\n    // 3: default val\n    // 4: setter\n    [1, \"BEEP_ON_MENTION\", \"Beep when nick mentioned or on query activity (requires Flash or html5)\", true,\n    {\n        enabled: $lambda([true]),\n        applyChanges: function(value, ui) {\n            if ($defined(ui.setBeepOnMention))\n                ui.setBeepOnMention(value);\n        }\n    }],\n    [7, \"FLASH_ON_MENTION\", \"Flash titlebar when nick mentioned or on query activity\", true,\n    {\n        enabled: ui.supportsFocus\n    }],\n    [2, \"DEDICATED_MSG_WINDOW\", \"Send privmsgs to dedicated messages window\", false],\n    [4, \"DEDICATED_NOTICE_WINDOW\", \"Send notices to dedicated message window\", false],\n    [3, \"NICK_OV_STATUS\", \"Show status (@/+) before nicknames in channel lines\", true],\n    [5, \"ACCEPT_SERVICE_INVITES\", \"Automatically join channels when invited by Q\", true,\n    {\n        settableByURL: false\n    }],\n    [6, \"USE_HIDDENHOST\", \"Hide your hostmask when authed to Q (+x)\", true,\n    {\n        settableByURL: false\n    }],\n    [8, \"LASTPOS_LINE\", \"Show a last position indicator for each window\", true,\n    {\n        enabled: ui.supportsFocus\n    }],\n    [9, \"NICK_COLOURS\", \"Automatically colour nicknames\", false],\n    [10, \"HIDE_JOINPARTS\", \"Hide JOINS/PARTS/QUITS\", false],\n    [11, \"STYLE_HUE\", \"Adjust user interface hue\", function() {\n        return {\n            class_: config.HueOption,\n            default_: 210\n        };\n    }, {\n        applyChanges: function(value, ui) {\n            ui.setModifiableStylesheetValues({\n                hue: value\n            });\n        }\n    }],\n    [12, \"QUERY_ON_NICK_CLICK\", \"Query on nickname click in channel\", false],\n    [13, \"SHOW_NICKLIST\", \"Show nickname list in channels\", true],\n    [14, \"SHOW_TIMESTAMPS\", \"Show timestamps\", true] /* we rely on the hue update */ ];\n\nconfig.DefaultOptions = null;\n\nconfig.Input = new Class({\n    initialize: function(parent, option, position, parentObject) {\n        this.option = option;\n        this.value = option.value;\n        this.enabled = this.option.enabled;\n        this.position = position;\n        this.parentElement = parent;\n        this.parentObject = parentObject;\n        this.render();\n    },\n\n    createInput: function(type, parent, name, selected, id) {\n        if (!$defined(parent))\n            parent = this.parentElement;\n\n        return util.createInput(type, parent, name, selected, this.option.id);\n    },\n\n    FE: function(element, parent) {\n        var n = new Element(element);\n        if (!$defined(parent)) parent = this.parentElement;\n\n        parent.adopt(n);\n        return n;\n    },\n\n    focus: function() {\n        this.mainElement.focus();\n    },\n\n    render: function() {\n        this.event(\"render\", this.mainElement);\n    },\n\n    applyChanges: function() {\n        this.event(\"applyChanges\", [this.get(), this.parentObject.optionObject.ui]);\n    },\n\n    event: function(name, x) {\n        if (!$defined(this.option.extras)) return;\n        var t = this.option.extras[name];\n        if (!$defined(t)) return;\n\n        t.pass(x, this)();\n    },\n\n    cancel: function() {}\n});\n\nconfig.TextInput = new Class({\n    Extends: config.Input,\n    render: function() {\n        var i = this.createInput(\"text\");\n        this.mainElement = i;\n\n        i.value = this.value;\n        i.disabled = !this.enabled;\n\n        this.parent();\n    },\n\n    get: function() {\n        return this.mainElement.value;\n    }\n});\n\nconfig.HueInput = new Class({\n    Extends: config.Input,\n    render: function() {\n        var i = new Element(\"div\");\n        i.addClass(\"qwebirc-optionspane\");\n        i.addClass(\"hue-slider\");\n        this.parentElement.appendChild(i);\n\n        var k = new Element(\"div\");\n        k.addClass(\"knob\");\n        if (Browser.Engine.trident) {\n            k.setStyle(\"top\", \"0px\");\n            k.setStyle(\"background-color\", \"black\");\n        }\n\n        i.appendChild(k);\n\n        var slider = new Slider(i, k, {\n            steps: 36,\n            range: [0, 369],\n            wheel: true\n        });\n        slider.set(this.value);\n        this.startValue = this.value;\n\n        slider.addEvent(\"change\", function(step) {\n            this.value = step;\n            this.applyChanges();\n        }.bind(this));\n        this.mainElement = i;\n\n        if (!this.enabled) slider.detach();\n\n        this.parent();\n    },\n    get: function() {\n        return this.value;\n    },\n    cancel: function() {\n        this.value = this.startValue;\n        this.applyChanges();\n    }\n});\n\nconfig.CheckInput = new Class({\n    Extends: config.Input,\n    render: function() {\n        var i = this.createInput(\"checkbox\", null, null, null, this.id);\n        this.mainElement = i;\n\n        i.checked = this.value;\n        i.disabled = !this.enabled;\n\n        this.parent();\n    },\n    get: function() {\n        return this.mainElement.checked;\n    }\n});\n\nconfig.RadioInput = new Class({\n    Extends: config.Input,\n    render: function() {\n        var value = this.option.options;\n\n        this.elements = [];\n\n        for (var i = 0; i < value.length; i++) {\n            var d = this.FE(\"div\", this.parentObject);\n            var e = this.createInput(\"radio\", d, \"options_radio\" + this.position, i == this.option.position);\n            this.elements.push(e);\n            e.disabled = !this.enabled;\n\n            if (i === 0)\n                this.mainElement = e;\n\n            d.appendChild(document.createTextNode(value[i][0]));\n        };\n        this.parent();\n    },\n    get: function() {\n        for (var i = 0; i < this.elements.length; i++) {\n            var x = this.elements[i];\n            if (x.checked) {\n                this.option.position = i;\n                return this.option.options[i][1];\n            }\n        }\n    }\n});\n\nconfig.Option = new Class({\n    initialize: function(optionId, prefix, label, default_, extras) {\n        this.prefix = prefix;\n        this.label = label;\n        this.default_ = default_;\n        this.optionId = optionId;\n        this.extras = extras;\n\n        if ($defined(extras) && $defined(extras.enabled)) {\n            var enabledResult = extras.enabled();\n            this.enabled = enabledResult[0];\n\n            if (!enabledResult[0] && enabledResult.length > 1)\n                this.default_ = enabledResult[1];\n        } else {\n            this.enabled = true;\n        }\n\n        if ($defined(extras) && $defined(extras.settableByURL)) {\n            this.settableByURL = extras.settableByURL;\n        } else {\n            this.settableByURL = true;\n        }\n    },\n    setSavedValue: function(x) {\n        if (this.enabled)\n            this.value = x;\n    }\n});\n\nconfig.RadioOption = new Class({\n    Extends: config.Option,\n    Element: config.RadioInput,\n    initialize: function(optionId, prefix, label, default_, extras, options) {\n        this.options = options.map(function(x) {\n            return (typeof(x) === \"string\") ? [x, x] : x;\n        });\n        this.defaultposition = default_;\n\n        this.parent(optionId, prefix, label, this.options[default_][1], extras);\n    },\n    setSavedValue: function(x) {\n        for (var i = 0; i < this.options.length; i++) {\n            var y = this.options[i][1];\n            if (x === y) {\n                this.position = i;\n                this.value = x;\n                return;\n            }\n        }\n        this.position = this.defaultposition;\n        this.value = this.default_;\n    }\n});\n\nconfig.TextOption = new Class({\n    Extends: config.Option,\n    Element: config.TextInput\n});\n\nconfig.CheckOption = new Class({\n    Extends: config.Option,\n    Element: config.CheckInput\n});\n\nconfig.HueOption = new Class({\n    Extends: config.Option,\n    Element: config.HueInput\n});\n\nui.Options = new Class({\n    initialize: function(ui) {\n        if (!$defined(config.DefaultOptions)) this.__configureDefaults();\n\n        this.optionList = config.DefaultOptions.slice();\n        this.optionHash = {};\n        this.ui = ui;\n\n        this._setup();\n        this.optionList.each(function(x) {\n            x.setSavedValue(this._get(x));\n            this.optionHash[x.prefix] = x;\n            this[x.prefix] = x.value;\n        }.bind(this));\n    },\n    __configureDefaults: function() {\n        config.DefaultOptions = config.DEFAULT_OPTIONS.map(function(opt) {\n            var optionId = opt[0];\n            var prefix = opt[1];\n            var label = opt[2];\n            var default_ = opt[3];\n            var moreextras = opt[4];\n            var extras = opt[5];\n\n            var stype = typeof(default_);\n            if (stype == \"number\") {\n                return new config.RadioOption(optionId, prefix, label, default_, moreextras, extra);\n            } else {\n                var type;\n                if (stype == \"boolean\") {\n                    type = config.CheckOption;\n                } else if (stype == \"function\") {\n                    var options = default_();\n                    type = options.class_;\n                    default_ = options.default_;\n                } else {\n                    type = config.TextOption;\n                }\n                return new type(optionId, prefix, label, default_, moreextras);\n            }\n        });\n    },\n    setValue: function(option, value) {\n        this.optionHash[option.prefix].value = value;\n        this[option.prefix] = value;\n    },\n    getOptionList: function() {\n        return this.optionList;\n    },\n    _get: function(opt) {\n        return opt.default_;\n    },\n    _setup: function() {},\n    flush: function() {}\n});\n\nui.OptionsPane = new Class({\n    Implements: [Events],\n    initialize: function(parentElement, optionObject) {\n        this.parentElement = parentElement;\n        this.optionObject = optionObject;\n\n        this.createElements();\n    },\n    createElements: function() {\n        var FE = function(element, parent) {\n                var n = new Element(element);\n                parent.appendChild(n);\n                return n;\n            };\n\n        var t = FE(\"table\", this.parentElement);\n        var tb = FE(\"tbody\", t);\n\n        this.boxList = [];\n\n        var optList = this.optionObject.getOptionList();\n        for (var i = 0; i < optList.length; i++) {\n            var opt = optList[i];\n\n            var row = FE(\"tr\", tb);\n            var cella = FE(\"td\", row);\n\n            opt.id = qwebirc.util.generateID();\n            var label = new Element(\"label\", {\n                \"for\": opt.id\n            });\n            cella.appendChild(label);\n            label.set(\"text\", opt.label + \":\");\n\n            var cellb = FE(\"td\", row);\n            this.boxList.push([opt, new opt.Element(cellb, opt, i, this)]);\n\n        }\n\n        var r = FE(\"tr\", tb);\n        var cella = FE(\"td\", r);\n        var cellb = FE(\"td\", r);\n        var save = qwebirc.util.createInput(\"submit\", cellb);\n        save.value = \"Save\";\n\n        save.addEvent(\"click\", function() {\n            this.save();\n            this.fireEvent(\"close\");\n        }.bind(this));\n\n        var cancel = qwebirc.util.createInput(\"submit\", cellb);\n        cancel.value = \"Cancel\";\n        cancel.addEvent(\"click\", function() {\n            this.cancel();\n            this.fireEvent(\"close\");\n        }.bind(this));\n    },\n    save: function() {\n        this.boxList.each(function(opt) {\n            var option = opt[0];\n            var box = opt[1];\n            this.optionObject.setValue(option, box.get());\n        }.bind(this));\n        this.boxList.each(function(opt) {\n            opt[1].applyChanges();\n        }.bind(this));\n        this.optionObject.flush();\n    },\n    cancel: function() {\n        this.boxList.each(function(opt) {\n            opt[1].cancel();\n        }.bind(this));\n    }\n});\n\nui.CookieOptions = new Class({\n    Extends: ui.Options,\n    _setup: function() {\n        // this.__cookie = new Hash.Cookie(\"opt1\", {\n        //     duration: 3650,\n        //     autoSave: false\n        // });\n        this.storage = storage;\n        this.__key = \"opt1\";\n        this.__options = this.storage.get(this.__key) || {};\n    },\n    _get: function(option) {\n        // var v = this.__cookie.get(option.optionId); \n        var val = this.__options[option.optionId];\n        return $defined(val) ? val : option.default_;\n    },\n    flush: function() {\n        // this.storage.remove(this.__key);\n        // this._setup();\n\n        // var opts = this.getOptionList().each(function(option) {\n        //     this.__cookie.set(option.optionId, option.value);\n        // }.bind(this));\n        // this.__cookie.save();\n        var opts = {};\n        this.getOptionList().each(function(option) {\n            if(option.value !== option.default_) { //minimize stored data\n                opts[option.optionId] = option.value;\n            }\n        });\n        this.__options = opts;\n        this.storage.set(this.__key, opts);\n    }\n});\n\nui.SuppliedArgOptions = new Class({\n    Extends: ui.CookieOptions,\n    initialize: function(ui, arg) {\n        var p = {};\n\n        if ($chk(arg) && arg.length > 2) {\n            var checksum = arg.substr(arg.length - 2, 2);\n            var decoded = util.B64.decode(arg.substr(0, arg.length - 2));\n\n            if (decoded && (new crypto.MD5().digest(decoded).slice(0, 2) == checksum))\n                p = util.parseURI(\"?\" + decoded);\n        }\n\n        this.parsedOptions = p;\n        this.parent(ui);\n    },\n\n    _get: function(opt) {\n        if (opt.settableByURL !== true)\n            return this.parent(opt);\n\n        var option = this.parsedOptions[opt.optionId];\n\n        return $defined(option) ? opt : this.parent(opt);\n    },\n\n    serialise: function() {\n        var result = [];\n        this.getOptionList().each(function(opt) {\n            if (opt.settableByURL && opt.default_ != opt.value)\n                result.push(opt.optionId + \"=\" + opt.value);\n        }.bind(this));\n\n        var raw = result.join(\"&\");\n        var checksum = new crypto.MD5().digest(raw).slice(0, 2);\n        return (qwebirc.util.B64.encode(raw)).replaceAll(\"=\", \"\") + checksum;\n    }\n});\n\nui.DefaultOptionsClass = new Class({\n    Extends: ui.SuppliedArgOptions\n});\n\n\nutil.parseStylesheet = function(data) {\n    var lines = data.replace(/\\r/g, \"\") //irnore double breaks\n                    .split(\"\\n\");\n\n    var rules = {},\n        line, inx,\n        i;\n    for (var i = 0; i < lines.length; i++) {\n        line = lines[i];\n\n        if (line.trim() !== \"\" && (inx = line.indexOf(\"=\", 2)) !== -1)\n            rules[line.slice(0, inx)] = line.slice(inx + 1);\n        else\n            break;\n    }\n\n    var cssLines = lines.slice(i);\n    // for (; i < lines.length; i++) //note its using the same i as above\n    //     cssLines.push(lines[i]);\n\n    return {\n        cssText: cssLines.join(\"\\n\"),\n        rules: rules\n    };\n};\n\nutil.getSyncAsset = function(url) {\n    var req = new Request({\n        'url': url,//'http://atf2.org/css/qui-bbc577ad5cb78d946ac1.mcss',\n        'async': false\n    });\n    req.headers = {};\n    var result;\n    req.addEvent(\"complete\", function(x) {\n            result = x;\n        })\n        .get();\n    return result;\n};\n\nui.style.ModifiableStylesheet = new Class({\n    initialize: function(url) {\n        var n = util.parseStylesheet(util.getSyncAsset(url));\n\n        this.__cssText = n.cssText;\n        this.rules = n.rules;\n\n        this.__tag = new Element(\"style\", {\n                        type: \"text/css\",\n                        media: \"all\"\n                    }).inject(document.head, 'bottom');\n    },\n    __setStylesheet: function(stylesheet) {\n        var node = this.__tag;\n\n        if (node.styleSheet) { /* IE */\n            node.styleSheet.cssText = stylesheet;\n        } else {\n            node.empty()\n                .appendText(stylesheet);\n        }\n    },\n    set: function(mutatorfn) {\n        mutatorfn = mutatorfn || $identity;\n\n        var text = this.__cssText;\n\n        Object.each(this.rules, function(val, key) {\n            var s = val.split(\",\"),\n                value = mutatorfn.pass(s);\n\n            text = text.replaceAll(\"$(\" + key + \")\", value);\n        });\n\n        this.__setStylesheet(text);\n    }\n});\n\n\nui.Window = new Class({\n    Implements: [Events],\n    initialize: function(parentObject, client, type, name, identifier) {\n        this.parentObject = parentObject;\n        this.type = type;\n        this.currentChannel = this.name = name;\n        this.active = false;\n        this.client = client;\n        this.identifier = identifier;\n        this.hilighted = ui.HILIGHT_NONE;\n        // this.scrolltimer = null;\n        this.commandhistory = this.parentObject.commandhistory;\n        // this.scrolleddown = true;\n        // this.scrollpos = null;\n        this.lastNickHash = {};\n        this.lastSelected = null;\n        this.subWindow = null;\n        this.closed = false;\n\n        if (this.type & ui.WINDOW_LASTLINE) {\n            this.lastPositionLine = Element.from(templates.messageLine());\n            this.lastPositionLineInserted = false;\n        }\n\n        this.window = this.parentObject.qjsui.createWindow();\n    },\n    updateTopic: function(topic, element) {\n        ui.Colourise(\"[\" + topic + \"]\", element, this.client.exec, this.parentObject.urlDispatcher, this);\n    },\n    close: function() {\n        this.closed = true;\n\n        // if ($defined(this.scrolltimer)) {\n        //     $clear(this.scrolltimer);\n        //     this.scrolltimer = null;\n        // }\n\n        this.parentObject.__closed(this);\n        this.fireEvent(\"close\", this);\n    },\n    subEvent: function(event) {\n        if ($defined(this.subWindow))\n            this.subWindow.fireEvent(event);\n    },\n    setSubWindow: function(win) {\n        this.subWindow = win;\n    },\n\n    select: function() {\n        if (this.lastPositionLineInserted && !this.parentObject.uiOptions.LASTPOS_LINE) {\n            this.lines.disown(this.lastPositionLine);\n            this.lastPositionLineInserted = false;\n        }\n\n        this.active = true;\n        this.parentObject.__setActiveWindow(this);\n        if (this.hilighted)\n            this.highlightTab(ui.HILIGHT_NONE);\n\n        this.subEvent(\"select\");\n        // this.resetScrollPos();\n        this.lastSelected = new Date();\n    },\n\n    deselect: function() {\n        this.subEvent(\"deselect\");\n\n        // this.setScrollPos();\n        // if ($defined(this.scrolltimer)) {\n        //     $clear(this.scrolltimer);\n        //     this.scrolltimer = null;\n        // }\n\n        if (this.type & ui.WINDOW_LASTLINE)\n            this.replaceLastPositionLine();\n\n        this.active = false;\n    },\n\n    resetScrollPos: function() {\n        // if (this.scrolleddown) {\n        //     this.scrollToBottom();\n        // } else if ($defined(this.scrollpos)) {\n        //     this.getScrollParent().scrollTo(this.scrollpos.x, this.scrollpos.y);\n        // }\n    },\n    setScrollPos: function() {\n        // if (!this.parentObject.singleWindow) {\n        //     this.scrolleddown = this.scrolledDown();\n        //     this.scrollpos = this.lines.getScroll();\n        // }\n    },\n\n\n    /* A line is an object of the form:\n    -: current nick\n    @: opstatus\n    c: channel\n    f: origin channel\n    h: ip of propogater\n    m: msg\n    n: nick\n    */\n\n    addLine: function(type, line, colour, $ele) {\n        var self = this,\n            uiobj = self.parentObject;\n        var hilight = ui.HILIGHT_NONE,\n            hl_line = false;\n\n        if (type && line) {\n        //regexs\n            var isbot = /^TF2/.test(line.n), //works for pugna(hl), mix(hl)\n                ismsg = /(NOTICE|ACTION|MSG)$/.test(type),\n                regNotice = /NOTICE$/,\n                sentByUs = /^OUR/.test(type),//ignore\n                containsNick = util.testForNick(self.client.nickname);\n\n            var notice = function() {\n                if (!(self.active && uiobj.windowFocused) && line.c !== BROUHAHA) {\n                    uiobj.beep();\n                    uiobj.flash();\n                }\n            };\n\n            hilight = ui.HILIGHT_ACTIVITY;\n\n            if (ismsg) {\n                //highlighting\n                if (line.n && line.m && self.type === ui.WINDOW_CHANNEL) {\n                    $ele.addClass('message');\n                    if(isbot)\n                        $ele.addClass('bot');\n                    else if(sentByUs)\n                        $ele.addClass('our');\n                    if(!isbot && line.m.startsWith(\"!\"))\n                        $ele.addClass('command');\n                }\n\n                if (self.type === ui.WINDOW_QUERY || self.type === ui.WINDOW_MESSAGES) {\n                    if (sentByUs || regNotice.test(type)) {\n                        hilight = ui.HILIGHT_ACTIVITY;\n                    } else {\n                        hilight = ui.HILIGHT_US;\n                        notice(); //private message\n                    }\n                }\n                else if (regNotice.test(type) && self.type === ui.WINDOW_CHANNEL) {\n                    $ele.style.color = \"red\";\n                    notice();\n                }\n                else if (!sentByUs && containsNick(line.m)) { //dont beep if bot says our name\n                    if(isbot) {\n                        $ele.addClass('bot@us')\n                    }\n                    else {\n                        hl_line = true;\n                        hilight = ui.HILIGHT_US;\n                        notice();//name mention in chan\n                    }\n                }\n                else if (hilight !== ui.HILIGHT_US) {\n                    hilight = ui.HILIGHT_SPEECH;\n                }\n            }\n        }\n\n        if (!self.active && (hilight !== ui.HILIGHT_NONE))\n            self.highlightTab(hilight);\n\n        if (type)\n            line = uiobj.theme.message(type, line, hl_line);\n\n        var tsE = templates.timestamp({time:util.IRCTimestamp(new Date())});\n        $ele.insertAdjacentHTML('afterbegin', tsE);\n        // $ele.appendChild($ele.from(tsE));\n\n        ui.Colourise(line, $ele, self.client.exec, uiobj.urlDispatcher, self);\n        // self.scrollAdd($ele);\n        self.lines.adopt($ele);\n    },\n    errorMessage: function(message) {\n        this.addLine(\"\", message, \"warncolour\");\n    },\n    infoMessage: function(message) {\n        this.addLine(\"\", message, \"infocolour\");\n    },\n    highlightTab: function(state) {\n        if (state == ui.HILIGHT_NONE || state >= this.hilighted)\n            this.hilighted = state;\n    },\n\n    //holy shit i got this to actually make sense\n    // takes nicks (sorted array)\n    updateNickList: function(nicks) {\n        var lnh = this.lastNickHash,\n            oldnames = Object.keys(lnh),\n\n            added = prelude.difference(nicks, oldnames),//users who joined\n            left = prelude.difference(oldnames, nicks); //users who left\n\n        left.each(function(nick) {\n            var element = lnh[nick];\n            this.nickListRemove(nick, element);\n            delete lnh[nick];\n        }, this);\n\n        added.each(function(nick) {\n            var index = nicks.indexOf(nick); //indx in sorted array\n            lnh[nick] = this.nickListAdd(nick, index) || 1;\n        }, this);\n    },\n\n    nickListAdd: function(nick, position) {},\n    nickListRemove: function(nick, stored) {},\n    historyExec: function(line) {\n        this.commandhistory.addLine(line);\n        this.client.exec(line, this.currentChannel);\n    },\n    focusChange: function(newValue) {\n        if (!(newValue !== true || (this.type & ui.WINDOW_LASTLINE)))\n            this.replaceLastPositionLine();\n    },\n    replaceLastPositionLine: function() {\n        if (this.parentObject.uiOptions.LASTPOS_LINE) {\n            if (!this.lastPositionLineInserted) {\n                // this.scrollAdd(this.lastPositionLine);\n            } else if (this.lines.lastChild !== this.lastPositionLine) {\n                try {\n                    this.lines.disown(this.lastPositionLine);\n                } catch (e) { /* IGNORE, /clear removes lastPositionLine from the dom without resetting it. */\n                }\n                // this.scrollAdd(this.lastPositionLine);\n            }\n        } else {\n            if (this.lastPositionLineInserted)\n                this.lines.disown(this.lastPositionLine);\n        }\n\n        this.lastPositionLineInserted = this.parentObject.uiOptions.LASTPOS_LINE;\n    }\n});\n\n\nui.QUI.Window = new Class({\n    Extends: ui.Window,\n    Binds: [\"close\", \"attach\", \"detach\", \"selectTab\", \"nickChange\", \"nickClick\", \"editTopic\", \"updatePrefix\"],\n\n    initialize: function(parentObject, client, type, name, identifier) {\n        var self = this;\n        self.parent(parentObject, client, type, name, identifier);\n\n\n        var qwindow = self.window;\n        qwindow.detached = self.detached = false;\n\n        var $tab = self.tab = Element.from(templates.ircTab({\n                'name': (name === BROUHAHA) ? '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' : name\n            })).inject(parentObject.tabs),\n            $tabDetach = $tab.getElement('.detach');\n\n        if(name === BROUHAHA) {\n            $tab.addClass('brouhaha');\n        }\n\n\n\n        // var elchanid = document.getElementById('channel-name-id');\n\n        $tab.addEvents({\n                focus: $tab.blur,\n                click: self.selectTab,\n                dblclick: function(e) {\n                    e.stop();\n\n                    if (self.closed)\n                        return;\n\n                    parentObject.selectWindow(self);\n                }\n            })\n            .store(\"window\", self);\n\n        $tabDetach.addEvent('click', self.detach);\n\n        if (!isBaseWindow(name)) {\n            // var tabclose = new Element(\"span\");\n            // tabclose.set(\"text\", \"X\");\n            // tabclose.addClass(\"tabclose\");\n            var $tabclose = Element.from(templates.tabClose()),\n                close = self.close;\n            //close window\n\n            $tabclose.addEvent(\"click\", close);\n            $tab.addEvent(\"mouseup\", function(e) {\n                    var button = Browser.Engine.trident ? 4 : 1;\n\n                    if (e.event.button === button)\n                        close(e);\n                })\n                .appendChild($tabclose);\n        }\n\n        var lines = self.lines = qwindow.middle;\n        // self.parentObject.qjsui.applyClasses(\"middle\", self.lines);\n        if (type !== ui.WINDOW_CUSTOM && type !== ui.WINDOW_CONNECT) {\n            qwindow.window.addClass('ircwindow');\n                // .set('id', 'mainircwindow');\n            self.fxscroll = new Fx.AutoScroll(lines, {\n            });\n            self.highlighter = new Highlighter(lines, { //highlight last 5 messages\n                filter: function($ele) {\n                    return $ele.hasClass('message') &&\n                        !$ele.hasClass('bot') &&\n                        !$ele.hasClass('command') &&//msg 2 bot\n                        !$ele.hasClass('our');//from us\n                },\n                selector: '.message:not(.bot):not(.command):not(.our)',\n                maxHighlight: NaN\n            });\n\n            lines.store(\"fxscroll\", self.fxscroll)\n                .store(\"client\", self.client);\n\n        } else {\n            qwindow.window.addClass(name.capitalize().replace(\" \", \"-\"));//Connection Details -> Connection-Details\n        }\n\n        // lines.addEvent(\"scroll\", function() {\n        //     self.scrolleddown = self.scrolledDown();\n        //     self.scrollpos = self.getScrollParent().getScroll();\n        // });\n\n        if (type === ui.WINDOW_CHANNEL) {\n            qwindow.window.addClass('channel');\n\n            qwindow.topic.html(templates.topicBar({topic:false}));\n            var topic = self.topic = qwindow.topic;\n            topic.addEvent(\"dblclick\", self.editTopic);\n            self.updateTopic(\"\");\n\n            var $nicklist = self.nicklist = qwindow.right;\n            $nicklist.addClass(\"nicklist\")\n                    // .addEvent(\"click\", self.removePrevMenu.bind(self))\n                    .addEvent(\"click:relay(a.user)\", self.nickClick)\n                    .addEvent(\"focus:relay(a)\", $nicklist.blur);\n\n\n            var $divider = self.divider = Element.from(templates.verticalDivider())\n                                                    .inject($nicklist, \"before\");\n            //cant create splitpane here because elements are still hidden\n        }\n\n        var properties = self.properties = Element.from(templates.channelName({channel: name}))\n                                                    .inject(qwindow.properties);\n\n        if(util.windowNeedsInput(type))\n            qwindow.bottom.appendChild(self.createInput());\n\n\n        self.nicksColoured = self.parentObject.uiOptions.NICK_COLOURS;\n        // self.reflow();\n    },\n\n    close: function(e) {\n        if(e)\n            e.stop();\n\n        if (this.closed)\n            return;\n\n        if (isChannelType(this.type) && (!isBaseWindow(this.name)) && !util.wasKicked()) {\n            var client = this.client,\n                channels = util.removeChannel(client.channels, this.name);\n\n            client.exec(\"/PART \" + this.name);\n            client.storeChannels(channels);\n        }\n        this.parent();\n\n        this.parentObject.tabs.disown(this.tab);\n\n        if(this.detached) {\n            this.wrapper.destroy();\n        } else {\n            this.window.window.destroy();\n        }\n\n        // this.tab.dispose();\n        // this.reflow();\n    },\n\n    attach: function(e) {\n        var win = this.window.window,\n            wrapper = this.wrapper,\n            po = this.parentObject;\n\n        this.window.detached = this.detached = false;\n\n        wrapper.hide();\n        win.hide();\n        // wrapper.removeChild(win);\n        win.replaces(wrapper);\n        wrapper.destroy();\n\n        this.drag.detach().stop();\n        this.resizable.detach().stop();\n        this.wrapper = this.resizable = this.drag = undefined;\n\n        this.tab.show();\n        this.select();\n    },\n\n    detach: function(e) {\n        var self = this,\n            win = self.window.window,\n            po = self.parentObject,\n            qjsui = po.qjsui,\n\n            wrapper = self.wrapper = Element.from(templates.detachedWindow({\n                                                                'channel': this.name,\n                                                                'base': util.isBaseWindow(this.name)\n                                                            })),\n            header = wrapper.getElement('.header'),\n            attach = header.getElement('.attach'),\n            close = header.getElement('.tab-close'),\n\n            resizeWrapper = Element.from(templates.resizeHandle()),\n            resizeHandle = resizeWrapper.getElement('.resize-handle'),\n\n            setActive = function(e) {\n                po.windowArray.each(function(win) {\n                    if(win.detached)\n                        win.wrapper.removeClass('active');\n                });\n                wrapper.addClass('active');\n            };\n\n        attach.addEvent('click', self.attach);\n        if(close) {\n            close.addEvent('click', self.close);\n        }\n\n        //change window if we're active\n        if(self.active)\n            po.nextWindow(1, self);\n\n        var size = util.percentToPixel({x:40, y:60}, qjsui.parent);\n        wrapper.setStyles({\n                \"width\": size.x,\n                \"height\": size.y\n            })\n            .wraps(win) //*** adds wrapper to dom\n            .adopt(resizeWrapper);\n        win.show()\n            .addEvent(\"mousedown\", Event.stopPropagation);//prevent draggin occurring while clickin window\n        setActive();\n\n        self.resizable = wrapper.makeResizable({\n                                limit: {//min/max\n                                    x: [400, null],\n                                    y: [200, null]\n                                },\n                                handle: resizeHandle,\n                                stopPropagation: true\n                            });\n        self.drag = wrapper.makeDraggable({\n                                handle: wrapper,\n                                includeMargins: true\n                            });\n\n        wrapper.addEvents({\n            click: setActive\n        });\n\n\n        self.selectUpdates();\n\n        // util.centerElement(wrapper, qjsui.parent);\n        wrapper.position();\n\n        self.detached = self.window.detached = true;\n\n        //keeps order\n        self.tab.hide();\n    },\n\n    selectTab: function(e) {\n        var self = this;\n        if(self.name !== BROUHAHA) {\n            self.parentObject.windowArray.each(function(win) {\n                if(!win.detached && (!e || e.type !== \"click\" || win.name !== BROUHAHA)) {//keep brouhaha selected if its from a single click\n                    win.tab.swapClass(\"tab-selected\", \"tab-unselected\");\n                }\n                if(win.name === BROUHAHA) {\n                    if(util.isChannelType(self.type)) {\n                        win.properties.text(self.name); //update current channel in brouhaha\n                        win.currentChannel = self.name;\n                    }\n                }\n            });\n        }\n        irc.activeChannel = self.name;\n        self.tab.removeClasses(\"tab-hilight-activity\", \"tab-hilight-us\", \"tab-hilight-speech\")\n                .swapClass(\"tab-unselected\", \"tab-selected\");\n    },\n\n    select: function() {\n        this.selectTab();\n\n        //changing windows occurs here\n        this.parentObject.setWindow(this.window);\n\n        // this.reflow();\n        this.parent();\n\n        this.selectUpdates();\n    },\n\n    //styles and ui things to update\n    selectUpdates: function() {\n        var self = this,\n            parentObject = self.parentObject;\n\n        if(self.nicklist && !self.split) {\n            // (function() { //wait a sec for the styles to be calculated\n            //     self.split = new Drag.SplitPane(self.divider, {\n            //         // store: new Storage('__panelwidth')\n            //     });\n            // }).delay(50);\n        }\n\n        if(self.fxscroll) {//scroll to bottom\n            self.fxscroll.autoScroll();\n        }\n\n        if (util.windowNeedsInput(self.type)) {\n            util.fillContainer(self.$inputbox);\n            self.$inputbox.focus();\n        }\n\n        if(util.isChannelType(self.type)) {\n            if (self.nicksColoured !== parentObject.uiOptions.NICK_COLOURS) {\n                self.nicksColoured = parentObject.uiOptions.NICK_COLOURS;\n\n                var nodes = self.nicklist.childNodes;\n                if (parentObject.uiOptions.NICK_COLOURS) {\n                    Array.each(nodes, function(node) {\n                        var colour = util.toHSBColour(node.retrieve(\"nick\"), self.client);\n                        if ($defined(colour))\n                            node.firstChild.setStyle(\"color\", colour.rgbToHex());\n                    });\n                } else {\n                    Array.each(nodes, function(node) {\n                        node.firstChild.setStyle(\"color\", null);\n                    });\n                }\n            }\n\n            self.updatePrefix();\n        }\n\n    },\n\n    deselect: function() {\n        this.parent();\n\n        this.tab.swapClass(\"tab-selected\", \"tab-unselected\");\n    },\n\n    editTopic: function() {\n        if (!this.client.nickOnChanHasPrefix(this.client.nickname, this.name, \"@\")) {\n/*      var cmodes = this.client.getChannelModes(channel);\n      if(cmodes.indexOf(\"t\")) {*/\n            return alert(lang.needOp.message); /*}*/\n        }\n        var newTopic = prompt(util.formatter(lang.changeTopicConfirm.message, {channel: this.name}), this.topic.topicText);\n        if (!$defined(newTopic))\n            return;\n\n        this.client.exec(\"/TOPIC \" + newTopic);\n    },\n\n    //creates the input box on the bottom\n    createInput: function() {\n        var self = this,\n            parentO = self.parentObject,\n\n            inputtype = Browser.isMobile ?  \"mobile-input\": \"keyboard-input\",\n\n            nick = self.client.nickname,\n\n            $form = Element.from(templates.ircInput({'nick': nick, 'status': '', type: inputtype})),\n            $nicklabel = self.$nicklabel = $form.getElement('.nickname'),\n            $inputbox = self.$inputbox = $form.getElement('.input-field'),\n            $inputbtn = $form.getElement('.input-button'),\n\n            sendInput = function(e) {\n                if(e)\n                    e.stop();\n                if ($inputbox.value.trim() !== \"\") {\n                    parentO.resetTabComplete();\n                    self.historyExec($inputbox.value);\n                    $inputbox.value = \"\";\n                }\n                $inputbox.focus();\n            }\n\n        if (Browser.isMobile) {\n            $inputbtn.addClass(\"mobile-button\");\n        } else {\n            $inputbox.addEvents({\n                blur: function() {\n                    window.keyboardInputFocus = 0;\n                },\n                focus: function() {\n                    window.keyboardInputFocus = 1;\n                }\n            });\n        }\n\n        var resettab = parentO.resetTabComplete,\n            complete = function(e) {\n                var resultfn;\n                var cvalue = $inputbox.value;\n\n                if (e.key === \"up\") {\n                    resultfn = self.commandhistory.upLine;\n                } else if (e.key === \"down\") {\n                    resultfn = self.commandhistory.downLine;\n                } else if (e.key === \"tab\" && !e.ctrl) {\n                    e.stop();\n                    self.tabComplete($inputbox);\n                    return;\n                } else { /* ideally alt and other keys wouldn't break self */\n                    parentO.resetTabComplete();\n                    return;\n                }\n                e.stop();\n\n                parentO.resetTabComplete();\n                if ((!!cvalue) && (self.lastcvalue !== cvalue))\n                    self.commandhistory.addLine(cvalue, true);\n\n                var result = resultfn.call(self.commandhistory);//.bind(self.commandhistory)();\n\n                if (!result)\n                    result = \"\";\n                self.lastcvalue = result;\n\n                $inputbox.value = result;\n                util.setAtEnd($inputbox);\n            };\n\n        if(isChannelType(self.type)) {\n            self.client.addEvents({\n                \"mode\": self.updatePrefix\n            });\n        }\n\n        $nicklabel.addEvent(\"dblclick\", function() {\n            var nick = prompt(\"Enter a new nickname\", self.nickname);\n            if(nick) {\n                self.client.exec(\"/nick \" + nick);\n            }\n        });\n\n        $inputbtn.addEvent(\"click\", sendInput);\n        $form.addEvent(\"submit\", sendInput);\n        $inputbox.addEvents({\n                    \"focus\": resettab,\n                    \"mousedown\": resettab,\n                    \"keydown\": complete\n                    });\n        return $form;\n    },\n\n    updatePrefix: function (data) {\n        var prefix;\n        if(data) {\n            if(data.channel === this.name)\n                prefix = data.prefix;\n            else return;\n        } else {\n            prefix = this.client.getNickStatus(this.name, this.client.nickname)\n        }\n        this.$nicklabel.getElement('.status')\n                        .removeClasses('op', 'voice')\n                        .addClass((prefix === OPSTATUS) ? \"op\" : (prefix === VOICESTATUS) ? \"voice\" : \"\")\n        util.fillContainer(this.$inputbox);\n    },\n\n    nickClick: function(evt, $tar) { //delegation to nick items\n        var hasMenu = $tar.hasClass('selected-middle');\n\n        this.removePrevMenu(); //collapse old menus\n        if (!hasMenu) {\n            this.moveMenuClass($tar);\n            $tar.addClass(\"selected\")\n                .store(\"menu\", this.createMenu($tar.retrieve(\"nick\"), $tar));\n        }\n    },\n\n    // - clicking user in nick list\n    createMenu: function(nick, $parent) {\n        var pmenu = $parent.retrieve('menu');\n        if(pmenu) {\n            return pmenu.toggle();\n        }\n\n        var $menu = Element.from(templates.menuContainer()),\n            self = this;\n\n        (ui.MENU_ITEMS.filter(function(item) {\n            var pred = item.predicate;\n\n            return ($type(pred) === 'function') ? pred.call(self, nick) : //pred.apply(this, nickArray)\n                                                  !!pred;\n        })).each(function(item) {\n            Element.from(templates.nickbtn({'nick': \"- \" + item.text}))\n                    .store(\"action\", item.fn)\n                    .inject($menu);\n        });\n\n        $menu.addEvent('click:relay(.user)', function(e, target) {\n                e.stop();\n                self.menuClick(target.retrieve(\"action\"));\n            })\n            .addEvent('focus:relay(a)', Element.prototype.blur)\n            .inject($parent);\n\n        return $menu;\n    },\n\n    menuClick: function(fn) {\n        var selected = this.nicklist.getElement('.selected');\n        //i dont understand why these arent equivalent\n        fn.call(this, selected.retrieve(\"nick\"));\n        this.removePrevMenu();\n    },\n\n    moveMenuClass: function($sel) {\n        $sel = $($sel) || this.nicklist.getElement('.selected-middle, .selected');\n        if (!$sel){}\n        else if (this.nicklist.firstChild === $sel) {\n            $sel.removeClass(\"selected-middle\");\n        } else {\n            $sel.addClass(\"selected-middle\");\n        }\n    },\n\n    removePrevMenu: function() {\n        var $sel = this.nicklist.getElements('.selected-middle, .selected');\n        if ($sel) {\n            $sel.removeClasses(\"selected\", \"selected-middle\");\n            var $menu = $sel.retrieve('menu');\n            if ($menu) {\n                $menu.dispose();\n                $sel.eliminate('menu');\n            }\n        }\n    },\n\n    nickListAdd: function(nick, position) {\n        var realNick = util.stripPrefix(this.client.prefixes, nick);\n\n        var nickele = Element.from(templates.nickbtn({'nick': nick}));\n        var span = nickele.getElement('span');\n        nickele.store(\"nick\", realNick);\n\n\n        if (this.parentObject.uiOptions.NICK_COLOURS) {\n            var colour = util.toHSBColour(realNick, this.client);\n            if ($defined(colour))\n                span.setStyle(\"color\", colour.rgbToHex());\n        }\n\n        this.nicklist.insertAt(nickele, position);\n        this.moveMenuClass();\n\n        return nickele;\n    },\n\n    nickListRemove: function(nick, stored) {\n        try {\n            this.nicklist.removeChild(stored);\n            this.moveMenuClass();\n        } catch (e) {\n        }\n    },\n\n    updateTopic: function(topic) {\n        var topice = this.topic.empty();\n\n        topice.topicText = topic;\n        if (topic) {\n            this.parent(topic, topice);\n        } else {\n            topice.html(templates.topicText({topic:lang.noTopic.message, empty:true}));\n        }\n        // this.reflow();\n    },\n\n    //TODO do all processing in template?\n    addLine: function(type, line, colourClass) {\n        // var e = new Element(\"div\");\n        var eclass = colourClass || (this.lastcolour ? \"linestyle1\" : \"linestyle2\");\n\n        var msge = Element.from(templates.ircMessage({styles: eclass, message: line}));\n        this.lastcolour = !this.lastcolour;\n\n        this.parent(type, line, colourClass, msge);\n        // this.reflow();\n    },\n    highlightTab: function(state) {\n        this.parent(state);\n\n        if (state == this.hilighted)\n            return;\n\n        //inefficient as fuck\n        this.tab.removeClasses(\"tab-hilight-activity\", \"tab-hilight-us\", \"tab-hilight-speech\");\n\n        switch (state) {\n        case ui.HILIGHT_US:\n            this.tab.addClass(\"tab-hilight-us\");\n            break;\n        case ui.HILIGHT_SPEECH:\n            this.tab.addClass(\"tab-hilight-speech\");\n            break;\n        case ui.HILIGHT_ACTIVITY:\n            this.tab.addClass(\"tab-hilight-activity\");\n            break;\n        }\n    }\n});\n\n//close the iife and call with this\n})(this);\n",
			"file": "js/qwebirc.js",
			"file_size": 275189,
			"file_write_time": 130190242529144315,
			"settings":
			{
				"buffer_size": 266706,
				"line_ending": "Windows"
			}
		},
		{
			"file": "js/contentscript.js",
			"settings":
			{
				"buffer_size": 5456,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/JSHint/JSHint.sublime-build",
	"command_palette":
	{
		"height": 104.0,
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"run",
				"Grunt"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"cdn",
				"Cdnjs: Import Script"
			],
			[
				"javascrip",
				"Set Syntax: JavaScript"
			],
			[
				"consol",
				"Set Syntax: R Console"
			]
		],
		"width": 504.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/qwebirc.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/manifest.json",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/helpers.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/window/1window.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/window/2quiwindow.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/2StandardUI.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/Handlebars/Templates.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/util/6urlifcate.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/util/urlifier.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/Urlerizer.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/6QUI.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/3notifiers.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/irc/ircclient.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/css/modifiablecss.mcss",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/2mootools-more-1.4.0.1 (1).js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/autoscroll.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/optionconfig.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/irc/baseclient.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/1mootools-core-1.4.5.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/resizeable.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/native-mods.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/libs/highlighter.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/util/4ircutils.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/irc/Interface.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/Colorise.js",
		"/C/Users/Dynomite/AppData/Roaming/Sublime Text 3/Packages/SideBarEnhancements/Side Bar.sublime-settings",
		"/C/Users/Dynomite/AppData/Roaming/Sublime Text 3/Packages/User/Side Bar.sublime-settings",
		"/C/Users/Dynomite/AppData/Roaming/Sublime Text 3/Packages/CommandOnSave/Base File.sublime-settings",
		"/C/Users/Dynomite/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/misc.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/gruntfile.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/5QNui.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/irc/sounds.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/1window.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/js/src/ui/4loginui.js",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/qwebirc-upate/build.bat",
		"/D/Users/Dynomite/Dropbox/Programming/extensions/tfirc/extension0.93/js/src/ui/helpers.js",
		"/D/Users/Dynomite/Documents/GitHub/demo/index.html",
		"/D/Users/Dynomite/Documents/GitHub/mariofischer-cwcomplete-764c285/Demo/index.html",
		"/D/Users/Dynomite/Documents/GitHub/mariofischer-cwcomplete-764c285/Source/cwcomplete.js"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"js/",
			"page",
			"unload",
			"send",
			"window.ctrl",
			"ctrl",
			"\",",
			",",
			".addEvent(",
			")",
			"addTab",
			"T",
			"a",
			"this",
			"rawnumeric",
			"rawNumeric",
			"channelElement",
			"win",
			"self",
			"serverPassword",
			"gamesurge",
			"recv",
			"\"recv\"",
			"irc_PRIVMSG",
			"__timeout",
			"self.initialNickname",
			"initialNickname",
			"recv",
			"x",
			"disconnect",
			".connection",
			"connection",
			"conn",
			"list",
			"to",
			"self",
			"message",
			"channel",
			"getActiveWindow",
			"c",
			"getActiveWindow",
			"target",
			"getActiveWindow",
			"chan",
			"args",
			"fn",
			"cmdopts",
			"command",
			"self",
			"historyExec",
			"history",
			"getNickname()",
			"h",
			"mapper",
			"ui.themes.Default",
			"$C",
			"$n",
			"$@",
			"$)",
			"$(",
			"$w",
			"$[",
			"$]",
			"$t",
			"],\n",
			"[",
			"$O",
			"$B",
			"$h",
			"{B}",
			"$B",
			"$x",
			"$N",
			"{B}",
			"$m",
			"$c",
			"$C",
			"$c",
			"$v",
			"$}",
			"${",
			"{",
			"\"{\":",
			"{",
			"new hash",
			"hash",
			"hash.imp",
			"hash.imple",
			"hash",
			"opts",
			"new ui.theme",
			"containerSize",
			"10",
			"hl_line",
			"containsNick",
			"hilight",
			"addline",
			"colourClass",
			"addline",
			"colour",
			"info",
			"else if",
			"text",
			"result",
			"this",
			"text",
			"appendfn",
			"qwebirc:",
			"punct_re",
			"appendChan",
			"soundinit",
			"appendText",
			"user",
			"appendChild(document.createTextNode",
			"createTextNode",
			" != -1",
			"indexOf",
			"Element",
			"element",
			"Element",
			"element",
			"appendChan",
			"execfn",
			"window.",
			"lines",
			"store",
			"whois",
			"uiOptions"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"folders":
	[
		{
			"follow_symlinks": true,
			"path": "D:\\Users\\Dynomite\\Dropbox\\Programming\\extensions\\tfirc\\qwebirc-upate"
		}
	],
	"groups":
	[
		{
			"selected": 21,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "js/src/ui/misc.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11152,
						"regions":
						{
						},
						"selection":
						[
							[
								4875,
								4879
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1600.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "js/src/util/1constants.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4231,
						"regions":
						{
						},
						"selection":
						[
							[
								3950,
								3950
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 966.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "js/src/util/2lang.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7942,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2048.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "js/libs/2mootools-more-1.4.0.1 (1).js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 107026,
						"regions":
						{
						},
						"selection":
						[
							[
								68592,
								68592
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 39834.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "js/libs/1mootools-core-1.4.5.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 161160,
						"regions":
						{
						},
						"selection":
						[
							[
								116343,
								116351
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 58070.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "js/src/irc/commands_utils.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14568,
						"regions":
						{
						},
						"selection":
						[
							[
								3783,
								3783
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1410.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "css/modifiablecss.mcss",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15216,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/CSS/CSS.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5694.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "js/src/ui/window/2quiwindow.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19688,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4966.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "js/src/ui/window/1window.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8161,
						"regions":
						{
						},
						"selection":
						[
							[
								7203,
								7203
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2716.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "js/src/irc/ircclient.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31557,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 13833.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "js/src/irc/baseclient.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18014,
						"regions":
						{
						},
						"selection":
						[
							[
								1213,
								1213
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 42.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "js/src/irc/ircconnection.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9598,
						"regions":
						{
						},
						"selection":
						[
							[
								1435,
								1435
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 546.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "js/src/ui/6QUI.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14744,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5050.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "js/src/ui/helpers.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3478,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 791.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "js/src/ui/4loginui.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7303,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "js/src/ui/1BaseUI.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5522,
						"regions":
						{
						},
						"selection":
						[
							[
								5522,
								5522
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1620.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "js/hacks.min.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 470402,
						"regions":
						{
						},
						"selection":
						[
							[
								1009,
								1009
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "js/src/irc/Interface.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11499,
						"regions":
						{
						},
						"selection":
						[
							[
								4403,
								4403
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1218.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "gruntfile.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3187,
						"regions":
						{
						},
						"selection":
						[
							[
								1905,
								1905
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 210.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "js/src/qwebirc_end.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 46,
						"regions":
						{
						},
						"selection":
						[
							[
								45,
								45
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "js/qwebirc.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 266706,
						"regions":
						{
						},
						"selection":
						[
							[
								50660,
								50660
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 20906.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "js/contentscript.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5456,
						"regions":
						{
						},
						"selection":
						[
							[
								3929,
								3929
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1018.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 29.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 88.0
	},
	"project": "",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"_end",
				"js\\src\\qwebirc_end.js"
			],
			[
				"inter",
				"js\\src\\irc\\Interface.js"
			],
			[
				"base",
				"js\\src\\irc\\baseclient.js"
			],
			[
				"baseui",
				"js\\src\\ui\\1BaseUI.js"
			],
			[
				"login",
				"js\\src\\ui\\4loginui.js"
			],
			[
				"quiwi",
				"js\\src\\ui\\window\\2quiwindow.js"
			],
			[
				"helper",
				"js\\src\\ui\\helpers.js"
			],
			[
				"qui",
				"js\\src\\ui\\6QUI.js"
			],
			[
				"constant",
				"js\\src\\util\\1constants.js"
			],
			[
				"connect",
				"js\\src\\irc\\ircconnection.js"
			],
			[
				"irccl",
				"js\\src\\irc\\ircclient.js"
			],
			[
				"window",
				"js\\src\\ui\\window\\1window.js"
			],
			[
				"quiwin",
				"js\\src\\ui\\window\\2quiwindow.js"
			],
			[
				"modif",
				"css\\modifiablecss.mcss"
			],
			[
				"command",
				"js\\src\\irc\\commands_utils.js"
			],
			[
				"mooto",
				"js\\libs\\1mootools-core-1.4.5.js"
			],
			[
				"more",
				"js\\libs\\2mootools-more-1.4.0.1 (1).js"
			],
			[
				"lang",
				"js\\src\\util\\2lang.js"
			],
			[
				"constants",
				"js\\src\\util\\1constants.js"
			],
			[
				"misc",
				"js\\src\\ui\\misc.js"
			],
			[
				"auto",
				"js\\libs\\autoscroll.js"
			],
			[
				"mcss",
				"css\\modifiablecss.mcss"
			],
			[
				"irc",
				"js\\src\\irc\\ircclient.js"
			],
			[
				"url",
				"js\\libs\\Urlerizer.js"
			],
			[
				"standard",
				"js\\src\\ui\\2StandardUI.js"
			],
			[
				"notif",
				"js\\src\\ui\\3notifiers.js"
			],
			[
				"opti",
				"js\\src\\ui\\optionconfig.js"
			],
			[
				"urlif",
				"js\\src\\util\\urlifier.js"
			],
			[
				"urli",
				"js\\src\\util\\6urlifcate.js"
			],
			[
				"templates",
				"js\\src\\ui\\Handlebars\\Templates.js"
			],
			[
				"colo",
				"js\\src\\ui\\Colorise.js"
			],
			[
				"ircutil",
				"js\\src\\util\\4ircutils.js"
			],
			[
				"temp",
				"js\\src\\ui\\Handlebars\\Templates.js"
			],
			[
				"template",
				"js\\src\\ui\\Handlebars\\Templates.js"
			],
			[
				"native",
				"js\\libs\\native-mods.js"
			],
			[
				"high",
				"js\\libs\\highlighter.js"
			],
			[
				"autoscro",
				"js\\libs\\autoscroll.js"
			],
			[
				"res",
				"js\\libs\\resizeable.js"
			],
			[
				"ircclient",
				"js\\src\\irc\\ircclient.js"
			],
			[
				"mootoolscore",
				"js\\libs\\1mootools-core-1.4.5.js"
			],
			[
				"notifi",
				"js\\src\\ui\\3notifiers.js"
			],
			[
				"sounds",
				"js\\src\\irc\\sounds.js"
			],
			[
				"autos",
				"js\\libs\\autoscroll.js"
			],
			[
				"helpers",
				"js\\src\\ui\\helpers.js"
			],
			[
				"resi",
				"extension0.93\\js\\libs\\resizeable.js"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 206.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
